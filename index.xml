<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker Pirates ARMed with explosive stuff</title>
    <link>https://blog.hypriot.com/index.xml</link>
    <description>Recent content on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Apr 2017 14:30:34 -0600</lastBuildDate>
    <atom:link href="https://blog.hypriot.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>DockerCon 2017 Demo: Monitoring Docker Swarm with LED&#39;s</title>
      <link>https://blog.hypriot.com/post/dockerconaustin2017/</link>
      <pubDate>Thu, 20 Apr 2017 14:30:34 -0600</pubDate>
      
      <guid>https://blog.hypriot.com/post/dockerconaustin2017/</guid>
      <description>&lt;p&gt;At DockerCon 2017 in Austin I gave a presentation of a Raspberry Pi cluster mixed with some UP boards. The audience really liked the visual effects of the Docker Swarm scaling a service up and down. So I show you some background details what you need to run that demo on your Raspberry Pi cluster as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/stage2.jpg&#34; alt=&#34;PiCloud at DockerCon Austin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;All the effort played off to build that cluster, to find out how to drive LED&amp;rsquo;s in swarm mode, to put it into my bag and go through customs on my flight from Germany to Austin, Texas. It really was fun to show this the audience and everybody liked it.&lt;/p&gt;

&lt;p&gt;To enable you to replay the demo with some Pimoroni Blinkt! LED&amp;rsquo;s and Raspberry Pi - regardless if you only have Pi Zeros I want to show you the Docker images I used and the commands to show the scaling demo.&lt;/p&gt;

&lt;p&gt;The Docker image &lt;a href=&#34;https://hub.docker.com/r/stefanscherer/monitor/&#34;&gt;stefanscherer/monitor&lt;/a&gt; is available on the Docker Hub. It is a multi-architecture image that can be used on Linux with Intel or ARM CPU&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;So just create a Docker swarm with the usual commands &lt;code&gt;docker swarm init&lt;/code&gt; and then join some other workers with the swarm token shown in your terminal.&lt;/p&gt;

&lt;h2 id=&#34;start-the-led-monitor&#34;&gt;Start the LED monitor&lt;/h2&gt;

&lt;p&gt;First we have to start the LED monitor as a service so that it is running on each node of the Docker swarm. The option &lt;code&gt;--mode global&lt;/code&gt; will do this and start one instance on each node. We have to bind mount both the Docker socket and a part of the file system into the container so it can access the &lt;code&gt;/sys/class/fs&lt;/code&gt; file system.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service create --name monitor --mode global \
  --restart-condition any --mount type=bind,src=/sys,dst=/sys \
  --mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
  stefanscherer/monitor:1.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are all set to play with scaling an example service.&lt;/p&gt;

&lt;h2 id=&#34;scale-up&#34;&gt;Scale up&lt;/h2&gt;

&lt;p&gt;There is another multi-arch image that I used for the scaling demo. It is the &amp;ldquo;whoami&amp;rdquo; web service that responds the container&amp;rsquo;s hostname.&lt;/p&gt;

&lt;p&gt;First we create the service with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service create --name whoami stefanscherer/whoami:1.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As said this works with any Raspberry Pi or the UP board that has an Intel Atom CPU.
After the image has been downloaded the LED monitor should show one yellow LED lighting up.&lt;/p&gt;

&lt;p&gt;Now scale the service a little more eg. to the number of nodes you have to have one LED lighting up per node.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then scale it up a little more&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/scale-up.gif&#34; alt=&#34;Scale up&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And then light up all the LED&amp;rsquo;s by scaling up to the number of LED&amp;rsquo;s you have.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=32
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rolling-update&#34;&gt;Rolling update&lt;/h2&gt;

&lt;p&gt;Another thing that can be visualized is a rolling update. The LED monitor shows each container with a yellow color for version 1.1.0 of the service and blue for version 1.2.0.&lt;/p&gt;

&lt;p&gt;So start the rolling update by specifing &lt;code&gt;--update-parallelism&lt;/code&gt; with the number of containers that should be replaced in one step. So Docker Swarm kills that number of containers and starts the new version of it before stopping the next bulk of containers. Use the &lt;code&gt;--image&lt;/code&gt; option to specifiy the new version that should be used by the whoami service.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service update --update-parallelism 5 \
  --image stefanscherer/whoami:1.2.0 whoami
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now watch what happens. Each destroyed container lights up red and then dims. After a while Docker swarm manager starts the new version and so new LED&amp;rsquo;s with blue light up. After a while all LED&amp;rsquo;s have changed from yellow (version 1.1.0) to blue (version 1.2.0). And while this rolling update is going on you still can use this &amp;ldquo;whoami&amp;rdquo; service by curl&amp;rsquo;ing it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/rolling-update.gif&#34; alt=&#34;Rolling update&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;scale-down-to-one&#34;&gt;Scale down to one&lt;/h2&gt;

&lt;p&gt;Another nice effect is to scale down the service back to one as all LED&amp;rsquo;s will flash up in red and only one LED remains blue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/scale-down-to-one.gif&#34; alt=&#34;Scale down to one&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hope I did make you curious to try it out on your own cluster. Happy hacking and have fun! If you want to improve the visual effects have a look at the Node.js sources in the &lt;a href=&#34;https://github.com/StefanScherer/swarm-monitor&#34;&gt;GitHub repo&lt;/a&gt;. Rewrite it in Golang or anything else and suprise me with other nice visual effects.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building a 64bit Docker OS for the Raspberry Pi 3</title>
      <link>https://blog.hypriot.com/post/building-a-64bit-docker-os-for-rpi3/</link>
      <pubDate>Thu, 02 Mar 2017 11:28:42 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/building-a-64bit-docker-os-for-rpi3/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m happy to announce the start of a &amp;ldquo;short&amp;rdquo; workshop were I&amp;rsquo;m going through all the steps to build a complete 64bit operating system for the Raspberry Pi 3. This 64bit HypriotOS is mainly focused on running Docker containers easily on this popular DIY and IoT device.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/e/e6/Raspberry-Pi-3-Flat-Top.jpg&#34; alt=&#34;Raspi3-Image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll see that I&amp;rsquo;m using Docker heavily for each and every build step, because it really helps us a lot to run a local build with &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;Docker-for-Mac&lt;/a&gt; or later on the cloud build servers at &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/building-a-64bit-docker-os-for-rpi3/bee42-workshop.jpg&#34; alt=&#34;bee42-workshop.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This workshop is sponsored by &lt;a href=&#34;http://bee42.com&#34;&gt;bee42 solutions&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bee42solutions&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @bee42solutions&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background-and-contents&#34;&gt;Background and Contents&lt;/h3&gt;

&lt;p&gt;As you may already know, a complete Linux operating system consists of several important building blocks and I&amp;rsquo;d like to show you how to build all of these step by step.&lt;/p&gt;

&lt;p&gt;For this purpose I&amp;rsquo;m not going to reinvent the wheel and so I&amp;rsquo;ll reuse all of the existing parts which are already published by the Raspberry Pi Organisation, by the Debian Linux project and will add some more glue code.&lt;/p&gt;

&lt;p&gt;At the end you should have learned how to build all the necessary parts and how to automatically create a finished SD card image which could be flashed on an empty SD card. Then boot your Raspberry Pi 3 with and in less than a minute you have a fully running Docker Engine on a Debian-based 64bit Linux OS.&lt;/p&gt;

&lt;p&gt;Here is a short overview of the contents of the workshop:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 1: Bootloader&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 2: Kernel&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 3: Root filesystem&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 4: SD Card Image&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, that&amp;rsquo;s enough for explaining the background of this workshop. For more informations please follow along the details I&amp;rsquo;ll publish on the coming tweets at Twitter and in the GitHub repos until all the parts of this workshop are finished and available as OpenSource.&lt;/p&gt;

&lt;p&gt;Please be aware that this OS is in a development phase and far from being perfect. So you are encouraged to help me with reporting issues and filing pull-requests to add features and fix bugs.&lt;/p&gt;

&lt;h3 id=&#34;further-links&#34;&gt;Further Links&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to publish all the details and steps to build the new operating system in a public GitHub repo. All other details and necessary GitHub repos will be linked here in this section as a future reference.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Workshop Repo&lt;/strong&gt; &lt;a href=&#34;https://github.com/dieterreuter/workshop-raspberrypi-64bit-os&#34;&gt;https://github.com/dieterreuter/workshop-raspberrypi-64bit-os&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So please stay tuned, this link list will be extended over the next few days.&lt;/p&gt;

&lt;h3 id=&#34;acknowledgments&#34;&gt;Acknowledgments&lt;/h3&gt;

&lt;p&gt;Please follow along the detailed tweets about this workshop via&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; &lt;a href=&#34;https://twitter.com/Quintus23M&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @Quintus23M&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt; &lt;a href=&#34;https://twitter.com/HypriotTweets&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @HypriotTweets&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/bee42solutions&#34;&gt;@bee42solutions&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bee42solutions&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @bee42solutions&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Special thanks goes to &lt;a href=&#34;http://bee42.com&#34;&gt;bee42 solutions&lt;/a&gt; for giving me the time to work on this awesome topic to build a complete Docker-enabled 64bit OS for the Raspberry Pi 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/building-a-64bit-docker-os-for-rpi3/bee42-logo.jpg&#34; alt=&#34;bee42-logo.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Let&#39;s build the smallest possible Docker image</title>
      <link>https://blog.hypriot.com/post/build-smallest-possible-docker-image/</link>
      <pubDate>Wed, 22 Feb 2017 09:18:35 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/build-smallest-possible-docker-image/</guid>
      <description>&lt;p&gt;Imagine what happens if we&amp;rsquo;re starting to use Docker containers on IoT devices. On small and slow devices with limited system resources and connected via a damn slow network connection we do have to care differently on how to build and ship our apps. In these circumstances it pays off and it&amp;rsquo;s absolutely essential to optimize our applications and the resulting Docker images for size.&lt;/p&gt;

&lt;p&gt;SIZE DOES MATTER&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/build-smallest-possible-docker-image/docker-image-minimal.png&#34; alt=&#34;docker-image-minimal.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re doing it right we&amp;rsquo;ll get a lot of benefits such as blasting fast download speed for updating to a new or more secured version. On wireless networks we are also reducing the costs for data transfers as well.&lt;/p&gt;

&lt;p&gt;According to my &lt;a href=&#34;https://twitter.com/quintus23m/status/834132186211180544&#34;&gt;tweet&lt;/a&gt; I&amp;rsquo;d like to start a new Docker challenge:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How small is the smallest Docker image we could build, which prints a &amp;ldquo;Hello Docker World!&amp;rdquo;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Sometimes developing directly on an IoT device can be pretty hard or nearly impossible due to the lack of enough system resources. These resources can be the amount of memory, disk space or CPU capacity - or it can be just a limited network connectivity over a low-bandwith 64kbit/sec wireless network.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s assume we do have a Raspberry Pi already deployed in the field and this IoT device has such a low-bandwidth network connection. We&amp;rsquo;re preparing our developing system to run on a bare-metal cloud server and we are transfering our build artefacts as ready-to-run Docker images regularly with each and every new release in a DevOps driven manner. For this reason we&amp;rsquo;d like to speed up the deployment with minimized Docker image sizes.&lt;/p&gt;

&lt;p&gt;Wait, I thought a Docker image can be pretty heavy with up to 1 GByte or even larger? Well, that could happen if we&amp;rsquo;re packing a whole Operating System like Ubuntu or Debian into our Docker images. But as we&amp;rsquo;re building an IoT application we should take care about that situation. A Docker image can instead be build with an app consisting of a statically linked binary and when we start it as a Docker container it will run a single Linux process only.&lt;/p&gt;

&lt;h3 id=&#34;creating-our-app-in-arm-assembly&#34;&gt;Creating our App in ARM assembly&lt;/h3&gt;

&lt;p&gt;TL;DR all the source code and build instructions can be found in this public &lt;a href=&#34;https://github.com/DieterReuter/dockerchallenge-smallest-image&#34;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here is my starting example of an assembly program which just prints a single static text string. It is written in ARM assembly language and should be compiled into a really small binary we can run on any ARMv7 device.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat hello.S
.data
msg:
    .ascii      &amp;quot;Hello Docker World!\n&amp;quot;
len = . - msg

.text

.globl _start
_start:
    /* syscall write(int fd, const void *buf, size_t count) */
    mov     %r0, $1     /* fd -&amp;gt; stdout */
    ldr     %r1, =msg   /* buf -&amp;gt; msg */
    ldr     %r2, =len   /* count -&amp;gt; len(msg) */
    mov     %r7, $4     /* write is syscall #4 */
    swi     $0          /* invoke syscall */

    /* syscall exit(int status) */
    mov     %r0, $0     /* status -&amp;gt; 0 */
    mov     %r7, $1     /* exit is syscall #1 */
    swi     $0          /* invoke syscall */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s compile and link it as a static program&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ as -o hello.o hello.S
$ ld -s -o hello hello.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show details about the binary&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ file hello
hello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now as we do have our app as a single binary program, we can build our smallest Docker image easily from scratch. This new Docker image consists only our binary and nothing else of other components at all. But you have to know this only works if the binary is statically linked and has all necessary tools baked in.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat Dockerfile.armhf
FROM scratch
ADD hello /hello
CMD [&amp;quot;/hello&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Building the Docker image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t dieterreuter/hello -f Dockerfile.armhf .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;starting-point&#34;&gt;Starting point&lt;/h3&gt;

&lt;p&gt;With all the details I&amp;rsquo;ve shown above in this blog post I finally built a first super-small Docker image with an indicated size of 452 Bytes only.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
dieterreuter/hello           latest              b961df9c849e        27 hours ago        452 B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting this Docker container on a Raspberry Pi (or another ARMv7 machine) will print the requested text string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run dieterreuter/hello
Hello Docker World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, if you&amp;rsquo;re working with &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;Docker-for-Mac&lt;/a&gt; or &lt;a href=&#34;https://docs.docker.com/docker-for-windows/&#34;&gt;Docker-for-Windows&lt;/a&gt; you should try to run this command, too. I guess you&amp;rsquo;ll be surprised what happens on your Intel based system when you start this Docker container which is containing an ARM binary. But this is a topic for another future blog post.&lt;/p&gt;

&lt;h3 id=&#34;challenge-details&#34;&gt;Challenge details&lt;/h3&gt;

&lt;p&gt;There are not many rules for this challenge, but let&amp;rsquo;s give you some hints:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the Docker image should output the text &amp;ldquo;Hello Docker World!&amp;rdquo; on the console&lt;/li&gt;
&lt;li&gt;we measure the size of the Docker image with &lt;code&gt;docker images&lt;/code&gt; or &lt;code&gt;docker image ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;feel free to use a CPU architecture of your choice: Intel, ARMv7, ARMv8/AARCH64, &amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Please publish your results on DockerHub, source codes on GitHub and tweet about it on Twitter with the hashtag #DockerChallenge. The goal of this challenge is to get familiar with the techniques to build minimal sized Docker images not only for IoT use cases, to understand the fact that a Docker container can be just a single process, and that this process can be really extremely small itself. On the way we&amp;rsquo;ll learn to take care about all the necessary steps to reduce the size and how we can optimize our development workflow as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/build-smallest-possible-docker-image/docker-image-minimal2.png&#34; alt=&#34;docker-image-minimal2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s start the journey&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Setup Kubernetes on a Raspberry Pi Cluster easily the official way!</title>
      <link>https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/</link>
      <pubDate>Wed, 11 Jan 2017 14:03:34 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;kubernetes.io&#34;&gt;Kubernetes&lt;/a&gt; shares the pole position with Docker in the category &amp;ldquo;orchestration solutions for Raspberry Pi cluster&amp;rdquo;.
However it&amp;rsquo;s setup process has been elaborate – until &lt;a href=&#34;http://blog.kubernetes.io/2016/09/how-we-made-kubernetes-easy-to-install.html&#34;&gt;v1.4 with the kubeadm announcement&lt;/a&gt;.
With that effort, Kubernetes changed this game completely and can be up and running officially within no time.&lt;/p&gt;

&lt;p&gt;I am very happy to announce that this blog post has been written in collaboration with &lt;a href=&#34;https://github.com/luxas&#34;&gt;Lucas Käldström&lt;/a&gt;, an independent maintainer of Kubernetes (his story is very interesting,  you can read it in a &lt;a href=&#34;https://www.cncf.io/blog/2016/11/29/diversity-scholarship-series-programming-journey-becoming-kubernetes-maintainer&#34;&gt;CNCF blogpost&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/raspberry-pi-cluster.png&#34; alt=&#34;SwarmClusterHA&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;why-kubernetes&#34;&gt;Why Kubernetes?&lt;/h2&gt;

&lt;p&gt;As shown in my recent &lt;a href=&#34;http://www.slideshare.net/MathiasRenner/high-availability-performance-of-kubernetes-and-docker-swarm-on-a-raspberry-pi-cluster/&#34;&gt;talk&lt;/a&gt;, there are many software suites available to manage a cluster of computers. There is Kubernetes, Docker Swarm, Mesos, OpenStack, Hadoop YARN, Nomad&amp;hellip; just to name a few.&lt;/p&gt;

&lt;p&gt;However, at Hypriot we have always been in love with tiny devices. So when working with an orchestrator, the maximum power we wanna use is what&amp;rsquo;s provided by a Raspberry Pi. Why? We have IoT networks in mind that will hold a large share in tomorrow&amp;rsquo;s IT infrastructure. At their edges, the power required for large orchestrators simply is not available.&lt;/p&gt;

&lt;p&gt;This boundary of resources leads to several requirements that need to be checked before we start getting our hands dirty with an orchestrator:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lightweight:&lt;/strong&gt; Software should be fit on a Raspberry Pi or smaller. As proofed in my talk mentioned above, Kubernetes painlessly runs on a Raspberry Pi.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARM compatible:&lt;/strong&gt; Since the ARM CPU architecture is designed for low energy consumption but still able to deliver a decent portion of power, the Raspberry Pi runs an ARM CPU. Thanks to Lucas, Kubernetes is ARM compatible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;General purpose:&lt;/strong&gt; Hadoop or Apache Spark are great for data analysis. But what if your use case changes? We prefer general purpose software that allows to run &lt;strong&gt;anything&lt;/strong&gt;. Kubernetes uses a container runtime (with Docker as the 100% supported runtime for the time being) that allows to run whatever you want.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Production ready:&lt;/strong&gt; Since we compare Kubernetes against a production ready Docker suite, let&amp;rsquo;s be fair and only choose equivalents. Kubernetes itself is production ready, and while the ARM port has some small issues, it&amp;rsquo;s working exactly as expected when going the official kubeadm route, which also will mature with time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, Kubernetes seems to be a compelling competitor to Docker Swarm. Let&amp;rsquo;s get our hands on it!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;wait-what-about-kubernetes-on-arm&#34;&gt;Wait – what about &lt;em&gt;Kubernetes-on-ARM&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;If you followed the discussion of Kubernetes on ARM for some time, you probably know about Lucas&amp;rsquo; project &lt;a href=&#34;https://github.com/luxas/kubernetes-on-arm&#34;&gt;kubernetes-on-ARM&lt;/a&gt;. Since the beginning of the movement to bring Kubernetes on ARM in 2015, this project has always been the most stable and updated.&lt;/p&gt;

&lt;p&gt;However, during 2016, Lucas&amp;rsquo; contributions have successfully been merged into official Kubernetes repositories, such that there is no point any more for using the kubernetes-on-ARM project.
In fact, the features of that project are far behind of what&amp;rsquo;s now implemented in the official repos, &lt;strong&gt;and that has been Lucas&amp;rsquo; goal from the beginning.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So if you&amp;rsquo;re up to using Kubernetes, please stick to the official repos now. And as of the kubeadm documentation, &lt;strong&gt;the following setup is considered official for Kubernetes on ARM.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;at-first-flash-hypriotos-on-your-sd-cards&#34;&gt;At first: Flash HypriotOS on your SD cards&lt;/h2&gt;

&lt;p&gt;As hardware, take at least two Raspberry Pis and make sure they are connected to each other and to the Internet.&lt;/p&gt;

&lt;p&gt;First, we need an operating system. Download and flash &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases&#34;&gt;HypriotOS&lt;/a&gt;. The fastest way to download and flash HypriotOS on your SD cards is by using our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --hostname node01 https://github.com/hypriot/image-builder-rpi/releases/download/v1.4.0/hypriotos-rpi-v1.4.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Provision all Raspberry Pis you have like this and boot them up.&lt;/p&gt;

&lt;p&gt;Afterwards, SSH into the Raspberry Pis with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@node01.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The password &lt;code&gt;hypriot&lt;/code&gt; will grant you access.&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;install-kubernetes&#34;&gt;Install Kubernetes&lt;/h2&gt;

&lt;p&gt;The installation requries root privileges. Retrieve them by&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo su -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install Kubernetes and its dependencies, only some commands are required.
First, trust the kubernetes APT key and add the official APT Kubernetes repository on every node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
$ echo &amp;quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&amp;quot; &amp;gt; /etc/apt/sources.list.d/kubernetes.list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and then just install &lt;code&gt;kubeadm&lt;/code&gt; on every node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get update &amp;amp;&amp;amp; apt-get install -y kubeadm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the previous command has been finished, initialize Kubernetes on the &lt;strong&gt;master node&lt;/strong&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm init --pod-network-cidr 10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is important that you add the &lt;code&gt;--pod-network-cidr&lt;/code&gt; command as given here, because we will use &lt;a href=&#34;https://coreos.com/flannel/docs/latest/&#34;&gt;flannel&lt;/a&gt;. Read the next notes about flannel if you wanna know why.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Some notes about flannel&lt;/strong&gt;: We picked flannel here because that’s the only available solution for ARM at the moment (this is subject to change in the future though).&lt;/p&gt;

&lt;p&gt;flannel can use and is using in this example the Kubernetes API to store metadata about the Pod CIDR allocations, and therefore we need to tell &lt;em&gt;Kubernetes&lt;/em&gt; first which subnet we want to use. The subnet we chose here is somehow fixed, because the &lt;a href=&#34;https://github.com/coreos/flannel/blob/master/Documentation/kube-flannel.yml#L25&#34;&gt;flannel configuration file&lt;/a&gt; that we&amp;rsquo;ll use later in this guide predefines the equivalent subnet. Of course, you can adapt both.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you are connected via WIFI instead of Ethernet, add &lt;code&gt;--api-advertise-addresses=&amp;lt;wifi-ip-address&amp;gt;&lt;/code&gt; as parameter to &lt;code&gt;kubeadm init&lt;/code&gt; in order to publish Kubernetes&amp;rsquo; API via WiFi. Feel free to explore the other options that exist for &lt;code&gt;kubeadm init&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After Kubernetes has been initialized, the last lines of your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/init.png&#34; alt=&#34;init&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To start using your cluster, you need to run (as a regular user):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo cp /etc/kubernetes/admin.conf $HOME/
$ sudo chown $(id -u):$(id -g) $HOME/admin.conf
$ export KUBECONFIG=$HOME/admin.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, as told by that output, let all other nodes join the cluster via the given &lt;code&gt;kubeadm join&lt;/code&gt; command. It will look something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm join --token=bb14ca.e8bbbedf40c58788 192.168.0.34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After some seconds, you should see all nodes in your cluster when executing the following &lt;strong&gt;on the master node&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/get-nodes.png&#34; alt=&#34;k8S&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, &lt;strong&gt;we need to setup flannel as the Pod network driver&lt;/strong&gt;. Run this &lt;strong&gt;on the master node&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sSL https://rawgit.com/coreos/flannel/v0.7.0/Documentation/kube-flannel.yml | sed &amp;quot;s/amd64/arm/g&amp;quot; | kubectl create -f -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/flannel.png&#34; alt=&#34;k8S&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then wait until all flannel and all other cluster-internal Pods are &lt;code&gt;Running&lt;/code&gt; before you continue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get po --all-namespaces
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice, it seems like they are all &lt;code&gt;Running&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/show-namespaces.png&#34; alt=&#34;show-namespaces&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all for the setup of Kubernetes! Next, let&amp;rsquo;s actually spin up a service on the cluster!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;test-your-setup-with-a-tiny-service&#34;&gt;Test your setup with a tiny service&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start a simple service so see if the cluster actually can publish a service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run hypriot --image=hypriot/rpi-busybox-httpd --replicas=3 --port=80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command starts set of containers called &lt;strong&gt;hypriot&lt;/strong&gt; from the image &lt;strong&gt;hypriot/rpi-busybox-httpd&lt;/strong&gt; and defines the port the container listens on at &lt;strong&gt;80&lt;/strong&gt;. The service will be &lt;strong&gt;replicated with 3 containers&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Next, expose the Pods in the above created Deployment in a Service with a stable name and IP:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl expose deployment hypriot --port 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! Now, let&amp;rsquo;s check if all three desired containers are up and running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get endpoints hypriot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see three endpoints (= containers) like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/show-endpoints.png&#34; alt=&#34;show-endpoints&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo; curl one of them to see if the service is up:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/curl-service.png&#34; alt=&#34;curl-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The HTML is the response of the service. Good, it&amp;rsquo;s up and running! Next, let&amp;rsquo;s see how we can access it from outside the cluster!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;finally-access-your-service-from-outside-the-cluster&#34;&gt;Finally access your service from outside the cluster&lt;/h2&gt;

&lt;p&gt;We will now deploy an example Ingress Controller to manage incoming requests from the outside world onto our tiny service. Also, in this example we we&amp;rsquo;ll use &lt;a href=&#34;https://traefik.io&#34;&gt;Traefik&lt;/a&gt; as load balancer. Read the following notes if you wanna know more about Ingress and Traefik.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;In contrast to Docker Swarm, Kubernetes itself does not provide an option to define a specific port that you can use to access a service&lt;/strong&gt;. According to Lucas is this an important design decision; routing of incoming requests should be handled by a third party, such as a load balancer or a webserver, but not by the core product. The core Kubernetes should be lean and extensible, and encourage others to build tools on top of it for their specific needs.&lt;/p&gt;

&lt;p&gt;Regarding load balancers in front of a cluster, there is &lt;a href=&#34;http://kubernetes.io/docs/user-guide/ingress/&#34;&gt;the Ingress API object&lt;/a&gt; and some sample &lt;a href=&#34;https://github.com/kubernetes/ingress&#34;&gt;Ingress Controllers&lt;/a&gt;. Ingress is a built-in way of exposing Services to the outside world via an Ingress Controller that anyone can build. An &lt;em&gt;Ingress rule&lt;/em&gt; defines how traffic should flow from the node the Ingress controller runs on to services inside of the cluster.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;First, let&amp;rsquo;s deploy traefik as load balancer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/hypriot/rpi-traefik/master/traefik-k8s-example.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Label the node you want to be the load balancer. Then the Traefik Ingress Controller will land on the node you specified. Run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl label node &amp;lt;load balancer-node&amp;gt; nginx-controller=traefik
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, create an Ingress object that makes Traefik load balance traffic on port &lt;code&gt;80&lt;/code&gt; to the &lt;code&gt;hypriot&lt;/code&gt; service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;gt; hypriot-ingress.yaml &amp;lt;&amp;lt;EOF
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: hypriot
spec:
  rules:
  - http:
      paths:
      - path: /
        backend:
          serviceName: hypriot
          servicePort: 80
EOF
$ kubectl apply -f hypriot-ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visit the loadbalancing node&amp;rsquo;s IP address in your browser and you should see a nice web page:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/hypriot-website.png&#34; alt=&#34;curl-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t see a website there yet, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get pods
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and make sure all hypriot Pods are in the &lt;code&gt;Running&lt;/code&gt; state.&lt;/p&gt;

&lt;p&gt;Wait until you see that all Pods are running, and a nice Hypriot website should appear!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;tear-down-the-cluster&#34;&gt;Tear down the cluster&lt;/h2&gt;

&lt;p&gt;If you wanna reset the whole cluster to the state after a fresh install, just run this on each node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm reset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition, it is recommended to delete some additional files &lt;a href=&#34;http://stackoverflow.com/questions/41359224/kubernetes-failed-to-setup-network-for-pod-after-executed-kubeadm-reset/41372829#41372829&#34;&gt;as it is mentioned here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;optional-deploy-the-kubernetes-dashboard&#34;&gt;Optional: Deploy the Kubernetes dashboard&lt;/h2&gt;

&lt;p&gt;The dashboard is a wonderful interface to visualize the state of the cluster. Start it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sSL https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml | sed &amp;quot;s/amd64/arm/g&amp;quot; | kubectl create -f -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following command provides the port that the dashboard is exposed at on every node with the NodePort function of Services, which is another way to expose your Services to the outside of your cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl -n kube-system get service kubernetes-dashboard -o template --template=&amp;quot;{{ (index .spec.ports 0).nodePort }}&amp;quot; | xargs echo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can checkout the dashboard on any node&amp;rsquo;s IP address on that port!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;you-like-a-follow-up&#34;&gt;You like a follow-up?&lt;/h2&gt;

&lt;p&gt;It was our goal to show that Kubernetes indeed works well on ARM (and ARM 64-bit!). For more examples including the AMD64 platform, check out the &lt;a href=&#34;http://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;official kubeadm documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We might follow-up this blog post with a more in-depth post about the current and planned state of Kubernetes officially on ARM and more, so stay tuned and tell Lucas if that&amp;rsquo;s something you&amp;rsquo;re interested in reading.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;Mathias Renner&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/kubernetesonarm&#34;&gt;Lucas Käldström&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Setup a simple CI pipeline to build Docker images for ARM</title>
      <link>https://blog.hypriot.com/post/setup-simple-ci-pipeline-for-arm-images/</link>
      <pubDate>Tue, 10 Jan 2017 07:25:23 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/setup-simple-ci-pipeline-for-arm-images/</guid>
      <description>&lt;p&gt;Recently I did an experiment: Can we build Docker images for ARM on ordinary cloud CI services that only provide Intel CPU&amp;rsquo;s?&lt;/p&gt;

&lt;p&gt;The idea was to get rid of self hosted CI build agents that you have to care for. If you want to provide an ARM Docker image for an open source project your task is to build it and not to setup and maintain a whole pipeline for it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/setup-simple-ci-pipeline-for-arm-images/github_yaml_arm.png&#34; alt=&#34;GitHub + YAML = ARM Docker image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;We at Hypriot have created several Dockerfiles for open source tools like &lt;a href=&#34;https://github.com/hypriot/rpi-mysql&#34;&gt;MySQL&lt;/a&gt;, &lt;a href=&#34;https://github.com/hypriot/rpi-traefik&#34;&gt;Træfɪk&lt;/a&gt; or &lt;a href=&#34;https://github.com/hypriot/rpi-node&#34;&gt;Node.js&lt;/a&gt; to make them available as Docker images for your ARM devices.&lt;/p&gt;

&lt;p&gt;Building such images and maintaining them over a longer period of time you have to care for updates. We are happy to receive pull requests from our community that help us updating the Dockerfiles.
But sometimes it happended that our ARM CI pipeline went offline and we had to put in some time and effort to fix it. There were pull requests lying around for some time without any CI checks.&lt;/p&gt;

&lt;p&gt;To get out of this trap I wanted a simpler CI pipeline without self hosted build agents. There are several cloud CI services like Travis, Codeship, Circle and so on, but they all only offer you Intel based CPU&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;But they have one thing in common: Just add a YAML file to your GitHub repo, connect it to their CI servers and you are done. There must be a way to use this convenient way for our ARM builds.&lt;/p&gt;

&lt;h3 id=&#34;qemu-for-the-rescue&#34;&gt;QEMU for the rescue&lt;/h3&gt;

&lt;p&gt;There are some blog posts how to use QEMU to emulate ARM on Intel CPU&amp;rsquo;s and many have even tried to build Docker images. I followed these tutorials, but many steps were needed to set up everything and it looked very complex.&lt;/p&gt;

&lt;p&gt;But after some hours of investigation I found out that all comes down to just two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;An Intel binary of QEMU for ARM must exist in the base Docker image&lt;/li&gt;
&lt;li&gt;The QEMU binary must be registered in the CI build agent&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fortunately both steps can be done in a very simple way.&lt;/p&gt;

&lt;h3 id=&#34;choose-a-base-image-with-qemu-binary&#34;&gt;Choose a base image with QEMU binary&lt;/h3&gt;

&lt;p&gt;The Raspbian Docker images from &lt;a href=&#34;https://resin.io&#34;&gt;Resin&lt;/a&gt; already have the QEMU binary in it. As these are the most common base images used you are already prepared.&lt;/p&gt;

&lt;p&gt;So if you use the following line in your &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM resin/rpi-raspbian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you are done with the first step. But what about Alpine? Well we have created a similar - still small - Docker image &lt;a href=&#34;https://github.com/hypriot/rpi-alpine&#34;&gt;hypriot/rpi-alpine&lt;/a&gt; that uses the &amp;ldquo;official&amp;rdquo; &lt;a href=&#34;https://hub.docker.com/r/armhf/alpine/&#34;&gt;armhf/alpine&lt;/a&gt; image and just append the QEMU binary. If you want to build ARM Alpine images just use this line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM hypriot/rpi-alpine
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;register-qemu-in-the-build-agent&#34;&gt;Register QEMU in the build agent&lt;/h3&gt;

&lt;p&gt;The next step is to register QEMU in the build agent. There is a Docker image available that can do this for us in just one line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm --privileged multiarch/qemu-user-static:register --reset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. Just add this line to your YAML file before the other docker commands.&lt;/p&gt;

&lt;h3 id=&#34;travis-builds-mysql-arm-image&#34;&gt;Travis builds MySQL ARM image&lt;/h3&gt;

&lt;p&gt;I have done the tests with Travis CI to build ARM images. But if you prefer another cloud CI services that offers Docker builds, it should be the same.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s put all pieces together and have a look at the final &lt;code&gt;.travis.yml&lt;/code&gt; file that is used to build the &lt;a href=&#34;https://github.com/hypriot/rpi-mysql&#34;&gt;hypriot/rpi-mysql&lt;/a&gt; Docker image for ARM.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo: required
services:
- docker
language: bash
script:
# prepare qemu
- docker run --rm --privileged multiarch/qemu-user-static:register --reset
# build image
- docker build -t hypriot/rpi-mysql .
# test image
- docker run hypriot/rpi-mysql mysql --version
# push image
- &amp;gt;
  if [ &amp;quot;$TRAVIS_BRANCH&amp;quot; == &amp;quot;master&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;$TRAVIS_PULL_REQUEST&amp;quot; == &amp;quot;false&amp;quot; ]; then
    docker login -u=&amp;quot;$DOCKER_USER&amp;quot; -p=&amp;quot;$DOCKER_PASS&amp;quot;
    TAG=$(grep &amp;quot;ENV MYSQL_VERSION&amp;quot; Dockerfile | awk &#39;NF&amp;gt;1{print $NF}&#39;)
    docker tag hypriot/rpi-mysql hypriot/rpi-mysql:$TAG
    docker push hypriot/rpi-mysql:$TAG
    docker push hypriot/rpi-mysql
  fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference to an Intel build is to just register QEMU here. The rest is activating Docker builds and do a simple docker build, test, push of that image.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;You only have to remember two things to let the cloud build your ARM images:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FROM resin/rpi-raspbian&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run --rm --privileged multiarch/qemu-user-static:register --reset&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are using this setup for more and more GitHub repos to gain speed and respond to pull requests much faster.&lt;/p&gt;

&lt;p&gt;For example we also are using &lt;a href=&#34;https://github.com/hypriot/rpi-node/blob/33d6ea9bebeca9bf31abac1b5dbc66a9f9902184/.travis.yml#L5-L8&#34;&gt;matrix builds&lt;/a&gt; for all major versions of Node.js to build new Docker images with Travis.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker is supported on the $9 C.H.I.P. computer</title>
      <link>https://blog.hypriot.com/post/docker-supported-on-chip-computer/</link>
      <pubDate>Sun, 11 Dec 2016 13:22:15 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/docker-supported-on-chip-computer/</guid>
      <description>&lt;p&gt;I guess you&amp;rsquo;re already knowing, one of the cheapest but powerful ARM boards is the $9 C.H.I.P. computer from Next Thing Co. &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt;. It has an ARMv7 1GHz CPU with 512 MByte of main memory, 4 GByte flash memory as disk storage and is equipped with onboard WiFi and bluetooth as well.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-photo2.jpg&#34; alt=&#34;chip-photo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Some time ago I wrote a detailed blog post about how to &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt; with the help of a custom Linux kernel which I built from source for this purpose and included all the necessary kernel modules which are required to run Docker. As an outlook I mentioned that one of the kernel developers from &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt;, namely Wynter Woods &lt;a href=&#34;https://twitter.com/zerotri&#34;&gt;@zerotri&lt;/a&gt;, is working to support Docker officially.&lt;/p&gt;

&lt;p&gt;Kernel development and testing takes time and finally here it is!&lt;br&gt;
&lt;strong&gt;Docker is running on the C.H.I.P. with their latest standard kernel!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-and-banana.jpg&#34; alt=&#34;chip-and-banana&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;short-overview&#34;&gt;Short overview&lt;/h3&gt;

&lt;p&gt;With the new Docker-enabled Linux kernel for the C.H.I.P. it&amp;rsquo;s really easy to install and use Docker on these tiny cute ARM devices. Basically you just have to update/upgrade to the latest software packages through the standard &lt;code&gt;apt&lt;/code&gt; package management commands, have to install Docker and you&amp;rsquo;re good to go.&lt;/p&gt;

&lt;p&gt;As I&amp;rsquo;ve already covered all these steps in detail in my post &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt;, we can take a shortcut and I&amp;rsquo;m explaining only the new and shorter steps.&lt;/p&gt;

&lt;h3 id=&#34;necessary-steps-to-install-docker&#34;&gt;Necessary steps to install Docker&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Flash the latest available firmware (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Connect to the C.H.I.P. via USB or UART console cable (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Configure WiFi connection (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Configure SSH to access the C.H.I.P. (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Checking the OS and Linux kernel version&lt;/li&gt;
&lt;li&gt;Upgrade the Linux kernel and operating system&lt;/li&gt;
&lt;li&gt;Install the Docker Engine the official way&lt;/li&gt;
&lt;li&gt;Run your first Docker Container on the C.H.I.P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;step-5-checking-the-os-and-linux-kernel-version&#34;&gt;Step 5: Checking the OS and Linux kernel version&lt;/h4&gt;

&lt;p&gt;Here I&amp;rsquo;ve flashed the C.H.I.P. with the latest available firmware&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.13-ntc-mlc #1 SMP Thu Nov 3 01:28:54 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we can see it&amp;rsquo;s running a Linux kernel version &lt;code&gt;4.4.13-ntc-mlc&lt;/code&gt; which is compiled at &lt;code&gt;Thu Nov 3 01:28:54 UTC 2016&lt;/code&gt;. If you&amp;rsquo;ve flashed your device weeks or months before, you could maybe see a different and older kernel version.&lt;/p&gt;

&lt;h4 id=&#34;step-6-upgrade-the-linux-kernel-and-operating-system&#34;&gt;Step 6: Upgrade the Linux kernel and operating system&lt;/h4&gt;

&lt;p&gt;The new Docker-enabled Linux kernel for the C.H.I.P. computer is already available in the standard APT package repository, but it&amp;rsquo;s not yet included in the latest firmware you can flash with the &lt;a href=&#34;http://flash.getchip.com/&#34;&gt;C.H.I.P. Flasher&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In order to update/upgrade the C.H.I.P. kernel we are going the easy way and performing a complete update and upgrade process of the operating system as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update
apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see on the &lt;code&gt;apt-get upgrade&lt;/code&gt; command, you&amp;rsquo;ll be asked to confirm to install a few new software packages which also includes the new kernel packages.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
The following packages will be upgraded:
  apt apt-utils base-files chip-mali-modules-4.4.13-ntc-mlc cpio dmsetup dpkg e2fslibs e2fsprogs
  gnupg gpgv libapt-inst1.5 libapt-pkg4.12 libc-bin libc6 libcomerr2 libdevmapper1.02.1
  libdns-export100 libgcrypt20 libhogweed2 libicu52 libidn11 libirs-export91 libisc-export95
  libisccfg-export90 libnettle4 libpam-modules libpam-modules-bin libpam0g libpcre3 libss2
  libtasn1-6 libudev1 linux-image-4.4.13-ntc-mlc multiarch-support
  rtl8723bs-mp-driver-modules-4.4.13-ntc-mlc tar tzdata udev vim-common vim-tiny wget
42 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Need to get 39.8 MB of archives.
After this operation, 8562 kB of additional disk space will be used.
Do you want to continue? [Y/n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of the upgrade you have to reboot the device in order to boot the new Linux kernel. That&amp;rsquo;s all, really!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you log in again, you can see&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.13-ntc-mlc #1 SMP Tue Dec 6 21:38:00 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the new Linux kernel has the same version, but a newer build time from &lt;code&gt;Tue Dec 6 21:38:00 UTC 2016&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;step-6-install-the-docker-engine-the-official-way&#34;&gt;Step 6: Install the Docker Engine the official way&lt;/h4&gt;

&lt;p&gt;To install Docker the official way is quite easy today because we can use the APT packages and install scripts directly provided by the &lt;a href=&#34;https://github.com/docker/docker&#34;&gt;Docker project&lt;/a&gt;. And Debian for ARMv7 is one of the officially supported OS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://get.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will take some time, but after a while the Docker Engine is installed on your C.H.I.P. computer with just a few commands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/apt/sources.list.d/docker.list
deb [arch=armhf] https://apt.dockerproject.org/repo debian-jessie main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the version of the Docker client command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker --version
Docker version 1.12.2, build bb80604
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the versions of the Docker client, Docker API and Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker version
Client:
 Version:      1.12.2
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   bb80604
 Built:        Tue Oct 11 17:52:51 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.2
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   bb80604
 Built:        Tue Oct 11 17:52:51 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get some more details about the running Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.12.2
Storage Driver: devicemapper
 Pool Name: docker-0:16-33578-pool
 Pool Blocksize: 65.54 kB
 Base Device Size: 10.74 GB
 Backing Filesystem: ext4
 Data file: /dev/loop0
 Metadata file: /dev/loop1
 Data Space Used: 305.7 MB
 Data Space Total: 107.4 GB
 Data Space Available: 6.596 GB
 Metadata Space Used: 729.1 kB
 Metadata Space Total: 2.147 GB
 Metadata Space Available: 2.147 GB
 Thin Pool Minimum Free Space: 10.74 GB
 Udev Sync Supported: true
 Deferred Removal Enabled: false
 Deferred Deletion Enabled: false
 Deferred Deleted Device Count: 0
 Data loop file: /var/lib/docker/devicemapper/devicemapper/data
 WARNING: Usage of loopback devices is strongly discouraged for production use. Use `--storage-opt dm.thinpooldev` to specify a custom block storage device.
 Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata
 Library Version: 1.02.90 (2014-09-01)
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: overlay bridge null host
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Security Options:
Kernel Version: 4.4.13-ntc-mlc
Operating System: Debian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 1
Total Memory: 491 MiB
Name: chip
ID: Z7U2:2DYF:G54F:2QLU:AAG3:TD7Y:YWSQ:6PRM:6ZW3:WIC5:7DEA:HFFK
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
WARNING: No swap limit support
WARNING: No kernel memory limit support
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we could see, the latest Docker Engine v1.12.2 for Debian/ARMv7 is now installed and is successfully running.&lt;/p&gt;

&lt;h4 id=&#34;step-8-run-your-first-docker-container-on-the-c-h-i-p&#34;&gt;Step 8: Run your first Docker Container on the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;As a last step we&amp;rsquo;d like to start a first Docker container, a small web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
fec2773baaec570ba8b6e00296dfd11b4b4768d1b51e574d851968b9225b9d22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start your web browser and point it to the website from our Docker container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open http://192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/first-container-on-chip.jpg&#34; alt=&#34;first-container-on-chip&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;using-latest-rc-of-docker-engine&#34;&gt;Using latest RC of Docker Engine&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to get the latest Docker Engine for testing, like release candidates, you can install it pretty easily with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://test.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can upgrade your current system with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#edit /etc/apt/sources.list.d/docker.list # change &#39;main&#39; to &#39;testing&#39;
cat /etc/apt/sources.list.d/docker.list
deb [arch=armhf] https://apt.dockerproject.org/repo debian-jessie testing

apt-get update
apt-get install -y docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can test the latest available release candidate of the Docker Engine with all the newest features with Docker Swarm mode and other goodies.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker version
Client:
 Version:      1.13.0-rc3
 API version:  1.25
 Go version:   go1.7.3
 Git commit:   4d92237
 Built:        Mon Dec  5 19:00:08 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.13.0-rc3
 API version:  1.25 (minimum version 1.12)
 Go version:   go1.7.3
 Git commit:   4d92237
 Built:        Mon Dec  5 19:00:08 2016
 OS/Arch:      linux/arm
 Experimental: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tl-dr-install-docker-on-the-c-h-i-p-computer&#34;&gt;TL;DR - Install Docker on the C.H.I.P. computer&lt;/h3&gt;

&lt;p&gt;For all the impatient users, these are the minimal steps to install the latest Linux kernel and the latest Docker Engine on the C.H.I.P. computer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update
apt-get upgrade -y
reboot
curl -sSL https://get.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DONE !!!!&lt;/p&gt;

&lt;h3 id=&#34;acknowledgments&#34;&gt;Acknowledgments&lt;/h3&gt;

&lt;p&gt;Again, I like to thank Wynter Woods &lt;a href=&#34;https://twitter.com/zerotri&#34;&gt;@zerotri&lt;/a&gt; from &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt; for his efforts and hard work to include all the Linux kernel changes necessary to run the Docker Engine pretty slick on the C.H.I.P. computer. It&amp;rsquo;s so great to see when all the changes will be accepted and implemented in the upstream version, so everybody can use the new features without spending too much time.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s the important point to work in opensource, contributing back so that all users benefit from the results!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fix Dirty COW on Raspberry Pi the Docker way</title>
      <link>https://blog.hypriot.com/post/fix-dirty-cow-on-raspberry-pi/</link>
      <pubDate>Tue, 01 Nov 2016 13:42:20 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/fix-dirty-cow-on-raspberry-pi/</guid>
      <description>&lt;p&gt;Have you seen the latest reports about the Linux kernel security vulnerability called &amp;ldquo;Dirty COW&amp;rdquo;?
Dirty COW is a &lt;a href=&#34;http://www.theregister.co.uk/2016/10/21/linux_privilege_escalation_hole/&#34;&gt;race condition in Linux&lt;/a&gt; arising from how Copy-On-Write (the COW in the name) is handled by the kernel&amp;rsquo;s memory subsystem&amp;rsquo;s use of private mappings.&lt;/p&gt;

&lt;p&gt;The really dangerous point here is, it can be used to &lt;a href=&#34;http://www.theregister.co.uk/2016/11/01/docker_user_havent_patched_dirty_cow_yet_bad_news/&#34;&gt;escape Docker containers&lt;/a&gt;.
&lt;img src=&#34;https://blog.hypriot.com/images/fix-dirty-cow-on-raspberry-pi/dirty-cow-001.jpg&#34; alt=&#34;dirty-cow-001&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, we&amp;rsquo;re encourage you to immediately fix it with upgrading your Linux kernel on the Raspberry Pi !!!&lt;/p&gt;

&lt;p&gt;No matter if you&amp;rsquo;re running an official Raspbian or HypriotOS, please upgrade your Linux kernel to be safe again&amp;hellip;
&lt;/p&gt;

&lt;h3 id=&#34;tl-dr-fast-fixing&#34;&gt;TL;DR - Fast Fixing&lt;/h3&gt;

&lt;p&gt;For all the impatient users, here are the essential steps to upgrade your Linux kernel in an easy way on your Raspberry Pi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS&lt;/strong&gt; and &lt;strong&gt;Raspbian Jessie&lt;/strong&gt; (more details can be found &lt;a href=&#34;https://www.raspberrypi.org/blog/#fix-dirty-cow-raspberry-pi&#34;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For both operating systems it requires a system reboot to exchange the running Linux kernel in memory. But once you&amp;rsquo;ve done these easy steps you have successfully fixed the Dirty COW vulnerability.&lt;/p&gt;

&lt;h3 id=&#34;testing-for-dirty-cow-with-the-help-of-docker&#34;&gt;Testing for Dirty COW with the help of Docker&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to know whether your system is vulnerable against Dirty COW you can easily run a test with the help of a Docker Image. The complete source code can be found in my Github repo &lt;a href=&#34;https://github.com/DieterReuter/rpi-dirtycow&#34;&gt;DieterReuter/rpi-dirtycow&lt;/a&gt;, so you can build everything on your own, too.&lt;/p&gt;

&lt;p&gt;Running this single command is just absolutely easy and this is one of the benefits of Docker, you don&amp;rsquo;t have to install anything on your host machine. Just run a Docker container in a secure way and get instant results within seconds.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s do some testing on two different operating systems for the Raspberry Pi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Raspbian Jessie LITE (2016-09-23)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve used a freshly installed Raspbian Lite for these tests and you can see, we do have a Linux kernel 4.4.21.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux raspberrypi 4.4.21-v7+ #911 SMP Thu Sep 15 14:22:38 BST 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t have the Docker Engine already installed on Raspbian, you can perform it with this few commands - YEAH, it&amp;rsquo;s just so easy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sSL https://get.docker.com | bash
$ sudo usermod -aG docker pi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, logout and login again to get access to the Docker CLI from your default &amp;ldquo;pi&amp;rdquo; user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker --version
Docker version 1.12.3, build 6b644ec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have Docker installed, we can test against Dirty COW.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm hypriot/rpi-dirtycow
Unable to find image &#39;hypriot/rpi-dirtycow:latest&#39; locally
latest: Pulling from hypriot/rpi-dirtycow
38070c4d0c33: Pull complete
a3ed95caeb02: Pull complete
2d2e2d46b9b5: Pull complete
Digest: sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Status: Downloaded newer image for hypriot/rpi-dirtycow:latest

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are VULNERABLE!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s upgrade the Linux kernel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;ll test it again. Hopefully we&amp;rsquo;ve fixed it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux raspberrypi 4.4.26-v7+ #915 SMP Thu Oct 20 17:08:44 BST 2016 armv7l GNU/Linux

$ docker run --rm hypriot/rpi-dirtycow

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are SAFE!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New Linux kernel 4.4.26 is installed for Raspbian and Dirty COW is fixed!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Did you mentioned the different output from the &lt;code&gt;docker run&lt;/code&gt; commands? The first time, Docker has detected that the Docker Image &amp;ldquo;hypriot/rpi-dirtycow&amp;rdquo; is not on the machine and downloads/pulls the required image layers. The second time it can just start the Docker container.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS 1.1.0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;m using the latest HypriotOS 1.1.0 release, but the Linux kernel upgrade works even for an older 0.8 release.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux black-pearl 4.4.24-hypriotos-v7+ #1 SMP PREEMPT Tue Oct 11 17:15:58 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test for Dirty COW.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time docker run --rm hypriot/rpi-dirtycow
Unable to find image &#39;hypriot/rpi-dirtycow:latest&#39; locally
latest: Pulling from hypriot/rpi-dirtycow
38070c4d0c33: Pull complete
a3ed95caeb02: Pull complete
2d2e2d46b9b5: Pull complete
Digest: sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Status: Downloaded newer image for hypriot/rpi-dirtycow:latest

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are VULNERABLE!!!

real	0m14.514s
user	0m0.200s
sys	0m0.180s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You can see, it takes just under 15 seconds to pull the Docker Image and to perform the test against the Dirty COW vulnerability. We didn&amp;rsquo;t installed anything on the host machine for these tests and we can get rid of the Docker image later on and clean our host system easily.&lt;/p&gt;

&lt;p&gt;Upgrade the Linux kernel for HypriotOS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we have the latest Linux kernel 4.4.27 for HypriotOS installed and we&amp;rsquo;re safe again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux black-pearl 4.4.27-hypriotos-v7+ #1 SMP PREEMPT Fri Oct 28 09:06:49 UTC 2016 armv7l GNU/Linux

$ time docker run --rm hypriot/rpi-dirtycow

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are SAFE!

real	0m4.504s
user	0m0.100s
sys	0m0.050s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we&amp;rsquo;ll remove the Docker Image we&amp;rsquo;ve used for the tests and free some disk space.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
hypriot/rpi-dirtycow   latest              31229be9ea1d        3 days ago          5.512 MB

$ docker rmi -f 31229be9ea1d
Untagged: hypriot/rpi-dirtycow:latest
Untagged: hypriot/rpi-dirtycow@sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Deleted: sha256:31229be9ea1d01ed2df47cc23ab50efdc84be3b49572bb4b6047a449dea4e596

$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This is another great advantage by Docker - get rid of all the tools we don&amp;rsquo;t need anymore.&lt;/p&gt;

&lt;h3 id=&#34;conclusion-upgrade-your-system-regularly&#34;&gt;Conclusion: upgrade your system regularly&lt;/h3&gt;

&lt;p&gt;Your Raspberry Pi system is now SAFE again. In the future don&amp;rsquo;t forget to upgrade it from time to time. On both operating systems, Raspbian and HypriotOS, you can do the upgrade procedure with these few commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with this way you&amp;rsquo;ll get some other tools updated as well, like the Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker version
Client:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 19:06:36 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 19:06:36 2016
 OS/Arch:      linux/arm
HypriotOS/armv7: pirate@black-pearl in ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all and STAY SAFE !!!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Visualize your Raspberry Pi containers with Portainer or UI for Docker</title>
      <link>https://blog.hypriot.com/post/new-docker-ui-portainer/</link>
      <pubDate>Mon, 31 Oct 2016 15:18:33 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/new-docker-ui-portainer/</guid>
      <description>&lt;p&gt;At home I use some Raspberry Pi&amp;rsquo;s for some home network services, and I run
these services inside Docker containers. From time to time I want to see or
manage one of these containers. But I&amp;rsquo;m too lazy to get to my laptop and use
the Docker CLI for that. There are two nice Docker UI&amp;rsquo;s to access your Docker engine with a web browser. Let&amp;rsquo;s have a look at both.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-docker.png&#34; alt=&#34;Portainer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;ui-for-docker-formerly-known-as-dockerui&#34;&gt;UI for Docker, formerly known as DockerUI&lt;/h2&gt;

&lt;p&gt;I have started using the DockerUI, an open source project from Michael Crosby and Kevan Ahlquist. You can find the source code on GitHub at &lt;a href=&#34;https://github.com/kevana/ui-for-docker&#34;&gt;https://github.com/kevana/ui-for-docker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://github.com/StefanScherer/docker-at-home/blob/eb451b954809393e8536259aff6daf27bfb7b7b8/docker-compose.yml#L27-L35&#34;&gt;my home setup&lt;/a&gt; I use Docker Compose to configure how to run my services.&lt;/p&gt;

&lt;p&gt;This is my configuration to start the UI so I can reach it on port 80 of the Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ui:
  image: hypriot/rpi-dockerui
  restart: always
  volumes:
    - &#39;/var/run/docker.sock:/var/run/docker.sock&#39;
  expose:
    - 9000
  ports:
    - 80:9000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we provide a Docker image &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-dockerui/&#34;&gt;hypriot/rpi-dockerui&lt;/a&gt; on the Docker hub so it is very easy to use it in your environment.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look at the dashboard which shows you an overview of your running or stopped containers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-dashboard.png&#34; alt=&#34;DockerUI Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can click on each container and see more details and so some actions with them like stopping and starting them again.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-container.png&#34; alt=&#34;DockerUI Container&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The UI provides some more views to list for example all local Docker images and information about your Docker engine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-images.png&#34; alt=&#34;DockerUI Images&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;portainer&#34;&gt;Portainer&lt;/h2&gt;

&lt;p&gt;Last week I found &lt;a href=&#34;http://portainer.io&#34;&gt;portainer.io&lt;/a&gt; which also looks very good. They provide Docker images for Linux and Windows, &lt;del&gt;but not for ARM right now&lt;/del&gt; and as well an image for ARM.&lt;/p&gt;

&lt;p&gt;The source code is also available on GitHub &lt;a href=&#34;https://github.com/portainer/portainer&#34;&gt;https://github.com/portainer/portainer&lt;/a&gt; and it&amp;rsquo;s based on the work of DockerUI.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/portainer/portainer/pull/299&#34;&gt;pull request&lt;/a&gt; to add Linux ARM support was merged and now you can get the Docker image for the Rapsberry Pi using the image &lt;a href=&#34;https://hub.docker.com/r/portainer/portainer/&#34;&gt;portainer/portainer:arm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Just use the same Docker Compose sample from above and replace the image name. Killing the old container and running a new one with &lt;code&gt;docker-compose up -d ui&lt;/code&gt; you have Portainer up and running.&lt;/p&gt;

&lt;p&gt;The dashboard also gives you an overview of all running containers, all images etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-dashboard.png&#34; alt=&#34;Portainer Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the container list you can see all running and stopped containers as well as some actions you can do with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-container.png&#34; alt=&#34;Portainer Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clicking on one of the running containers you have access to the details, environment variables, port mappings, volumes.
You can also access some CPU/memory and network statistics as well as the logs of your container, as well as the processes running inside the container.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-stats.png&#34; alt=&#34;Portainer Stats&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you want to remote control your Raspberry Pi Docker containers from a nice Web UI, then try
one of these prebuilt Docker images. Of course be aware that everyone in your home network
is able to manipulate your Docker containers with it as there is no login dialog.
But for some private projects it is still an advantage to simplify starting and stopping containers from your mobile phone.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Testing High Availability of Docker Swarm on a Raspberry Pi Cluster (Updated)</title>
      <link>https://blog.hypriot.com/post/high-availability-with-docker/</link>
      <pubDate>Wed, 26 Oct 2016 18:03:34 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/high-availability-with-docker/</guid>
      <description>&lt;p&gt;In its release in June this year, Docker announced two exciting news about the Docker Engine: First, the Engine 1.12 comes with built-in high availability features, called &amp;ldquo;Docker Swarm Mode&amp;rdquo;. And second, Docker started providing official support for the ARM architecture.&lt;/p&gt;

&lt;p&gt;These two news combined beg for testing the new capabilities in reality.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/high-availability-docker-swarm.png&#34; alt=&#34;SwarmClusterHA&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;old&amp;rdquo; Docker Swarm already offered some high availability features, but the new called &amp;ldquo;Swarm Mode&amp;rdquo; goes far beyond: To me, the most important capabilities to mention are: built-in security, rolling updates and - maybe one of the most important benefits - super user-friendliness. Production ready clustering based on powerful container technology has probably never been easier before.&lt;/p&gt;

&lt;p&gt;Also, the release of Docker 1.12 comes with official support for the ARM architecture. Running Docker on ARM has been possible for long time, but now, users can install it the same way on their Raspberry Pis as they do it on any other architecture: Using Docker&amp;rsquo;s official repositories. If you are one of our regular readers, you know that our team at Hypriot intensively collaborated with Docker to make this official support possible. So we are also very happy that this huge milestone that many people asked for is eventually checked!&lt;/p&gt;

&lt;p&gt;Now, with these two news, let&amp;rsquo;s get our hands dirty and test if the announced promises hold.&lt;/p&gt;

&lt;h2 id=&#34;setup-the-cluster&#34;&gt;Setup the cluster&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;As hardware&lt;/strong&gt;, I have 5x Raspberry Pi 3, connected in a network with Internet access.&lt;/p&gt;

&lt;p&gt;The Raspberry Pis with their SD cards, the network switch, power input and all cables live in a &lt;a href=&#34;https://www.picocluster.com/collections/starter-picocluster-kits/products/pico-5-raspberry-pi-starter-kit?variant=29344698892&#34;&gt;hardware kit from PicoCluster&lt;/a&gt;. Thanks to PicoCluster for providing the kit to us for testing!&lt;/p&gt;

&lt;p&gt;See how the cluster looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/PicoCluster.jpg&#34; alt=&#34;PicoClusterBuilt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;As software&lt;/strong&gt;, I chose HypriotOS. I also tried Raspbian, but it requires a large system upgrade after the first boot in order to provide all features required by Docker (e.g. VXLAN kernel module). Before and after the system upgrade, I also had to run &lt;a href=&#34;https://github.com/docker/docker/blob/master/contrib/check-config.sh&#34;&gt;Docker&amp;rsquo;s test script&lt;/a&gt; to make sure everything is ok. All of this is not a big deal, but if there is an OS available that comes out of the box with all that Docker needs (and even adds lots of useful optimizations), it simply saves time and provides a hassle-free experience. So I flashed all SD cards with HypriotOS using our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;To connect to the cluster&lt;/strong&gt;, I SSHed into all the nodes via &lt;a href=&#34;http://gnometerminator.blogspot.de/p/introduction.html&#34;&gt;Terminator&lt;/a&gt;. Terminator is my preferred tool to organize multiple terminals in a single window. It allows to send commands to several terminals at once. Soon, I&amp;rsquo;ll have a look at tmux and might switch, but for now I recommend Terminator :)&lt;/p&gt;

&lt;p&gt;Finally, we have 5 terminals opened, all waiting for commands as you see in the following image. Please don&amp;rsquo;t care about the commands running in each terminal for now.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/terminal.png&#34; alt=&#34;Terminator&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all to do before getting our hands on Docker itself!&lt;/p&gt;

&lt;h2 id=&#34;setup-docker-swarm-on-the-cluster&#34;&gt;Setup Docker Swarm on the cluster&lt;/h2&gt;

&lt;p&gt;On HypriotOS, you&amp;rsquo;ll have the latest Docker installed, so we can instantly start playing.&lt;/p&gt;

&lt;p&gt;On an arbitrary node of the cluster, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker swarm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output should look similar to that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Swarm initialized: current node (node-master) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-1acm9qa7b0hmzz5v8t40d75v5fsgckeu2z5ds6ls0x7cny7l8p-307wqrc8756akpxjxls9abbbs \
    [2a02:810d:8600:2a78:f6c6:d67d:6912:17ca]:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As explained in this output, now you need to run the presented &lt;code&gt;docker swarm join ...&lt;/code&gt; command on all other nodes, which you want to join the cluster.&lt;/p&gt;

&lt;p&gt;Finally, on the node at which you executed &lt;code&gt;docker swarm init&lt;/code&gt;, check if all nodes of your cluster successfully formed a swarm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker node ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the terminal prints a list of all nodes of your cluster, the setup is all done! Forming a cluster cannot be easier, can it?&lt;/p&gt;

&lt;h2 id=&#34;execution-of-tests&#34;&gt;Execution of tests&lt;/h2&gt;

&lt;p&gt;My tests of Docker&amp;rsquo;s ability to recover from failures comprise the following use cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The ethernet interface of a random node (master or slave) got unavailable&lt;/li&gt;
&lt;li&gt;A random node completely rebooted&lt;/li&gt;
&lt;li&gt;A random node instantly crashed (unplug power source)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I documented one of the test runs in the following screencast.&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;iframe src=&#34;https://player.vimeo.com/video/185361173&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&#34;https://vimeo.com/185361173&#34;&gt;Testing High Availability Docker Swarm Mode&lt;/a&gt; from &lt;a href=&#34;https://vimeo.com/user54109827&#34;&gt;Mathias Renner&lt;/a&gt; on &lt;a href=&#34;https://vimeo.com&#34;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;results&#34;&gt;Results&lt;/h2&gt;

&lt;p&gt;As shown in the screencast, Docker is able to recover from failure of the ethernet interface. After testing the other use cases later on, Docker recovered flawlessly from a reboot and crash as well. Note that this also holds for master nodes, not only for slave nodes! This is remarkable because in contrast to slave nodes, master nodes hold important data of the cluster state. A master nodes&amp;rsquo;s outage is critical for the health of the cluster. With e.g. &lt;a href=&#34;https://github.com/luxas/kubernetes-on-arm&#34;&gt;Kubernetes-on-arm&lt;/a&gt;, the cluster does not recover after rebooting or crashing a master node.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Edit on 6.11.2016&lt;/strong&gt;: Jérémy Derussé and Nikolay Kushin reported in the discussion below that for them a reboot or crash of a node did not result in a healthy cluster state after bringing up the node again. As of today, unfortunately I can confirm this, with Docker version 1.12.1, 1.12.2 as well as 1.12.3. I cannot explain why during my tests for this post a crashed node recovered smoothly.&lt;/p&gt;

&lt;p&gt;Based on Jeremy&amp;rsquo;s report, I was able to create a quick fix for this issue. On a node, simply run:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;sudo crontab -e&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There, insert the following line (without quotation marks) and save the file.&lt;/p&gt;

&lt;p&gt;&amp;rdquo;@reboot docker ps&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Having this configured, after a crash or reboot the node recovered correctly in my tests. I look forward for feedback about this issue! Please use the discussion below.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;more-to-come-soon&#34;&gt;More to come soon&lt;/h2&gt;

&lt;p&gt;This post is only a small chunk of the data I gathered during the tests. The next option to get the details is during my talk at the &lt;a href=&#34;http://highload.co/&#34;&gt;HighLoad++ Conference&lt;/a&gt; in Moskow, Russia. I&amp;rsquo;d be happy if you can make it there!&lt;/p&gt;

&lt;p&gt;Also, this is not the end of the story of course. Thorough testing requires also measuring incoming requests from an external load tester to the cluster while a failure occurs. After some research, I have not found any evidence that someone has ever performed that tests (please correct me if I&amp;rsquo;m wrong!).&lt;/p&gt;

&lt;p&gt;Moreover, Kubernetes received much attention lately since its support for ARM became better and better. So wouldn&amp;rsquo;t it be interesting to see if Docker or Kubernetes is better in keeping a service available and performing well, even if there are outages in the cluster?&lt;/p&gt;

&lt;p&gt;So there&amp;rsquo;s more coming soon, just stay tuned for the upcoming posts :)&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Deploying an IoT Swarm with Docker Machine</title>
      <link>https://blog.hypriot.com/post/deploy-swarm-on-chip-with-docker-machine/</link>
      <pubDate>Sun, 04 Sep 2016 19:45:58 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/deploy-swarm-on-chip-with-docker-machine/</guid>
      <description>&lt;p&gt;With the new SwarmMode in Docker 1.12 it is really damn easy to build a Docker Swarm and connect different ARM devices to an IoT cluster.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-flashing1.jpg&#34; alt=&#34;swarm-chip-flashing1.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s connect a few of the $9 C.H.I.P. computers and a Raspberry Pi Zero all through a WiFi network&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;step-1-install-docker-machine&#34;&gt;Step 1: Install Docker Machine&lt;/h4&gt;

&lt;p&gt;First of all, we need to make sure we do have Docker Machine installed on our local computer. I&amp;rsquo;m using a Mac for this tutorial, but you can use Docker Machine on Linux or Windows too. If not already done, you should install the latest Docker Machine binary following the &lt;a href=&#34;https://docs.docker.com/machine/install-machine/&#34;&gt;Install Docker Machine&lt;/a&gt; instructions.&lt;/p&gt;

&lt;p&gt;You can easily check the version of Docker Machine with the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine --version
docker-machine version 0.8.0, build b85aac1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-2-prepare-all-c-h-i-p-s-with-docker-machine&#34;&gt;Step 2: Prepare all C.H.I.P.&amp;rsquo;s with Docker Machine&lt;/h4&gt;

&lt;p&gt;In order to connect a couple of C.H.I.P. computers to a Docker Swarm cluster, we have to install Docker 1.12.1 first. This can be done easily by following the steps of my last tutorial &lt;a href=&#34;https://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt;. Then we&amp;rsquo;re using the standard Docker Machine from a Mac to attach each C.H.I.P. device via a secured Docker API port and give each device an individual hostname on the network. With the help of Docker Machine it&amp;rsquo;s easier to access all the C.H.I.P. devices we&amp;rsquo;d like to connect to the Swarm cluster from a Mac, Linux or Windows machine.&lt;/p&gt;

&lt;p&gt;Here are the basic steps we have to follow for each single C.H.I.P. computer:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;flash C.H.I.P. and install Docker 1.12.1&lt;/li&gt;
&lt;li&gt;detect the IP address and use Docker Machine&lt;/li&gt;
&lt;li&gt;restart Avahi daemon or reboot C.H.I.P.&lt;/li&gt;
&lt;li&gt;check the device connectivity via network and Docker API&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Flashing the C.H.I.P. computer in FEL mode with UART console cable attached: &lt;br&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-flashing2.jpg&#34; alt=&#34;swarm-chip-flashing2.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As soon as we&amp;rsquo;ve installed our first C.H.I.P. with Docker we&amp;rsquo;ll use its IP address and run &lt;code&gt;docker-machine create&lt;/code&gt; and let&amp;rsquo;s do some Docker magic and we have secured the network access to its Docker Engine easily. In this command I&amp;rsquo;m using the flag &lt;code&gt;--debug&lt;/code&gt; to get a more verbose output, so you can see all the details whats going on in the background, but you can omit this flag for the remaining C.H.I.P.&amp;rsquo;s.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CHIP_IP_ADDRESS=192.168.2.112
CHIP_NODENAME=swarm-chip01

docker-machine --debug create \
  --driver=generic \
  --engine-storage-driver=overlay \
  --generic-ip-address=$CHIP_IP_ADDRESS \
  $CHIP_NODENAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After successfully running this command, the C.H.I.P. device is attached to Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME           ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01   -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the C.H.I.P. itself you can see that the hostname has changed. So let&amp;rsquo;s check this in detail to get a better understanding what&amp;rsquo;s happening behind the scene. Now we&amp;rsquo;re using some Docker Machine fu to connect to the device.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01
root@swarm-chip01:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hostname has changed to &lt;code&gt;swarm-chip01&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/hostname
swarm-chip01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so there is a new local loopback address included as &lt;code&gt;127.0.1.1 swarm-chip01&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/hosts
127.0.0.1      	chip
127.0.0.1      	localhost
::1    		localhost ip6-localhost ip6-loopback
ff02::1		ip6-allnodes
ff02::2		ip6-allrouters

127.0.1.1 swarm-chip01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check if we can reach the C.H.I.P. from the network with its new hostname.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-chip01.local
ping: cannot resolve swarm-chip01.local: Unknown host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately the Avahi service discovery daemon didn&amp;rsquo;t changed the hostname, so we have to restart it manually to get the changes in order to reach the C.H.I.P. with it&amp;rsquo;s new hostname from the WiFi network. Alternatively we can just reboot the C.H.I.P. to activate these changes. So let&amp;rsquo;s do it through Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 systemctl restart avahi-daemon.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And check with ping again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-chip01.local
PING swarm-chip01.local (192.168.2.112): 56 data bytes
64 bytes from 192.168.2.112: icmp_seq=0 ttl=64 time=105.129 ms
64 bytes from 192.168.2.112: icmp_seq=1 ttl=64 time=3.529 ms
64 bytes from 192.168.2.112: icmp_seq=2 ttl=64 time=48.178 ms

--- swarm-chip01.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 3.529/52.279/105.129/41.579 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s up to you to repeat these steps for all the remaining C.H.I.P. devices. After some time you should be ready and having a list of devices connected to Docker Machine. I&amp;rsquo;ve done this with six C.H.I.P.&amp;rsquo;s, and one of them is an Alpha unit which works exactly the same way without any differences.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME            ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01    -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
swarm-chip02    -        generic   Running   tcp://192.168.2.116:2376           v1.12.1
swarm-chip03    -        generic   Running   tcp://192.168.2.117:2376           v1.12.1
swarm-chip04    -        generic   Running   tcp://192.168.2.118:2376           v1.12.1
swarm-chip05    -        generic   Running   tcp://192.168.2.120:2376           v1.12.1
swarm-chip06    -        generic   Running   tcp://192.168.2.104:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-3-initialize-the-swarm-create-a-swarm-manager&#34;&gt;Step 3: Initialize the Swarm, create a Swarm manager&lt;/h4&gt;

&lt;p&gt;As soon as all the C.H.I.P.&amp;rsquo;s are prepared we are able to initiate a Swarm cluster. We are creating a Swarm manager first and then we can attach the other C.H.I.P.&amp;rsquo;s as additional Swarm managers or Swarm workers pretty easily. All the steps to form a Swarm cluster are literally a single command per device only!&lt;/p&gt;

&lt;p&gt;With this command the Swarm will be initialized.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker swarm init
Swarm initialized: current node (8174iszkmn4u4wwjogam8bsrw) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
    192.168.2.112:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we do have our first Swarm manager running.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
8174iszkmn4u4wwjogam8bsrw *  swarm-chip01  Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-4-set-up-swarm-for-high-availability-attach-more-swarm-managers&#34;&gt;Step 4: Set up Swarm for high-availability, attach more Swarm managers&lt;/h4&gt;

&lt;p&gt;In order to build a high-availability Swarm cluster, we like to join two additional Swarm managers. So, first we have to ask the Swarm Leader for an access token to join new Swarm managers. You have to know that the complete control traffic between Swarm nodes is secured by default.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
    192.168.2.112:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this given command we can now join the nodes &lt;code&gt;swarm-chip02&lt;/code&gt; and &lt;code&gt;swarm-chip02&lt;/code&gt; as Swarm managers with a single command for each of the nodes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip02 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
  192.168.2.112:2377
This node joined a swarm as a manager.

docker-machine ssh swarm-chip03 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
  192.168.2.112:2377
This node joined a swarm as a manager.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Swarm status and the list of all Swarm nodes can be determined by asking any of the three Swarm managers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1    swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw *  swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02  Ready   Active        Reachable
OSX: dieter@DietersMacBookPro in ~/code/github/hypriot/blog on deploy-swarm-on-chip-with-docker-machine

docker-machine ssh swarm-chip02 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1    swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw    swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c *  swarm-chip02  Ready   Active        Reachable
OSX: dieter@DietersMacBookPro in ~/code/github/hypriot/blog on deploy-swarm-on-chip-with-docker-machine

docker-machine ssh swarm-chip03 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1 *  swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw    swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02  Ready   Active        Reachable
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-5-let-s-grow-the-swarm-attach-all-swarm-workers&#34;&gt;Step 5: Let&amp;rsquo;s grow the Swarm, attach all Swarm workers&lt;/h4&gt;

&lt;p&gt;Now it&amp;rsquo;s time to join our remaining C.H.I.P. devices as Swarm workers to our Swarm cluster. For this purpose we just pick the token from the initial Swarm creation command. But if we can&amp;rsquo;t remember we can just ask one of the Swarm managers for the access token with the command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip02 docker swarm join-token worker
To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
    192.168.2.116:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s join our workers one by one now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip04 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.

docker-machine ssh swarm-chip05 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.

docker-machine ssh swarm-chip06 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a result we have joined all of the six C.H.I.P. devices to the Swarm cluster, three as Swarm managers and three as Swarm workers.&lt;/p&gt;

&lt;h4 id=&#34;step-6-attach-an-additional-pi-zero-as-swarm-worker&#34;&gt;Step 6: Attach an additional Pi Zero as Swarm worker&lt;/h4&gt;

&lt;p&gt;But we&amp;rsquo;re not limited in using only one kind of ARM devices for our Swarm cluster. So I&amp;rsquo;d like to add a different device, a Raspberry Pi Zero which is equipped with a &lt;a href=&#34;https://twitter.com/redbearlab&#34;&gt;RedBear IoT pHAT&lt;/a&gt; for WiFi/Bluetooth connectivity.
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-pi-zero.jpg&#34; alt=&#34;swarm-chip-pi-zero.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here you can see that using &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;HypriotOS for RPi&lt;/a&gt; and the Hypriot &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; it&amp;rsquo;s damn easy to create another ARM device with Docker 1.12.1 and attach it via WiFi to our network.&lt;/p&gt;

&lt;p&gt;Flash the SD card, and power up the Raspberry Pi Zero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n swarm-raspi01 -s &amp;quot;WLAN-R46VFR&amp;quot; -p &amp;quot;************&amp;quot; https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Determine the IP address of the Pi Zero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-raspi01.local
PING swarm-raspi01.local (192.168.2.119): 56 data bytes
64 bytes from 192.168.2.119: icmp_seq=0 ttl=64 time=617.658 ms
64 bytes from 192.168.2.119: icmp_seq=1 ttl=64 time=26.326 ms
64 bytes from 192.168.2.119: icmp_seq=2 ttl=64 time=1187.048 ms

--- swarm-raspi01.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 26.326/610.344/1187.048/473.891 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare SSH access to the Pi Zero, use username=&lt;code&gt;pirate&lt;/code&gt; and password=&lt;code&gt;hypriot&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -R 192.168.2.119
ssh-copy-id pirate@192.168.2.119
ssh pirate@192.168.2.119
uname -a
Linux swarm-raspi01 4.4.15-hypriotos+ #2 PREEMPT Mon Jul 25 09:18:11 UTC 2016 armv6l GNU/Linux
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Login and install a fix on the Pi so we can use the standard Docker Machine binary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@192.168.2.119
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/001-fix-docker-machine-1.8.0-create-for-arm/apply-fix-001.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back on our Mac we are able to run Docker Machine and attach the Raspi. As you can see, we do use another flag &lt;code&gt;--generic-ssh-user=pirate&lt;/code&gt; because we&amp;rsquo;re using a different username instead of the default &lt;code&gt;root&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RASPI_IP_ADDRESS=192.168.2.119
RASPI_NODENAME=swarm-raspi01

docker-machine --debug create \
  --driver=generic \
  --engine-storage-driver=overlay \
  --generic-ip-address=$RASPI_IP_ADDRESS \
  --generic-ssh-user=pirate \
  $RASPI_NODENAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few minutes only, the Raspberry Pi Zero can be accessed through Docker Machine with the exactly same methods and commands like the C.H.I.P. devices.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME            ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01    -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
swarm-chip02    -        generic   Running   tcp://192.168.2.116:2376           v1.12.1
swarm-chip03    -        generic   Running   tcp://192.168.2.117:2376           v1.12.1
swarm-chip04    -        generic   Running   tcp://192.168.2.118:2376           v1.12.1
swarm-chip05    -        generic   Running   tcp://192.168.2.120:2376           v1.12.1
swarm-chip06    -        generic   Running   tcp://192.168.2.104:2376           v1.12.1
swarm-raspi01   -        generic   Running   tcp://192.168.2.119:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we join our last Swarm worker, a lonely Raspberry Pi Zero running HypriotOS 1.0.1 and Docker 1.12.1, to the Swarm cluster.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-raspi01 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-7-check-the-complete-swarm&#34;&gt;Step 7: Check the complete Swarm&lt;/h4&gt;

&lt;p&gt;With the &lt;code&gt;docker node ls&lt;/code&gt; command issued on any of the Swarm managers we can list all the Swarm nodes, get their roles and status shown in the printed output on our terminal window.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip03 docker node ls
ID                           HOSTNAME       STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1 *  swarm-chip03   Ready   Active        Reachable
3inlk62a6l3afqp570nnus12f    swarm-raspi01  Ready   Active
7jvz6c8a852rve1r21fordkfa    swarm-chip04   Ready   Active
8174iszkmn4u4wwjogam8bsrw    swarm-chip01   Ready   Active        Leader
91ee08vkwuh3f6yelc4ci46se    swarm-chip05   Ready   Active
agglzv8ju0diwpd665nbhdtti    swarm-chip06   Ready   Active
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02   Ready   Active        Reachable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-node-ls.jpg&#34; alt=&#34;swarm-chip-node-ls.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-result-a-mixed-iot-swarm-running-docker-1-12&#34;&gt;THE RESULT: a mixed IoT Swarm running Docker 1.12&lt;/h3&gt;

&lt;p&gt;This is our newly created Swarm cluster, built with an USB power supply from Anker, 6x C.H.I.P. computers and a lonely Raspberry Pi Zero - all devices attached through a WiFi network and running Docker 1.12.1 with SwarmMode: &lt;br&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-complete-cluster.jpg&#34; alt=&#34;swarm-chip-complete-cluster.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;With this hardware setup we&amp;rsquo;ve now built a network of seven ARM devices for IoT which are all connected through WiFi. All the control traffic between the nodes are secured be default and can be centrally controlled through the Swarm managers and we can connect them securely from a local computer via Docker Machine. The ARM boards can be spread out in your house and can run different tasks as Docker containers&amp;hellip; but these details I&amp;rsquo;d like to cover in a future blog post.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Install Docker 1.12 on the $9 C.H.I.P. computer</title>
      <link>https://blog.hypriot.com/post/install-docker-on-chip-computer/</link>
      <pubDate>Sat, 03 Sep 2016 22:53:12 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/install-docker-on-chip-computer/</guid>
      <description>&lt;p&gt;Did you see the successfully launch of a really cheap ARM board for $9 only - the C.H.I.P. computer? It has an ARMv7 CPU with 512 MByte of main memory, 4 GByte flash memory as disk storage and is equipped with onboard WiFi and bluetooth as well.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-and-banana.jpg&#34; alt=&#34;chip-and-banana&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With these awesome features built-in it would be really a great device to run Docker containers if only the recent Linux kernel 4.4  has the correct modules included, but it doesn&amp;rsquo;t - what a bummer!&lt;/p&gt;

&lt;p&gt;But with spending a lot of time in building a custom Linux kernel and tweaking &amp;amp; testing I was finally able to install the latest Docker Engine for ARM on the C.H.I.P. &amp;mdash; and as a result you can easily follow this tutorial and within a few minutes only you can run your first Docker container on this cute ARM board&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-photo.jpg&#34; alt=&#34;chip-photo&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Preparing your operating system and your Linux kernel to be able to run the Docker Engine efficiently can be a hard thing and can consume a lot of labor time.&lt;/p&gt;

&lt;p&gt;Fortunately in this tutorial I&amp;rsquo;ll show you the basic steps to get Docker running on the $9 C.H.I.P. computer, so every normal user should be able to do it on her own within a short time only - even without the need being an expert in this area. And if you&amp;rsquo;re in a hurry you can skip most of the tutorial and go straight ahead to the &lt;code&gt;Lessons learned - TL;DR&lt;/code&gt; section and install Docker with just two single commands.&lt;/p&gt;

&lt;h3 id=&#34;necessary-steps-to-install-docker&#34;&gt;Necessary steps to install Docker&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Flash the latest available firmware&lt;/li&gt;
&lt;li&gt;Connect to the C.H.I.P. via USB or UART console cable&lt;/li&gt;
&lt;li&gt;Configure WiFi connection&lt;/li&gt;
&lt;li&gt;Configure SSH to access the C.H.I.P.&lt;/li&gt;
&lt;li&gt;Checking the OS and Linux kernel version&lt;/li&gt;
&lt;li&gt;Install the Docker Engine 1.12.1 the easy way&lt;/li&gt;
&lt;li&gt;Upgrade the Linux kernel to a custom built version&lt;/li&gt;
&lt;li&gt;Run your first Docker Container on the C.H.I.P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;step-1-flash-the-latest-available-firmware&#34;&gt;Step 1: Flash the latest available firmware&lt;/h4&gt;

&lt;p&gt;Use a Chrome browser and flash the latest firmware and OS on your C.H.I.P. computer. For detailed instructions go to the appropriate web site at &lt;a href=&#34;http://flash.getchip.com/&#34;&gt;http://flash.getchip.com/&lt;/a&gt;.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/flash-getchip-com.jpg&#34; alt=&#34;flash-getchip-com&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To run Docker on the C.H.I.P. we&amp;rsquo;re using the OS image for &lt;code&gt;Debian Headless 4.4&lt;/code&gt;, which is a server installation without any GUI and thus it&amp;rsquo;s quite smaller is size, so we do have more space left for running apps and Docker containers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; You can even see all the detailed log messages while flashing via an UART console cable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Starting download of 6291508 bytes
................................................
downloading of 6291508 bytes finished
Flashing sparse image on partition UBI at offset 0x26800000 (ID: 10)
start 0x9a00 blkcnt 0x180 partition 0x400 size 0x7fc00
Writing at offset 0x26800000
New offset 0x27400000
........ wrote 384 blocks to &#39;UBI&#39;

*****************[ FLASHING DONE ]*****************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-successfully-flashed.jpg&#34; alt=&#34;chip-successfully-flashed&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;step-2-connect-to-the-c-h-i-p-via-usb-or-uart-console-cable&#34;&gt;Step 2: Connect to the C.H.I.P. via USB or UART console cable&lt;/h4&gt;

&lt;p&gt;Once the C.H.I.P. is successfully flashed you can connect it directly with an USB cable to a Mac or Linux machine. The C.H.I.P. is getting power over the USB cable and connects via an USB serial console driver, so you can easily connect to.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find the booted C.H.I.P. on the USB wire:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -al /dev/cu.usb*
crw-rw-rw-  1 root  wheel   20, 159 Sep  3 16:52 /dev/cu.usbmodem141113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note 1:&lt;/em&gt; you have to wait a few minutes until the device can be detected as the C.H.I.P. has to be fully booted. &lt;br&gt;
&lt;em&gt;Note 2:&lt;/em&gt; it&amp;rsquo;s strongly recommended to use a powered USB hub, otherwise you&amp;rsquo;ll hit some power problems and the C.H.I.P. can&amp;rsquo;t access or can immediately shuts off&lt;/p&gt;

&lt;p&gt;Now we can connect to the ARM device via the &lt;code&gt;screen&lt;/code&gt; utility:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo screen /dev/cu.usbmodem141113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, and this is my preferred way, you can attach an UART console cable (e.g. from &lt;a href=&#34;https://www.adafruit.com/product/954&#34;&gt;AdaFruit&lt;/a&gt;) which is typically shown as a device on the Mac like &lt;code&gt;/dev/cu.usbserial&lt;/code&gt;. With this setup you can even watch the complete boot logs of the C.H.I.P. computer and you are able to see all early boot messages from U-Boot and from loading and starting the Linux kernel. This gives you all details in case there are any problems and issues with a homegrown kernel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo screen /dev/cu.usbserial 115200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you get to the login message, you can use username &lt;code&gt;root&lt;/code&gt; and password &lt;code&gt;chip&lt;/code&gt; to login:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Debian GNU/Linux 8 chip ttyS0

chip login: root
Password:
Linux chip 4.4.11-ntc #1 SMP Sat May 28 00:27:07 UTC 2016 armv7l

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@chip:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-3-configure-wifi-connection&#34;&gt;Step 3: Configure WiFi connection&lt;/h4&gt;

&lt;p&gt;Following the instruction here &lt;a href=&#34;http://docs.getchip.com/chip.html#wifi-connection&#34;&gt;http://docs.getchip.com/chip.html#wifi-connection&lt;/a&gt; you can list all the available WiFi networks and then connect the C.H.I.P. to your preferred network.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi list
*  SSID         MODE   CHAN  RATE       SIGNAL  BARS  SECURITY
   HITRON-FEE0  Infra  11    54 Mbit/s  67      ▂▄▆_  WPA2
   WLAN-R46VFR  Infra  1     54 Mbit/s  65      ▂▄▆_  WPA2
   My ASUS      Infra  6     54 Mbit/s  64      ▂▄▆_  WPA2
   WLAN-718297  Infra  1     54 Mbit/s  59      ▂▄▆_  WPA2
   WLAN-MCQYPS  Infra  1     54 Mbit/s  30      ▂___  WPA2
   Telekom_FON  Infra  1     54 Mbit/s  27      ▂___  --

*  SSID  MODE  CHAN  RATE  SIGNAL  BARS  SECURITY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connect to the WiFi station with the SSID &lt;code&gt;mySSID&lt;/code&gt; and password &lt;code&gt;myPASSWORD&lt;/code&gt;, please insert you own SSID and PASSWORD. In this example I&amp;rsquo;m using the SSID &lt;code&gt;WLAN-R46VFR&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi connect &#39;WLAN-R46VFR&#39; password &#39;**********&#39; ifname wlan0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you are connected you can see the &amp;lsquo;*&amp;rsquo; in front of your connected WiFi network:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi list
*  SSID         MODE   CHAN  RATE       SIGNAL  BARS  SECURITY
   HITRON-FEE0  Infra  11    54 Mbit/s  67      ▂▄▆_  WPA2
   My ASUS      Infra  6     54 Mbit/s  64      ▂▄▆_  WPA2
   WLAN-718297  Infra  1     54 Mbit/s  59      ▂▄▆_  WPA2
   WLAN-MCQYPS  Infra  1     54 Mbit/s  30      ▂___  WPA2
   Telekom_FON  Infra  1     54 Mbit/s  27      ▂___  --
*  WLAN-R46VFR  Infra  1     54 Mbit/s  100     ▂▄▆█  WPA2

*  SSID  MODE  CHAN  RATE  SIGNAL  BARS  SECURITY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the C.H.I.P. should have got an IP address from the DHCP server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifconfig wlan0
wlan0     Link encap:Ethernet  HWaddr cc:79:cf:20:6d:d8
          inet addr:192.168.2.112  Bcast:192.168.2.255  Mask:255.255.255.0
          inet6 addr: fe80::ce79:cfff:fe20:6dd8/64 Scope:Link
          inet6 addr: 2003:86:8c18:1a37:ce79:cfff:fe20:6dd8/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:119 errors:0 dropped:1 overruns:0 frame:0
          TX packets:102 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:24656 (24.0 KiB)  TX bytes:16973 (16.5 KiB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re connected to the network and can access the internet and the C.H.I.P. can be reached from our Mac or Linux machine.&lt;/p&gt;

&lt;h4 id=&#34;step-4-configure-ssh-to-access-the-c-h-i-p&#34;&gt;Step 4: Configure SSH to access the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;Here we have to use the same username &lt;code&gt;root&lt;/code&gt; and password &lt;code&gt;chip&lt;/code&gt; to login via SSH:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-add
ssh-keygen -R 192.168.2.112
ssh-copy-id root@192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we can login to the C.H.I.P. computer via SSH:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh root@192.168.2.112

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Thu Jan  1 00:32:25 1970
-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
root@chip:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-5-checking-the-os-and-linux-kernel-version&#34;&gt;Step 5: Checking the OS and Linux kernel version&lt;/h4&gt;

&lt;p&gt;As a first step we&amp;rsquo;d like to check the current Linux kernel version and operating system.&lt;/p&gt;

&lt;p&gt;Kernel version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.11-ntc #1 SMP Sat May 28 00:27:07 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operating system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /etc/os-release
PRETTY_NAME=&amp;quot;Debian GNU/Linux 8 (jessie)&amp;quot;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;
VERSION_ID=&amp;quot;8&amp;quot;
VERSION=&amp;quot;8 (jessie)&amp;quot;
ID=debian
HOME_URL=&amp;quot;http://www.debian.org/&amp;quot;
SUPPORT_URL=&amp;quot;http://www.debian.org/support&amp;quot;
BUG_REPORT_URL=&amp;quot;https://bugs.debian.org/&amp;quot;
BUILD_ID=Wed Jun  1 05:34:36 UTC 2016
VARIANT=&amp;quot;Debian on C.H.I.P&amp;quot;
VARIANT_ID=SERVER
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-6-install-the-docker-engine-1-12-1-the-easy-way&#34;&gt;Step 6: Install the Docker Engine 1.12.1 the easy way&lt;/h4&gt;

&lt;p&gt;In order to install Docker I&amp;rsquo;ve prepared a complete installation script which can be downloaded and executed in a single command line. I&amp;rsquo;ve you&amp;rsquo;re interested into the details you should check the script at &lt;a href=&#34;https://github.com/DieterReuter/arm-docker-fixes/blob/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install Docker
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of running the install script we&amp;rsquo;ll see some errors occurred and the start of the Docker Engine has failed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Errors were encountered while processing:
 docker-engine
E: Sub-process /usr/bin/dpkg returned an error code (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is OK for now as it just indicates the default Linux kernel isn&amp;rsquo;t able to run Docker on the C.H.I.P. and we have to build and install a custom Linux kernel which has all the necessary kernel settings for Docker enabled.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re interested in analyzing these errors in more detail you can run the command &lt;code&gt;systemctl status docker.service&lt;/code&gt; and you&amp;rsquo;ll get more detailed log messages from &lt;code&gt;systemd&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# systemctl status docker.service -l
● docker.service - Docker Application Container Engine
   Loaded: loaded (/etc/systemd/system/docker.service; enabled)
   Active: failed (Result: exit-code) since Sat 2016-09-03 13:20:49 UTC; 2min 23s ago
     Docs: https://docs.docker.com
 Main PID: 10840 (code=exited, status=1/FAILURE)

Sep 03 13:20:48 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:48.580271961Z&amp;quot; level=info msg=&amp;quot;libcontainerd: new containerd process, pid: 10848&amp;quot;
Sep 03 13:20:49 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:49.652832502Z&amp;quot; level=error msg=&amp;quot;&#39;overlay&#39; not found as a supported filesystem on this host. Please ensure kernel is new enough and has overlay support loaded.&amp;quot;
Sep 03 13:20:49 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:49.656854332Z&amp;quot; level=fatal msg=&amp;quot;Error starting daemon: error initializing graphdriver: driver not supported&amp;quot;
Sep 03 13:20:49 chip systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE
Sep 03 13:20:49 chip systemd[1]: Failed to start Docker Application Container Engine.
Sep 03 13:20:49 chip systemd[1]: Unit docker.service entered failed state.
Sep 03 13:20:50 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:52 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:53 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:54 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-7-upgrade-the-linux-kernel-to-a-custom-built-version&#34;&gt;Step 7: Upgrade the Linux kernel to a custom built version&lt;/h4&gt;

&lt;p&gt;In order to keep this tutorial short and easy to follow, I&amp;rsquo;d like to use an already prepared custom kernel which has nearly all the possible kernel modules and settings enabled to run the Docker Engine in an optimized way on the C.H.I.P. computer.&lt;/p&gt;

&lt;p&gt;Therefore we only have to install our new Linux kernel and have to reboot the system to activate it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install custom Linux Kernel and reboot
curl -sSL https://github.com/hypriot/binary-downloads/releases/download/chip-kernel-4.4.11/4.4.11-hypriotos.tar.bz2 | tar xvfj - -C /
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After rebooting we&amp;rsquo;re going to check the kernel version again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.11-hypriotos #1 SMP Mon Aug 29 19:18:49 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the Docker client version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker -v
Docker version 1.12.1, build 23cf638
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the Docker server version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker version
Client:
 Version:      1.12.1
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   23cf638
 Built:        Thu Aug 18 05:31:15 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.1
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   23cf638
 Built:        Thu Aug 18 05:31:15 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting the detailed informations about the Docker Engine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.12.1
Storage Driver: overlay
 Backing Filesystem: &amp;lt;unknown&amp;gt;
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: null host bridge overlay
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Security Options:
Kernel Version: 4.4.11-hypriotos
Operating System: Debian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 1
Total Memory: 491 MiB
Name: chip
ID: SSJ5:7OTQ:BCAZ:4MDL:VEW6:VKND:3J6W:UI3O:UTBB:7H5V:LQ4W:ABRP
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we could see, the latest Docker Engine v1.12.1 is now installed and is successfully running.&lt;/p&gt;

&lt;h4 id=&#34;step-8-run-your-first-docker-container-on-the-c-h-i-p&#34;&gt;Step 8: Run your first Docker Container on the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;As a last step we&amp;rsquo;d like to start a first Docker container, a small web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
fec2773baaec570ba8b6e00296dfd11b4b4768d1b51e574d851968b9225b9d22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start your web browser and point it to the website from our Docker container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open http://192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/first-container-on-chip.jpg&#34; alt=&#34;first-container-on-chip&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Additional tip:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After installing some packages via &lt;code&gt;apt-get&lt;/code&gt; it&amp;rsquo;s a good idea to clean the APT cache from time to time and save disk space.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# apt-get clean
root@chip:~# df -h
Filesystem      Size  Used Avail Use% Mounted on
ubi0:rootfs     3.7G  373M  3.3G  11% /
devtmpfs        213M     0  213M   0% /dev
tmpfs           246M     0  246M   0% /dev/shm
tmpfs           246M  6.7M  239M   3% /run
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           246M     0  246M   0% /sys/fs/cgroup
tmpfs            50M     0   50M   0% /run/user/0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lessons-learned-tl-dr&#34;&gt;Lessons learned - TL;DR&lt;/h3&gt;

&lt;p&gt;Currently the C.H.I.P. isn&amp;rsquo;t able to run Docker out-of-the-box, but it just needs to install a custom built Linux kernel to prepare this awesome ARM board to run Docker easily. And now we&amp;rsquo;re able to install the officially built Docker Engine from the Docker project&amp;rsquo;s APT repository.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/em&gt; &lt;BR&gt;
these are the only commands you need to install Docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install Docker
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh | bash

# install custom Linux Kernel and reboot
curl -sSL https://github.com/hypriot/binary-downloads/releases/download/chip-kernel-4.4.11/4.4.11-hypriotos.tar.bz2 | tar xvfj - -C /
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the best thing is, according to this &lt;a href=&#34;https://twitter.com/zerotri/status/771218366845497344&#34;&gt;tweet&lt;/a&gt;, the developers at &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt; have already started to include all the required kernel settings into the standard OS images. So we can expect that the Docker Engine can be installed in the future even without tweaking the Linux kernel.&lt;/p&gt;

&lt;h3 id=&#34;outlook&#34;&gt;Outlook&lt;/h3&gt;

&lt;p&gt;As I told you at the beginning of this tutorial, these are just the basic steps for a normal user to install and use Docker on the C.H.I.P. computer. But if you&amp;rsquo;re interested in all the technical details behind the scene, how to check and analyze your Linux kernel and how to optimize it for running Docker efficiently, then please drop me a comment or tweet me and I&amp;rsquo;ll write even more about all the technical details so you can follow the path along on to an expert level too. With these skills you then should be able to install Docker on any Linux-based ARM device.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Releasing HypriotOS 1.0.0 &#34;Blackbeard&#34;</title>
      <link>https://blog.hypriot.com/post/releasing-HypriotOS-1-0/</link>
      <pubDate>Sun, 21 Aug 2016 12:30:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/releasing-HypriotOS-1-0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Today we proudly present our 1.0.0 release of HypriotOS – a container OS that takes you from Zero to Docker within 5 Minutes only, on any device of the complete Raspberry Pi family.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For this major release we&amp;rsquo;ve taken an especially great deal of trouble. Out of the box, you not only get the breaking features of the Docker Engine 1.12.1 and the latest versions of Docker Compose and Docker Machine, but also many improvements that enhance the performance, reliability and usability.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/release-1-0/docker_pirate_650px_full-width.jpg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Therefore, this release illustrates very much how we work as Hypriot Team: We don&amp;rsquo;t stop after a &lt;code&gt;docker run&lt;/code&gt; just works on a Raspberry Pi. Meanwhile this has been possible for a long time. We only stop, when we went all the way down the rabbit whole and identified all adjusting screws of the operating system that can be used to improve the &lt;strong&gt;performance, reliability and usability&lt;/strong&gt; to run containers efficiently on ARM. Just to name a few examples: we include a Linux Kernel that is optimized for running Docker, we set all recommended configuration settings stated by Docker (and more), and provide tools that make the process of downloading HypriotOS and flashing it on a SD card super easy (see our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; and &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;As a result, you can be sure that we fine-tuned all adjusting screws to ensure we provide not some container OS, but an awesome one.&lt;/p&gt;

&lt;h2 id=&#34;feature-highlights-of-hypriotos&#34;&gt;Feature Highlights of HypriotOS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Latest Docker Engine 1.12.1 with Swarm Mode&lt;/strong&gt; &lt;/br&gt;
You can get your hands on the new features of the freshly-baked Engine Docker 1.12.1 that is still warm. It includes the new Swarm Mode, which allows high availability of services in a multi-node cluster within just a few commands.
&lt;a href=&#34;https://blog.docker.com/2016/07/swarm-mode-on-a-raspberry-pi-cluster/&#34;&gt;See this short video how it works.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Support for the complete Raspberry Pi family&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS on each and every model of the Raspberry Pi family - we&amp;rsquo;re supporting Pi 1, 2, 3, Zero and even the Compute Module. Thus, all Raspberry Pi devices ever built are fully supported. This is possible through the dual kernels for ARMv6 and ARMv7 architecure we included on the SD card. Guess what: you can even switch your SD card from one Pi model to the other and it just works.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Easy flashing and configuration&lt;/strong&gt; &lt;/br&gt;
We improved our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;, which puts HypriotOS onto a SD card that is ready to boot from with a single command. After you flashed the SD card, you can store the settings of your environment, e.g. Wi-Fi connection parameters into a configuration file on the SD card &lt;code&gt;/boot/device-init.yaml&lt;/code&gt;. HypriotOS includes &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;, which makes your Raspberry Pi directly connecting to your Wi-Fi network after booting.
After booting, you can find the Raspberry Pi at your network with a simple &lt;code&gt;ping black-pearl.local&lt;/code&gt; – no more searching for IP addresses required thanks to the integrated Avahi service discovery.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enhanced security out of the box&lt;/strong&gt; &lt;/br&gt;
We think that security should be shipped out-of-the-box. We make HypriotOS more secure without you even noticing it. For instance, there is no built-in &amp;ldquo;root&amp;rdquo; user any more. Also, the default user &amp;ldquo;pirate&amp;rdquo; (password &amp;ldquo;hypriot&amp;rdquo;) is able to run Docker commands directly, which usually requires sudo rights. For an even better security, we strongly recommend to change the default user password and to restrict SSH access to pre-shared keys only with disabling SSH password authentication.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maximum performance out of the box&lt;/strong&gt; &lt;/br&gt;
As with security, running Docker with high performance comes out-of-the-box with HypriotOS. This includes faster booting times (15-17 sec.), an optimized file system to support more Inodes, minimal memory footprint and disk usage, and the reliable overlay storage driver for Docker by default.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Now 50% smaller in size, even smaller than Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
Even though HypriotOS 1.0.0 is fully packed with the complete and latest Docker tool set, it now comes at a size smaller than the tiniest version of Raspbian (&amp;ldquo;Raspbian Lite&amp;rdquo;). We achieved this mainly by reducing the cache&amp;rsquo;s footprint and leaving out some unused packages, so you won&amp;rsquo;t miss any features you are used to. You just need to download only 232 MB instead of 504 MB as before. With this improvements the minimum disk usage is reduced down to 600 MB.&lt;/p&gt;

&lt;p&gt;Please see all details in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases/tag/v1.0.0&#34;&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick start&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Download our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; and run&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Afterwards, put the SD card into the Raspberry Pi and power it. That&amp;rsquo;s all to get HypriotOS up and running!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;If you wanna connect to the Raspberry Pi, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with password &amp;ldquo;hypriot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you want the Raspberry Pi to connect directly to your Wi-Fi after boot, change the hostname of the Raspberry Pi and more, edit &lt;code&gt;/boot/device-init.yaml&lt;/code&gt; of the SD card and have a look at the &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;documentation of device-init&lt;/a&gt;. Alternatively, checkout the parameters of the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt; that also allows you to define configurations. Really, it&amp;rsquo;s just so damn easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n myHOSTNAME -s mySSID -p myWIFIPASSWORD https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h2&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Your Hypriot Team:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Andreas &lt;a href=&#34;https://twitter.com/firecyberice&#34;&gt;@firecyberice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mathias &lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Building Docker 1.12 on a Raspberry Pi</title>
      <link>https://blog.hypriot.com/post/building-docker-directly-on-a-raspberry-pi/</link>
      <pubDate>Sun, 31 Jul 2016 15:24:03 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/building-docker-directly-on-a-raspberry-pi/</guid>
      <description>&lt;p&gt;Over time many of our users have asked us exactly how we build the Docker Engine
and the associated Debian packages. For instance: they&amp;rsquo;d like to hack on some
 new features and need the latest software releases as soon as possible.&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;ll share all the details on building the latest Docker version - even on
a Raspberry Pi itself. Beware: while it&amp;rsquo;s not too complicated it will require
a large amount of time!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/build-docker-on-raspberrypi/docker-on-raspberrypi.jpg&#34; alt=&#34;Docker on Raspberry&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s get started. Follow me down the &lt;em&gt;Rabbit Hole&lt;/em&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;The goal of this tutorial is to give you all the details you need to build the
Docker Engine yourself on your cool and fast $35 super-computer (the Raspberry Pi).&lt;/p&gt;

&lt;h3 id=&#34;prepare-the-build-environment&#34;&gt;Prepare the Build Environment&lt;/h3&gt;

&lt;p&gt;Before we begin this arduous task have to prepare our build environment for what
will be a large, long-running workload.&lt;/p&gt;

&lt;h4 id=&#34;hardware-and-software-requirements&#34;&gt;Hardware and Software Requirements&lt;/h4&gt;

&lt;p&gt;For building the Docker Engine in the recommended way we need a Linux computer which
already has a recent version of Docker running. Yeah, the Docker Engine will be build
inside of a Docker container to get a consistent and reproducible build environment.
As this requires some CPU power and disk space, I&amp;rsquo;m giving you here the minimal
specs for the hardware.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3 (a Pi 2 will work, but the build process will take even longer!)&lt;/li&gt;
&lt;li&gt;16 GByte SD card (8 GByte is not enough!)&lt;/li&gt;
&lt;li&gt;enabled swap space (1 GByte of memory is not sufficient!)&lt;/li&gt;
&lt;li&gt;Docker Engine 1.11&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;installing-the-build-environment&#34;&gt;Installing the Build Environment&lt;/h4&gt;

&lt;p&gt;As you will see, setting up the build environment is damn easy, because we&amp;rsquo;ll just
use the latest release of HypriotOS which has the required Docker Engine 1.11.1
already pre-installed. These steps here are done on OS X, on a Linux or Windows
box it&amp;rsquo;s a little bit different.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step 1:&lt;/em&gt; install HypriotOS 0.8.2 on a SD card&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ flash https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.2/hypriotos-rpi-v0.8.2.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now boot the Raspberry Pi 3 with the newly flashed SD card.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step 2:&lt;/em&gt; deploy SSH keys&lt;/p&gt;

&lt;p&gt;(Note: login credentials are username=pirate, password=hypriot)&lt;/p&gt;

&lt;p&gt;First, wait until the Raspberry Pi is booted up and is visible on the network
to gather it&amp;rsquo;s IP address.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping -c 1 black-pearl.local
PING black-pearl.local (192.168.2.113): 56 data bytes
64 bytes from 192.168.2.113: icmp_seq=0 ttl=64 time=5.697 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, deploy your standard SSH keys to the Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-add
$ ssh-keygen -R 192.168.2.113
$ ssh-copy-id pirate@192.168.2.113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re able to login into the Raspberry Pi without using a password.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pirate@192.168.2.113

$ uname -a
Linux black-pearl 4.4.15-hypriotos-v7+ #1 SMP PREEMPT Mon Jul 25 08:46:52 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Step 3:&lt;/em&gt; install some build dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install -y make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Step 4:&lt;/em&gt; using a swap file&lt;/p&gt;

&lt;p&gt;This will create and use a default 2x 1GByte swap file at /var/swap.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install -y dphys-swapfile
$ ls -alh /var/swap
-rw------- 1 root root 1.8G Jul 30 17:58 /var/swap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we need a larger swap file, we could edit the config file &lt;code&gt;/etc/dphys-swapfile&lt;/code&gt;,
but for our use case the default 1.8 GByte swap file is sufficient.&lt;/p&gt;

&lt;h3 id=&#34;clone-the-docker-repo&#34;&gt;Clone the Docker repo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/docker/docker.git
$ cd docker
$ git checkout v1.12.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we&amp;rsquo;re using a tagged release for Docker to build this exact version.&lt;/p&gt;

&lt;h3 id=&#34;how-to-apply-some-extra-pull-requests&#34;&gt;How to apply some extra Pull Requests&lt;/h3&gt;

&lt;p&gt;Just to be honest, right now the build process for Docker v1.12.0 will fail on ARM.
This is a known issue and will be fixed hopefully soon. But luckily there is already
a &lt;a href=&#34;https://github.com/docker/docker/pull/25192&#34;&gt;pull request&lt;/a&gt;
which enables us to build the Docker .deb packages. This gives me
the change to explain how you can easily apply a PR on top of a release version.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s cherry pick this specific pull request.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin pull/25192/head:fix-manpages-on-arm
$ git cherry-pick fix-manpages-on-arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally let&amp;rsquo;s check if everything is OK with the git history.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;commit e15322b4fcb173674fd62a329a51b0756f02d503
Author: Daniel Nephin &amp;lt;dnephin@docker.com&amp;gt;
Date:   Thu Jul 28 14:53:08 2016 -0400

    Fix the man/Dockerfile for arm

    Signed-off-by: Daniel Nephin &amp;lt;dnephin@docker.com&amp;gt;

commit 8eab29edd820017901796eb60d4bea28d760f16f
Author: Tibor Vass &amp;lt;tibor@docker.com&amp;gt;
Date:   Wed Jul 27 16:35:10 2016 -0700

    Bump VERSION to v1.12.0

    Signed-off-by: Tibor Vass &amp;lt;tibor@docker.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the second last commit is the release commit for the official v1.12.0
version of the Docker Engine. The last commit is from the applied PR.&lt;/p&gt;

&lt;h3 id=&#34;run-the-build&#34;&gt;Run the build&lt;/h3&gt;

&lt;p&gt;And here comes the magic: we&amp;rsquo;ll start the build process and then have to wait
for a really long time for it to finish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time make deb

...
real	350m48.228s
user	0m22.140s
sys	0m4.870s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete build process takes almost 6 hours on a fast Raspberry Pi 3, but finally
we&amp;rsquo;ll get the Docker Engine v1.12.0 build for a few different ARM operating systems.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -al ~/docker/bundles/1.12.0/build-deb/*/*.deb
-rw-r--r-- 1 root root 15933554 Jul 31 10:46 /home/pirate/docker/bundles/1.12.0/build-deb/debian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb
-rw-r--r-- 1 root root 15945462 Jul 31 12:28 /home/pirate/docker/bundles/1.12.0/build-deb/raspbian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb
-rw-r--r-- 1 root root 15915910 Jul 31 13:40 /home/pirate/docker/bundles/1.12.0/build-deb/ubuntu-trusty/docker-engine_1.12.0-0~trusty_armhf.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install the Docker Engine on our Raspberry Pi&amp;rsquo;s, we just pick&lt;/p&gt;

&lt;p&gt;&lt;code&gt;raspbian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the install process on HypriotOS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get purge -y docker-hypriot
$ sudo dpkg -i docker-engine_1.12.0-0~jessie_armhf.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we do have the latest release version v1.12.0 of the Docker Engine running
on our Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker version
Client:
 Version:      1.12.0
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   e15322b4f
 Built:        Sun Jul 31 11:41:45 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.0
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   e15322b4f
 Built:        Sun Jul 31 11:41:45 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;what-other-build-options-can-be-used&#34;&gt;What other build options can be used?&lt;/h3&gt;

&lt;p&gt;Some Raspberry Pi owners such as &lt;a href=&#34;http://blog.alexellis.io/&#34;&gt;Alex Ellis&lt;/a&gt; run Docker on &lt;a href=&#34;http://archlinuxarm.org&#34;&gt;Arch Linux for ARM (ALARM)&lt;/a&gt; or other compatible Linux distributions. For most non-Debian
distributions it makes sense to build a static binary with the below command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/docker
$ time make binary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will find the binary files in the &lt;code&gt;bundles&lt;/code&gt; folder and can then move then to &lt;code&gt;/usr/bin&lt;/code&gt; or &lt;code&gt;/usr/local/bin&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;lessons-learned&#34;&gt;Lessons learned&lt;/h3&gt;

&lt;p&gt;With the right Raspberry Pi OS and the Docker Engine already pre-installed, it&amp;rsquo;s
pretty easy and straight forward to build the next version of the Docker Engine
directly and natively on a standard Raspberry Pi.&lt;/p&gt;

&lt;p&gt;I strongly recommend to use the faster Raspberry Pi 3 and a SD card of at least
16 GByte, with a smaller SD card the build will crash after some hours and you
have to start all over again!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Edits by &lt;a href=&#34;http://twitter.com/alexellisuk&#34;&gt;Alex Ellis&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swarm Machines or Having fun with Docker Machine and the new Docker Swarm orchestration</title>
      <link>https://blog.hypriot.com/post/swarm-machines-or-having-fun-with-docker-machine-and-the-new-docker-swarm-orchestration/</link>
      <pubDate>Tue, 21 Jun 2016 13:49:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/swarm-machines-or-having-fun-with-docker-machine-and-the-new-docker-swarm-orchestration/</guid>
      <description>&lt;p&gt;In the last couple of days there were some users on our Gitter channel having problems accessing their Raspberry Pi&amp;rsquo;s with HypriotOS via Docker Machine.
As we have not yet written how that works I thought I would do a short blog post on how to use Docker Machine with HypriotOS.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not all. Yesterday when I watched the DockerCon Keynote Livestream of the new Docker orchestration I wondered how Docker Machine and the new orchestration would work together.&lt;/p&gt;

&lt;p&gt;So just for the fun of it I decided I will explore that a bit, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/docker-machine/swarm_machines.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/thewakingdragon/&#34;&gt;Brent M&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;I am using the latest Docker4Mac with Docker on my notebook and three Raspberry Pi&amp;rsquo;s with HypriotOS 0.8 as hosts for my remote Docker Engines.&lt;/p&gt;

&lt;p&gt;The Docker version on the notebook and on the Pi&amp;rsquo;s is 1.12 RC1. Having the lastest Docker 1.12 is not necessary for the part about Docker Machine, but it is for the part about the new Docker orchestration.&lt;/p&gt;

&lt;h2 id=&#34;docker-machine&#34;&gt;Docker Machine&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt; is used to control remote Docker-Engines as if they were locally installed.&lt;/p&gt;

&lt;p&gt;That is very convenient in many cases, for instance if you have set up a Docker host with the help of Amazon AWS or Microsoft Azure and you can access it only remotely.
In that case you do not have to establish a SSH connection first in order to work with a specific Docker Engine.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not all - Docker Machine also helps if there is no Docker-Engine present on a remote host.&lt;/p&gt;

&lt;p&gt;With the help of Docker Machine it is very easy to install and configure a new Docker Engine.&lt;/p&gt;

&lt;p&gt;Both in case of an existing or a new Docker Engine Docker Machine reconfigures the Engine to make it availabe via a HTTP network socket.
To ensure that only authorized clients can connect to the remote Docker Engine Docker Machine also sets up everything that is needed for &lt;a href=&#34;https://docs.docker.com/engine/security/https/&#34;&gt;securing the communication with TLS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To remotely manage my Pi&amp;rsquo;s with Docker Machine I first need to copy my SSH public key to the remote host.
If you do not have a SSH key pair you need to &lt;a href=&#34;https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#generating-a-new-ssh-key&#34;&gt;generate one first&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Transfering your public key to a remote host is easily done with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-copy-id pirate@pi3.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command configures the remote host &amp;lsquo;pi3.local&amp;rsquo; in a way that I can access this host via SSH with my default SSH key (~/.ssh/id_rsa).&lt;/p&gt;

&lt;p&gt;We can test this now by executing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pirate@pi3.local ls -lah
total 32K
drwxr-xr-x 3 pirate pirate 4.0K Jun 21 12:01 .
drwxr-xr-x 3 root   root   4.0K May 17 22:43 ..
-rw------- 1 pirate pirate  116 Jun 21 12:01 .bash_history
-rw-r--r-- 1 pirate pirate  220 Oct 18  2014 .bash_logout
-rw-r--r-- 1 pirate pirate 2.5K May 17 22:42 .bash_prompt
-rw-r--r-- 1 pirate pirate  570 May 17 22:42 .bashrc
-rw-r--r-- 1 pirate pirate  314 May 17 22:42 .profile
drwx------ 2 pirate pirate 4.0K Jun 21 12:09 .ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command establishes a SSH connection to the host &amp;lsquo;pi3.local&amp;rsquo; and executes &amp;lsquo;ls -lah&amp;rsquo;. If you can see a similar output everything is OK.&lt;/p&gt;

&lt;p&gt;Next we need to add our &amp;lsquo;pi3.local&amp;rsquo; host to the list of hosts that are managed by Docker Machine.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we already have some existing hosts that are managed by Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine ls
NAME   ACTIVE   DRIVER    STATE     URL                          SWARM   DOCKER        ERRORS
pi1    -        generic   Running   tcp://192.168.178.171:2376           v1.12.0-rc1
pi2    -        generic   Running   tcp://192.168.178.24:2376            v1.12.0-rc1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And indeed we have two hosts that are already managed by Docker Machine.&lt;/p&gt;

&lt;p&gt;Adding another one is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine create --driver generic --generic-ip-address=192.168.178.59 --generic-ssh-key=/Users/govindaf/.ssh/id_rsa --generic-ssh-user=pirate --engine-storage-driver=overlay pi3
Running pre-create checks...
Creating machine...
(pi3) Importing SSH key...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with debian...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env pi3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output looks good. Let&amp;rsquo;s dissect this command a bit to understand what it does.&lt;/p&gt;

&lt;p&gt;We are using the &amp;lsquo;create&amp;rsquo; subcommand of Docker Machine to create a new host that is managed by Docker Machine.
We are also using the &amp;lsquo;generic&amp;rsquo; driver that allows us to communicate with our Raspberry Pi&amp;rsquo;s via SSH.&lt;/p&gt;

&lt;p&gt;For this we need to tell Docker Machine some SSH connection details like the IP address of our target host, the SSH user and the location of our private SSH key.&lt;/p&gt;

&lt;p&gt;The IP address of our Pi can be easily obtained by running&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping -c1 pi3.local
PING pi3.local (192.168.178.59): 56 data bytes
64 bytes from 192.168.178.59: icmp_seq=0 ttl=64 time=1.926 ms

--- pi3.local ping statistics ---
1 packets transmitted, 1 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 1.926/1.926/1.926/0.000 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is important that we provide the absolute path to our private SSH key with the option &amp;lsquo;generic-ssh-key&amp;rsquo;. A relative path did not work for me.&lt;/p&gt;

&lt;p&gt;Furthermore we need to tell Docker Machine which user it should use for the SSH connection.
The default here is the &amp;lsquo;root&amp;rsquo; user. With HypriotOS we can only use an unprivileged user which is why we need to provide the &amp;lsquo;generic-ssh-user&amp;rsquo; option.&lt;/p&gt;

&lt;p&gt;Last but no least we need to tell Machine to use the &amp;lsquo;overlay&amp;rsquo; filesystem for the configuration of the Docker Engine which is the default with HypriotOS.
Without this option Docker Machine would try to use &amp;lsquo;aufs&amp;rsquo; which would fail miserably.&lt;/p&gt;

&lt;p&gt;Alright, let&amp;rsquo;s see if we now have a third host under our Machine control:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine ls
NAME   ACTIVE   DRIVER    STATE     URL                          SWARM   DOCKER        ERRORS
pi1    -        generic   Running   tcp://192.168.178.171:2376           v1.12.0-rc1
pi3    -        generic   Running   tcp://192.168.178.59:2376            v1.12.0-rc1
pi2    -        generic   Running   tcp://192.168.178.24:2376            v1.12.0-rc1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yeah - we do.&lt;/p&gt;

&lt;p&gt;Sometimes you might get SSH timeout errors when setting up another host with Docker-Machine.
If this is the case make sure you did not forget to set up your SSH public key with the remote host first.&lt;/p&gt;

&lt;p&gt;Sometimes when Docker Machine tries to add a new host it happens that it is stuck halfway with an error.
In those cases the best course of action is often to remove the host first and add it again later.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine rm pi3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s assume all went well and we now have a list of host under remote control. How do you work with those now?&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s were the Docker Machine &amp;lsquo;env&amp;rsquo; subcommand comes into play.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine env pi3
export DOCKER_TLS_VERIFY=&amp;quot;1&amp;quot;
export DOCKER_HOST=&amp;quot;tcp://192.168.178.59:2376&amp;quot;
export DOCKER_CERT_PATH=&amp;quot;/Users/govindaf/.docker/machine/machines/pi3&amp;quot;
export DOCKER_MACHINE_NAME=&amp;quot;pi3&amp;quot;
# Run this command to configure your shell:
# eval $(docker-machine env pi3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The env command outputs a bunch of environment variables that control to which Docker instance our local Docker binary is talking to.
Per default the &amp;lsquo;docker&amp;rsquo; command only talks to our local Docker Engine - for instance on our notebook - but by exporting those environment variables this changes fundamentally.&lt;/p&gt;

&lt;p&gt;The easiest way to export the necessary variables is by running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything I do with the &amp;lsquo;docker&amp;rsquo; command runs against the Docker Engine of my &amp;lsquo;pi3&amp;rsquo; host.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check if that is true:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 27
Server Version: 1.12.0-rc1
Storage Driver: overlay
 Backing Filesystem: extfs
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge null host overlay
Swarm: inactive
Runtimes: default
Default Runtime: default
Security Options:
Kernel Version: 4.4.10-hypriotos-v7+
Operating System: Raspbian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 4
Total Memory: 925.4 MiB
Name: pi3
ID: 5DYT:MHTS:4JQK:KNGB:FYZI:EFG4:YIPZ:2WJR:VW5Y:KLPJ:WXCX:S3CG
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
WARNING: No cpuset support
Labels:
 provider=generic
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see with the &amp;lsquo;Name&amp;rsquo; attribute, we are really working on host &amp;lsquo;pi3&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Changing to another host is also easy.&lt;/p&gt;

&lt;p&gt;Just repeat the command from above and replace the hostname with another:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;docker-machine-and-docker-swarm-mode&#34;&gt;Docker Machine and Docker Swarm Mode&lt;/h2&gt;

&lt;p&gt;In the past Docker Machine allowed to set up a Docker Swarm cluster with a &lt;a href=&#34;https://docs.docker.com/machine/reference/create/&#34;&gt;number of options&lt;/a&gt; for the &amp;lsquo;create&amp;rsquo; subcommand.&lt;/p&gt;

&lt;p&gt;With Docker 1.12 we now how a much more powerful version of Swarm that is directly integrated into Docker.
This feature is called Docker Swarm Mode and you can find some inital documentation about it &lt;a href=&#34;https://docs.docker.com/engine/swarm/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I could not find any specifics on how to use it together with Docker Machine. So there might be better ways of how to deal with it than what I am going to show you now.&lt;/p&gt;

&lt;p&gt;Assuming we have three fresh hosts that are managed by Docker Machine, we need to tell Docker to initialize a new Swarm cluster first.&lt;/p&gt;

&lt;p&gt;We can execute the necessary command on any of our hosts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi1)
$ docker swarm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command create a Docker Swarm cluster with one node. This first node automatically becomes a Swarm Manager Node.&lt;/p&gt;

&lt;p&gt;The output of &amp;lsquo;docker info&amp;rsquo; shows us what role our current Docker Engine plays in regard to Swarm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker info
...
Swarm: active
 NodeID: efyap0lxrttld19djs3ygtuac
 IsManager: Yes
 Managers: 1
 Nodes: 1
 CACertHash: sha256:9a29dafb3f6f600b64e8ec7a421fd6386f938de623a3a479ca56229b22a6b680
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also another command that is able to show us which nodes are part of our Swarm cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker node ls
ID                           NAME  MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS
efyap0lxrttld19djs3ygtuac *  pi1   Accepted    Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK. Time to add two more nodes.&lt;/p&gt;

&lt;p&gt;First we need to switch our Docker environment with Docker Machine. Afterwards we join the existing Swarm cluster with the next node.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi2)
$ docker swarm join pi1:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks promising. Let&amp;rsquo;s see what our &amp;lsquo;docker node ls&amp;rsquo; command has to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker node ls
Error response from daemon: this node is not participating as a Swarm manager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s that?&lt;/p&gt;

&lt;p&gt;Obviously we are only able to use the &amp;lsquo;node&amp;rsquo; subcommand from a Swarm Manager node and not from a Swarm Worker node.
So ignoring this for the moment let&amp;rsquo;s add the last node, too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi3)
$ docker swarm join pi1:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s switch back to our original Swarm Manager node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi1)
$ docker node ls
ID                           NAME  MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS
3cgg9qfo6nk77zisgrst1333n    pi2   Accepted    Ready   Active
6lezwd8vplgcdmxyhswbc1cvp    pi3   Accepted    Ready   Active
efyap0lxrttld19djs3ygtuac *  pi1   Accepted    Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we have sucessfully set up a Docker Swarm Cluster with three nodes.&lt;/p&gt;

&lt;p&gt;With the help of Docker Machine this was really easy and straightforward as we only had to switch our Docker environment to work on individual nodes.&lt;/p&gt;

&lt;p&gt;So as a last treat for you and to be able to show another screenshot let&amp;rsquo;s start a small webserver in our Swarm cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker service create --name hypriot-httpd -p 8080:80 --replicas 6 hypriot/rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command creates a Docker Swarm service that consists of six running httpd containers that are spread equally across the three nodes of our Swarm cluster.&lt;/p&gt;

&lt;p&gt;Seeing is believing so let&amp;rsquo;s check this again by using the &amp;lsquo;docker service task&amp;rsquo; sub sub command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker service tasks hypriot-httpd
ID                         NAME             SERVICE        IMAGE                      LAST STATE         DESIRED STATE  NODE
14ywlwfix019b95oizce0hgd2  hypriot-httpd.1  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi1
60k55m336zq04rke696m848w1  hypriot-httpd.2  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi3
55sl8zwi1v8om3pvtb0zscf8d  hypriot-httpd.3  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi2
105gbhovh5p3zmwpqaeg3hprd  hypriot-httpd.4  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi3
8her9l13z78g9mjdrkovs9d46  hypriot-httpd.5  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi2
5xwwxuvbwsr7pmomg91cnf08y  hypriot-httpd.6  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On a Mac we now can open the website that is served by this service with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ open http://$(docker-machine ip pi1):8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are then rewarded with this neat little website:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/docker-machine/hypriot-http.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hope this tour was fun and gave you a feeling for the power that comes with Docker Machine.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>More Microservices Bliss with Docker 1.12 and Swarm only</title>
      <link>https://blog.hypriot.com/post/more-microservice-bliss-with-docker-1-12/</link>
      <pubDate>Mon, 20 Jun 2016 21:49:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/more-microservice-bliss-with-docker-1-12/</guid>
      <description>&lt;p&gt;A couple of days ago I wrote a &lt;a href=&#34;https://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/&#34;&gt;blog post&lt;/a&gt; about how easy it is to get a microservice application up and running with Docker and a HTTP proxy called Traefik.
I explained how awesome Traefik is because it makes complex setups with HAProxy, Registrator, Consul, etc. a thing of the past.&lt;/p&gt;

&lt;p&gt;I really thought it couldn&amp;rsquo;t get much easier. Oh boy - was I wrong!&lt;/p&gt;

&lt;p&gt;Today as part of the Docker opening keynote Docker demostrated an evolution of Docker Swarm that simplifies this whole scenario even more.
It makes setting up a Docker Swarm Cluster a really simple and straigtforward task.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how this new thing works&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/more-microservices/swarm.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/thewakingdragon/&#34;&gt;Brent M&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;If you remember the example from my last post - it consisted of a microservice application made of a frontend and a couple of backend services.
The frontend was a Traefik HTTP proxy that routed the requests to the backend services.
And the backend for the sake of simplicity was just a simple Go-based HTTP webserver that returned the ID of the containers it was running within.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/traefik/microsservice_example_end.jpg&#34; alt=&#34;Traffic&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The new Docker Swarm removes the need for a separate HTTP proxy in front of our application containers.
The architecture from above is now slimmed down considerably and looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/more-microservices/architecture_with_swarm.jpg&#34; alt=&#34;With Swarm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Less moving parts - that is great!&lt;/p&gt;

&lt;p&gt;Still we get built-in loadbalancing to our backend services. We even can access those services from every node in our cluster.
Docker Swarm has a kind of built-in mesh routing integrated that takes care of routing requests to the appropriate backend containers.&lt;/p&gt;

&lt;p&gt;With all the new functionality one could assume that setting up a Docker Swarm cluster got even more complicated than before.
But to the contrary - it got much easier - and that by leaps and bounds.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t believe me? Just follow along.&lt;/p&gt;

&lt;p&gt;As you might have guessed, we are doing this on Raspberry Pi cluster again.
I am using a homegrown version of Docker 1.12 that I installed on my Raspberry Pi.
Hopefully when Docker 1.12 is not a release candidate anymore we will have a version for you ready, too.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what we have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker version
Client:
 Version:      1.12.0-rc1
 API version:  1.24
 Go version:   go1.6.2
 Git commit:   1f136c1-unsupported
 Built:        Wed Jun 15 15:35:51 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.0-rc1
 API version:  1.24
 Go version:   go1.6.2
 Git commit:   1f136c1-unsupported
 Built:        Wed Jun 15 15:35:51 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great. Docker 1.12 RC1 is ready. We should have everything we need to get started.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find out if we have same new features hidden in our Docker CLI.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker
Usage: docker [OPTIONS] COMMAND [arg...]
       docker [ --help | -v | --version ]

A self-sufficient runtime for containers.
    ...
    service   Manage Docker services
    ...
    stats     Display a live stream of container(s) resource usage statistics
    ...
    swarm     Manage Docker Swarm
    ...
    update    Update configuration of one or more containers

Run &#39;docker COMMAND --help&#39; for more information on a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I removed the lines of the command output that have not changed compared to the previous release. What remains though is still pretty interesting&amp;hellip;&lt;/p&gt;

&lt;p&gt;We now seem to have a &amp;lsquo;docker swarm&amp;rsquo; command.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what it is all about&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker swarm

Usage:  docker swarm COMMAND

Manage Docker Swarm

Options:
      --help   Print usage

Commands:
  init        Initialize a Swarm.
  join        Join a Swarm as a node and/or manager.
  update      update the Swarm.
  leave       Leave a Swarm.
  inspect     Inspect the Swarm

Run &#39;docker swarm COMMAND --help&#39; for more information on a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &amp;lsquo;Initialize a Swarm.&amp;rsquo; seems to be exactly what we want. Let&amp;rsquo;s start with this one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker swarm init
Swarm initialized: current node (1njlvzi9rk2syv3xojw217o0g) is now a manager.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have a Swarm manger node running it is time to add some more nodes to the cluster.&lt;br /&gt;
And it is really simple as well.&lt;/p&gt;

&lt;p&gt;Just go to another node of your cluster and execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 $ docker swarm join pi6:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this command we basically just tell new nodes that they should join the Swarm Manager node on which we created the inital Swarm cluster.
In the background Docker Swarm now does some work for us.&lt;/p&gt;

&lt;p&gt;For instance it sets up encrypted communication channels between the cluster nodes. We do not need to manage TLS certificates on our own.&lt;/p&gt;

&lt;p&gt;Everybody who knows how involved it could be to get a Docker Swarm cluster up running in the past should realize how easy it is now.&lt;/p&gt;

&lt;p&gt;Still we are not yet finished.&lt;/p&gt;

&lt;p&gt;A &amp;lsquo;docker info&amp;rsquo; on our Swarm Manager node reveals some interesting tidbits.
Again I removed the uninteresting parts for brevity.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker info
...
Swarm: active
 NodeID: 1njlvzi9rk2syv3xojw217o0g
 IsManager: Yes
 Managers: 1
 Nodes: 2
 CACertHash: sha256:de4e2bff3b63700aad01df97bbe0397f131aabed5fabb7732283f044472323fc
...
Kernel Version: 4.4.10-hypriotos-v7+
Operating System: Raspbian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 4
Total Memory: 925.4 MiB
Name: pi6
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we now have a new &amp;lsquo;Swarm&amp;rsquo; part in the &amp;lsquo;docker info&amp;rsquo; output.
It tells us that our current node is a Swarm Manager node and that the cluster is composed of two cluster nodes in total.&lt;/p&gt;

&lt;p&gt;On our second node it looks a bit different as it is not a Manager node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Swarm: active
 NodeID: 3fmwt4taurwxczr2icboojz8g
 IsManager: No
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Until now we just have an interesting, but still very empty Swarm cluster.
Let&amp;rsquo;s change that.&lt;/p&gt;

&lt;p&gt;Before we start let me introduce you to the concept of a service that is also new abstraction with Docker 1.12.
You might have seen a hint of it already in the output of the Docker command above.
Yes, it is the &amp;lsquo;docker service&amp;rsquo; command that I am talking about.
A Docker service is basically just a bit of software running in a container that offers its &amp;lsquo;service&amp;rsquo; to the outside world and runs on a Swarm cluster.&lt;/p&gt;

&lt;p&gt;Such a service can consist of just one container or of multiple containers.
In the latter case we get high availability and/or loadbalancing for our service out of the box.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create such a service based on our &amp;lsquo;whoami&amp;rsquo; image from my last blog post.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service create --name whoami -p 80:8000 hypriot/rpi-whoami
buy0q65lw7nshm76kvy5imxk3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of the &amp;lsquo;docker swarm ls&amp;rsquo; command we can check the status of our new service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service ls
ID            NAME    SCALE  IMAGE               COMMAND
buy0q65lw7ns  whoami  1      hypriot/rpi-whoami
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check if we can request the index page from our whoami container by sending I http request via curl to the ip of eth0 network interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ curl http://192.168.178.24
I&#39;m 1b6df814c654
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is working. Awesome!&lt;/p&gt;

&lt;p&gt;Those who followed along with keen eyes will have noticed the &amp;lsquo;SCALE&amp;rsquo; part in the header line of the &amp;lsquo;docker swarm ls&amp;rsquo; command.
It seems as we can scale our service somehow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service scale whoami=5
whoami scaled to 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK. Let&amp;rsquo;s check what we have now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service ls
ID            NAME    SCALE  IMAGE               COMMAND
buy0q65lw7ns  whoami  5      hypriot/rpi-whoami

root@pi6 $ for i in {1..5}; do curl http://192.168.178.24; done
I&#39;m 8db1657e8517
I&#39;m e1863a2be88d
I&#39;m 1b6df814c654
I&#39;m 8db1657e8517
I&#39;m e1863a2be88d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty neat.&lt;/p&gt;

&lt;p&gt;But this is not just way more simple than the old Swarm, it also feels much more snappier and faster when executing commands.
And remember I am working on Raspberry Pi&amp;rsquo;s and not on a beefy server like you would propably work on.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how this looks from the perspective of an individual Docker engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
e1863a2be88d        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             2 minutes ago       Up 2 minutes        8000/tcp            whoami.4.0lg12zndbal72exqe08r9wvpg
8db1657e8517        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             2 minutes ago       Up 2 minutes        8000/tcp            whoami.5.5z6mvsrdy73m5w24icgsqc8i2
1b6df814c654        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.1.bg4qlpiye6h6uxyf8cmkwuh52
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see from the five containers that were started three reside on &amp;lsquo;pi6&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find the rest:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
db411a119c0a        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             6 minutes ago       Up 6 minutes        8000/tcp            whoami.2.2tf7yhmx9haol7e2b7xib2emj
0a4bf32fa9c4        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             6 minutes ago       Up 6 minutes        8000/tcp            whoami.3.2r6mm091c2ybr0f9jz4qaxw9k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what happens when I just leave the Swarm cluster on &amp;lsquo;pi1&amp;rsquo;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 docker swarm leave
Node left the default swarm.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I should be two containers short, right?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what we have on our remaining node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
58620e3d533c        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             46 seconds ago      Up 43 seconds       8000/tcp            whoami.2.cgc4e2ixulc2f3ehr4laoursg
acc9b523f434        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             46 seconds ago      Up 43 seconds       8000/tcp            whoami.3.67bhlo3nwgehthi3bg5bfdzue
e1863a2be88d        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.4.0lg12zndbal72exqe08r9wvpg
8db1657e8517        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.5.5z6mvsrdy73m5w24icgsqc8i2
1b6df814c654        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             15 minutes ago      Up 14 minutes       8000/tcp            whoami.1.bg4qlpiye6h6uxyf8cmkwuh52
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we witnessed here is the same what would have happened if we just had a failing &amp;lsquo;pi1&amp;rsquo; node.
All the containers that were running on node &amp;lsquo;pi1&amp;rsquo; were migrated to the remaining cluster nodes automatically.
That&amp;rsquo;s pretty impressive.&lt;/p&gt;

&lt;p&gt;So to recap what we just did:&lt;br /&gt;
We created a small dynamic microservice applications with just the plain Docker.
Docker Swarm is now integrated into the Docker-Engine instead of being a separate piece of software.
In many cases this makes a separate proxy for the backend services of your application obsolete. No more nginx, HAProxy or Traefik. Sorry to see you go&amp;hellip;&lt;/p&gt;

&lt;p&gt;Despite having fewer moving parts we now have additional load balancing and high availability features built-in.
I am really looking forward to find out what else there is in store with the new Docker Swarm and how it works together with Docker Compose.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s a story for another day&amp;hellip;&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>