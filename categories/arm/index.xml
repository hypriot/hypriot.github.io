<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arm on Docker Pirates ARMed with explosive stuff</title>
    <link>http://blog.hypriot.com/categories/arm/</link>
    <description>Recent content in Arm on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Apr 2015 06:35:55 +0200</lastBuildDate>
    <atom:link href="http://blog.hypriot.com/categories/arm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Connecting Kitematic to an external Docker Engine running on a Raspberry Pi</title>
      <link>http://blog.hypriot.com/post/connect-kitematic-to-external-docker-engine/</link>
      <pubDate>Wed, 15 Apr 2015 06:35:55 +0200</pubDate>
      
      <guid>http://blog.hypriot.com/post/connect-kitematic-to-external-docker-engine/</guid>
      <description>

&lt;p&gt;In this post we show you the first steps how easy it is using Kitematic to control a Docker engine running on a Raspberry Pi. Finally we demostrate in a small screencast how to run an unbelievable amount of 101 web servers on a single Raspberry Pi 2.&lt;/p&gt;

&lt;h3 id=&#34;intro-and-background:90fd682791be4b8b148459904d1205f8&#34;&gt;Intro and Background&lt;/h3&gt;

&lt;p&gt;At Hypriot we recently built and released our own OS image to run the Docker Engine on a low-cost Raspberry Pi and labeled it HypriotOS.  A user can download this pre-compiled Raspbian based SD card image, which includes a Linux 3.18.10 kernel with all Docker related kernel options included, and Docker 1.5.0 is already enabled with Overlay filesystem.  Just download, extract, flash to a SD card and boot your Raspberry Pi - and within minutes you have Docker up and running and you can instantly start using it.&lt;/p&gt;

&lt;p&gt;You can read more details and find the download links in our blog post &lt;a href=&#34;http://blog.hypriot.com/heavily-armed-after-major-upgrade-raspberry-pi-with-docker-1-dot-5-0&#34;&gt;Heavily ARMed after major upgrade: Raspberry Pi with Docker 1.5.0&lt;/a&gt; and recently updated post &lt;a href=&#34;http://blog.hypriot.com/post/hypriotos-back-again-with-docker-on-arm/&#34;&gt;HypriotOS: Back Again and Better then Ever&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As developers and geeks, we&amp;rsquo;re really comfortable using SSH and a bash shell to control the Docker CLI.  It&amp;rsquo;s also not a problem to connect a Linux or Mac OSX host via a native Docker CLI over the network, even a Windows client works well.  But what about the normal end users?  Wouldn&amp;rsquo;t it be great to have a more convinient way to use a graphical frontend via web or a specific app.  A GUI would be really cool, but this would take a long time to develop.&lt;/p&gt;

&lt;h3 id=&#34;kitematic-to-the-rescue:90fd682791be4b8b148459904d1205f8&#34;&gt;Kitematic to the Rescue&lt;/h3&gt;

&lt;p&gt;Even the fact that our OS image works pretty much out of the box, and everybody can use Docker within minutes we&amp;rsquo;ve received a lot of feedback, whether we could build and deliver a graphical application to control Docker and deploying apps/containers with it.  And here comes Kitematic to the rescue - what a great timing.  We&amp;rsquo;ve just read the announcement on the Docker blog and were extremely impressed but also a little bit frustrated, it&amp;rsquo;s only meant to be used on a Mac running it&amp;rsquo;s own Boot2Docker VM through a newly created Docker Machine.&lt;/p&gt;

&lt;p&gt;We were fascinated immediately about the simplicity and the seamless GUI, instantly installing Kitematic on a MacBookPro and it was running within 10 minutes only.  Really impressed and hooked!  Another 15 minutes later, we had cloned the source code repo from GitHub, then a &amp;ldquo;npm install&amp;rdquo; and a &amp;ldquo;npm start&amp;rdquo; and WOW, we&amp;rsquo;re running our personal dev version!  And we even were able to create our own Mac App with a &amp;ldquo;npm run release&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Imagine now what could be even better for an end user?  What if we could use Kitematic to control a remote Docker Host running on that cute little Raspberry Pi.&lt;/p&gt;

&lt;h3 id=&#34;connecting-the-dots:90fd682791be4b8b148459904d1205f8&#34;&gt;Connecting the Dots&lt;/h3&gt;

&lt;p&gt;We quickly read through the docs and studied the source code and found out that Kitematic is based upon Docker Machine to control the backend Docker Host, hey cool - that&amp;rsquo;s the key.  Within a couple of hours we had the first rough hack and were able to actively control a Raspberry Pi 2 running Docker 1.5.0 with a brand new graphical user interface.  Just selecting one of our favorite Docker Images from the Docker Hub and pushed it seamlessly to a RPi!&lt;br /&gt;
&lt;img src=&#34;http://blog.hypriot.com/images/kitematic/rpi-docker-images-at-the-hub.png&#34; alt=&#34;image1&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;But until now, it was just a hack and far away from being used in production or by end users.  All settings were done with some source code changes within Kitematic itself.&lt;/p&gt;

&lt;p&gt;Here are the details of that quick hack.  You only have to change these three lines in &lt;code&gt;src/Docker.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;16:      protocol: &#39;http&#39;,
17:      host: 192.168.2.114,
18:      port: 2375,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just use an unencrypted connection for the first step, change the protocol from &lt;code&gt;https&lt;/code&gt; to &lt;code&gt;http&lt;/code&gt;, use the IP address of the Raspberry Pi, and don&amp;rsquo;t forget to change the port number to &lt;code&gt;2375&lt;/code&gt;.  With the last change, Kitematic don&amp;rsquo;t use any cert or key file to connect to the remote Docker Host.&lt;/p&gt;

&lt;p&gt;For the next day we scheduled a short online meeting with Mike from Kitematic, and to our surprise the whole team joined us, including Jeff and Sean.  Everybody was so happy and surprised how easy we could merge both ideas and concepts together.  Right now, we&amp;rsquo;re able to offer a Docker optimized OS for the Raspberry Pi which one could install and use within a few minutes only, and within the same amount of time, installing the app from Kitematic to control your Raspberry Pi with a great user experience.&lt;/p&gt;

&lt;h3 id=&#34;switch-to-a-better-system-design:90fd682791be4b8b148459904d1205f8&#34;&gt;Switch to a better System Design&lt;/h3&gt;

&lt;p&gt;Thanks to the fact, that Kitematic uses Docker Machine under the hood to connect to it&amp;rsquo;s Docker VM, it must be able to use this concept for a better system design to communicate with an external Docker Host.  Our first try was just looking for a standard driver available which supports our needs.  We quickly tested the &lt;code&gt;none&lt;/code&gt; driver and were able to control the Raspberry Pi from within Docker Machine.  For this case it was necessary to reconfigure Docker to use a TLS encrypted connection.  But we had absolute no luck to get it work together with Kitematic.&lt;/p&gt;

&lt;p&gt;Ok, let&amp;rsquo;s dig deeper and just use the Docker Machine GitHub repo to get familiar with the driver concept.  And learn what has to be done, to build your own Docker Machine Driver specifically for connecting a Docker Engine running on an external Linux machine.  Within a day only, we got it working, our very first driver implementation for Docker Machine.  Our goal was to keep it super-simple and ready-to-use together with Kitematic, and hopefully don&amp;rsquo;t change anything within the app&amp;rsquo;s source code.&lt;/p&gt;

&lt;p&gt;All changes are already documented in a few pull-requests which are available for further improvement and testing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/kitematic/pull/1&#34;&gt;hypriot/kitematic#1, Connect to externel docker host through docker-machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/machine/pull/1&#34;&gt;hypriot/machine#1, Add driver &amp;lsquo;hypriot&amp;rsquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To use this improved Kitematic version from Hypriot, you have to clone the GitHub repo &lt;a href=&#34;https://github.com/hypriot/kitematic/tree/connect-to-externel-docker-host&#34;&gt;hypriot/kitematic&lt;/a&gt;, use the branch &lt;code&gt;connect-to-externel-docker-host&lt;/code&gt; and build it with &amp;ldquo;npm run install&amp;rdquo;, it will also download and use our specifically built version of Docker Machine with the &lt;code&gt;hypriot&lt;/code&gt; driver included.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/kitematic/Kitematic-and-HypriotOS-just-works.png&#34; alt=&#34;image2&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;mission-accomplished:90fd682791be4b8b148459904d1205f8&#34;&gt;Mission accomplished&lt;/h3&gt;

&lt;p&gt;At the end, we&amp;rsquo;ve now built our own basic Docker Machine driver for the HypriotOS to use it for controlling a Raspberry Pi with the Kitematic app, and we&amp;rsquo;ll improve it over the next few days and weeks to get it production ready.  To our surprise, we only had to change a single line of code within Kitematic itself.&lt;/p&gt;

&lt;p&gt;Here is a short 4 minute screencast to demonstrate the running system as &lt;a href=&#34;https://www.youtube.com/watch?v=yHytb1k3TfM&#34;&gt;Docker Kitematic controls Raspberry Pi 2 running Docker 1.5.0&lt;/a&gt;. Watch out the number of web servers we started simultaneously on the Raspberry Pi 2, all as separate Docker containers. Can you imagine how cool this Linux container technology from Docker is, even on such a small device?&lt;/p&gt;

&lt;p&gt;And the best thing is, it could be used to connect any other external Docker Host to Kitematic, not only the Raspberry Pi.  In the PR we included a short description how to connect an already running Boot2Docker VM to Kitematic.  And if anyone is interested to help, please feel free to join.  As soon as we&amp;rsquo;re done with the development we&amp;rsquo;ll create an upstream PR to get the changes back into Kitematic and Docker Machine.&lt;/p&gt;

&lt;h3 id=&#34;next-steps:90fd682791be4b8b148459904d1205f8&#34;&gt;Next Steps&lt;/h3&gt;

&lt;p&gt;We do have a lot of things on our roadmap, maybe too much to share in this blog post.  Here are at least the next important things we&amp;rsquo;re planing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;new Linux kernel 3.18.10 (DONE)&lt;/li&gt;
&lt;li&gt;support for Open vSwitch (we&amp;rsquo;d love to use SocketPlane on the RPi) (DONE)

&lt;ul&gt;
&lt;li&gt;include kernel options for Open vSwitch (DONE)&lt;/li&gt;
&lt;li&gt;natively compiled packages for Open vSwitch (DONE)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;support for Docker Machine (WIP)

&lt;ul&gt;
&lt;li&gt;production ready driver for HypriotOS and the Raspberry Pi&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;support for Docker Compose (WIP)&lt;/li&gt;
&lt;li&gt;support for Docker Swarm (WIP)&lt;/li&gt;
&lt;li&gt;&amp;hellip; (depending on user feedback)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/kitematic/pi_armed_with_docker.jpg&#34; alt=&#34;image3&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;send-us-your-feedback-please:90fd682791be4b8b148459904d1205f8&#34;&gt;Send us your Feedback, please!&lt;/h3&gt;

&lt;p&gt;We really love feedback and would like to get some new ideas and thoughts from all of you.  So, if you&amp;rsquo;re liking our ideas and the way to find and break the limits, please send us your comments via email, twitter or drop us a line.  We&amp;rsquo;d be more than happy to answer and talk directly to share our experiences.&lt;/p&gt;

&lt;h4 id=&#34;note:90fd682791be4b8b148459904d1205f8&#34;&gt;Note&lt;/h4&gt;

&lt;p&gt;This post was originally posted at the &lt;a href=&#34;http://blog.kitematic.com&#34;&gt;Kitematic Blog&lt;/a&gt;, and is slightly updated to recent download links and version numbers.&lt;/p&gt;

&lt;p&gt;&amp;ndash;
Dieter Reuter&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to use Docker Compose to run complex multi container apps on your Raspberry Pi</title>
      <link>http://blog.hypriot.com/post/docker-compose-nodejs-haproxy/</link>
      <pubDate>Mon, 06 Apr 2015 00:18:47 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/docker-compose-nodejs-haproxy/</guid>
      <description>

&lt;p&gt;In this blog post we gonna walk you through the different steps that are necessary to get you started with Docker Compose and show how to use it.&lt;/p&gt;

&lt;p&gt;To demonstrate the benefits of Docker Compose we are going to create a simple Node.js &amp;ldquo;Hello World&amp;rdquo; application which will run on three Docker Node.js containers.
HTTP requests will be distributed to these Node.js nodes by an HAProxy instance running on another Docker container.&lt;/p&gt;

&lt;p&gt;If you haven&amp;rsquo;t heard about Docker Compose its docs have a neat description of what it is all about:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compose is a tool for defining and running complex applications with Docker.
With Compose, you define a multi-container application in a single file,
then spin your application up in a single command which does everything that needs to be done to get it running.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-hello-world-application:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;A Hello-World application&lt;/h2&gt;

&lt;p&gt;We start by creating a simple Hello-World &lt;a href=&#34;https://nodejs.org&#34;&gt;Node.js&lt;/a&gt; web application based on &lt;a href=&#34;http://expressjs.com/&#34;&gt;Express.js&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To keep it simple we are only going to show a &amp;ldquo;Hello World&amp;rdquo; message and the hostname of the container.  This will be useful later on.&lt;/p&gt;

&lt;h3 id=&#34;src-index-js:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;src/index.js&lt;/h3&gt;

&lt;p&gt;First we create a &lt;code&gt;src/index.js&lt;/code&gt; file for the web application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var express = require(&#39;express&#39;);
var os = require(&amp;quot;os&amp;quot;);

var app = express();
var hostname = os.hostname();

app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Hello from Node.js container &#39; + hostname + &#39;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;);
});

app.listen(80);
console.log(&#39;Running on http://localhost&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;src-package-json:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;src/package.json&lt;/h3&gt;

&lt;p&gt;Then we need to create a &lt;code&gt;src/package.json&lt;/code&gt; file with the dependencies we need to build and start the Node.js application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;node-hello-world&amp;quot;,
  &amp;quot;private&amp;quot;: true,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Node.js Hello world app on docker&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;hypriot.com&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;express&amp;quot;: &amp;quot;4.12.0&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that is all that is need to set up this small Hello-World application from the nods.js side of things.&lt;/p&gt;

&lt;h3 id=&#34;dockerfile:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;Dockerfile&lt;/h3&gt;

&lt;p&gt;As we want to run our web application in a Docker container we now need to create a &lt;code&gt;Dockerfile&lt;/code&gt; for that.
The Dockerfile is simple and straightforward.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# use our prepared Raspberry Pi compatible Docker base image with Node.js
FROM hypriot/rpi-node:0.12.0

# make the src folder available in the docker image
ADD src/ /src
WORKDIR /src

# install the dependencies from the package.json file
RUN npm install

# make port 80 available outside of the image
EXPOSE 80

# start node with the index.js file of our hello-world application
CMD [&amp;quot;node&amp;quot;, &amp;quot;index.js&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-one-container:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;Running one container&lt;/h2&gt;

&lt;p&gt;We can now test if our Node.js web server works by building a Docker application image first and then spinning it up as a new container.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker build -t node-hello .

$ docker run -p 80:80 --name web -d node-hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can check if the server is running with the following command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://localhost
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Hello from Node.js container 38f69acbdf13&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we have published the port 80 to the host we also can access our web application from another machine.&lt;/p&gt;

&lt;h3 id=&#34;benchmarking-our-web-application:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;Benchmarking our web application&lt;/h3&gt;

&lt;p&gt;As we are curious guys we want to know how well our Hello-World application performs on a Docker-Raspberry-Pi-Combo.&lt;/p&gt;

&lt;p&gt;So we are going to use &lt;a href=&#34;http://httpd.apache.org/docs/2.2/programs/ab.html&#34;&gt;Apache Bench&lt;/a&gt; to do some benchmarking from another machine in the network.
To install Apache Bench on Debian/Ubuntu use &lt;code&gt;sudo apt-get install apache2-utils&lt;/code&gt;. On Mac OS X &lt;code&gt;ab&lt;/code&gt; usually comes preinstalled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ab -n 10000 -c 10 http://ip-of-your-rpi/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This runs 10.000 HTTP requests with a concurrency of 10. The CPU load while running the benchmark test shows that only one CPU core of the Raspberry Pi 2 is used. The reason is that Node.js is a single threaded process.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/rpi-node-haproxy/htop-1-webserver.png&#34; alt=&#34;htop with 1 webserver&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;And here are the results of the Apache Bench test. As you can see a single web server can handle &lt;strong&gt;338&lt;/strong&gt; Requests per second.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ab -n 10000 -c 10 http://192.168.33.200/
This is ApacheBench, Version 2.3 &amp;lt;$Revision: 655654 $&amp;gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking 192.168.33.200 (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests
Finished 10000 requests


Server Software:
Server Hostname:        192.168.33.200
Server Port:            80

Document Path:          /
Document Length:        67 bytes

Concurrency Level:      10
Time taken for tests:   29.499 seconds
Complete requests:      10000
Failed requests:        0
Write errors:           0
Total transferred:      2480000 bytes
HTML transferred:       670000 bytes
Requests per second:    338.99 [#/sec] (mean)
Time per request:       29.499 [ms] (mean)
Time per request:       2.950 [ms] (mean, across all concurrent requests)
Transfer rate:          82.10 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        1    1   2.0      1      78
Processing:    10   28   5.6     26     108
Waiting:        9   28   5.4     26     106
Total:         13   29   5.8     27     109

Percentage of the requests served within a certain time (ms)
  50%     27
  66%     27
  75%     28
  80%     28
  90%     38
  95%     39
  98%     47
  99%     53
 100%    109 (longest request)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cleaning-up:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;Cleaning up&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s it for our first test drive. We can now stop the web server container.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker stop web
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-multiple-container-with-docker-compose:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;Running multiple container with Docker Compose&lt;/h2&gt;

&lt;p&gt;To run more of these web servers we now use Docker Compose to create a farm of web servers which are running behind a &lt;a href=&#34;http://www.haproxy.org&#34;&gt;HAProxy&lt;/a&gt; load balancer.&lt;/p&gt;

&lt;p&gt;As our mission is to make Docker and its toolset available on ARM we created a &lt;code&gt;docker-compose&lt;/code&gt; binary ready to run on your Raspberry Pi.&lt;/p&gt;

&lt;h3 id=&#34;installation:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;First we have to install Docker Compose for the ARM-based Raspberry Pi from our fork at &lt;a href=&#34;https://github.com/hypriot/compose&#34;&gt;https://github.com/hypriot/compose&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo sh -c &amp;quot;curl -L https://github.com/hypriot/compose/releases/download/1.1.0-raspbian/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose; chmod +x /usr/local/bin/docker-compose&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;docker-compose-yml:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;docker-compose.yml&lt;/h3&gt;

&lt;p&gt;To get our four container configuration set up we first need to create a &lt;code&gt;docker-compose.yml&lt;/code&gt; file.
We will need three containers &lt;code&gt;weba&lt;/code&gt;, &lt;code&gt;webb&lt;/code&gt; and &lt;code&gt;webc&lt;/code&gt; based on our web application image and one &lt;code&gt;haproxy&lt;/code&gt; container.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;weba:
  build: .
  expose:
    - 80

webb:
  build: .
  expose:
    - 80

webc:
  build: .
  expose:
    - 80

haproxy:
  image: hypriot/rpi-haproxy
  volumes:
   - haproxy:/haproxy-override
  links:
   - weba
   - webb
   - webc
  ports:
   - &amp;quot;80:80&amp;quot;
   - &amp;quot;70:70&amp;quot;

  expose:
   - &amp;quot;80&amp;quot;
   - &amp;quot;70&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the three web application containers exposes port 80.
Additionally the HAProxy container will have (network) links to each of the three web application containers.
Furthermore the HAProxy container will exposes port 80 as a central entry point to our Hello-World application webserver farm and its admin interface on port 70.&lt;/p&gt;

&lt;h3 id=&#34;haproxy-haproxy-cfg:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;haproxy/haproxy.cfg&lt;/h3&gt;

&lt;p&gt;HAProxy needs a configuration file that is mapped into the container. Create a file &lt;code&gt;haproxy/haproxy.cfg&lt;/code&gt; with the following content.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
  log 127.0.0.1 local0
  log 127.0.0.1 local1 notice

defaults
  log global
  mode http
  option httplog
  option dontlognull
  timeout connect 5000
  timeout client 10000
  timeout server 10000

listen stats :70
  stats enable
  stats uri /

frontend balancer
  bind 0.0.0.0:80
  mode http
  default_backend aj_backends

backend aj_backends
  mode http
  option forwardfor
  # http-request set-header X-Forwarded-Port %[dst_port]
  balance roundrobin
  server weba weba:80 check
  server webb webb:80 check
  server webc webc:80 check
  # option httpchk OPTIONS * HTTP/1.1\r\nHost:\ localhost
  option httpchk GET /
  http-check expect status 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HAProxy does a health check for each of our three web servers.&lt;/p&gt;

&lt;h3 id=&#34;running-our-webserver-farm:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;Running our webserver farm&lt;/h3&gt;

&lt;p&gt;Now that we have set up all the necessary parts it is time to spin up all our Docker containers at once. Just run the command &lt;code&gt;docker-compose up&lt;/code&gt; interactively to see what is happening or use option &lt;code&gt;-d&lt;/code&gt; to start all containers in the background.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose up -d
Recreating rpinodehaproxyexample_webb_1...
Recreating rpinodehaproxyexample_webc_1...
Recreating rpinodehaproxyexample_weba_1...
Recreating rpinodehaproxyexample_haproxy_1...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will spin up all of our three web application servers and one HAProxy instance. Only the HAProxy container can be reached from the outside and each request will be load balanced by HAProxy to one of our web servers.&lt;/p&gt;

&lt;p&gt;You can watch the logs of all our containers by running the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose logs
Attaching to rpinodehaproxyexample_haproxy_1, rpinodehaproxyexample_weba_1, rpinodehaproxyexample_webc_1, rpinodehaproxyexample_webb_1
weba_1    | Running on http://localhost
webc_1    | Running on http://localhost
webb_1    | Running on http://localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can use &lt;code&gt;curl&lt;/code&gt; again to test our Hello-World application farm as whole.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# on your Rasberry Pi
$ curl http://localhost
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Hello from Node.js container fa05496d9ce7&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;~
$ curl http://localhost
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Hello from Node.js container 1167459cdacc&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;~
$ curl http://localhost
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Hello from Node.js container 660840416a84&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;~
$ curl http://localhost
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Hello from Node.js container fa05496d9ce7&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the container name is different for each &lt;code&gt;curl&lt;/code&gt; request.
And the fourth request has the same container name as the first one.
The HAProxy container forwards each request in a round robin fashion, so each web server gets only one third of the load.&lt;/p&gt;

&lt;h3 id=&#34;benchmarking-our-web-application-farm:63a2807194fcdb5e829ff92f8506efa0&#34;&gt;Benchmarking our web application farm&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s see how our web server farm fares compared to our single web application container instance from our first benchmark.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ab -n 10000 -c 30 http://ip-or-your-rpi/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we run 10.000 HTTP requests with a concurrency of 30. The CPU load while running the benchmark test now shows that all four CPU cores of the Raspberry Pi 2 are used.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/rpi-node-haproxy/htop-3-webserver-haproxy.png&#34; alt=&#34;htop with 3 webserver and haproxy&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;And here are the results of the benchmark test itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ab -n 10000 -c 30 http://192.168.33.200/
This is ApacheBench, Version 2.3 &amp;lt;$Revision: 655654 $&amp;gt;
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking 192.168.33.200 (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests
Finished 10000 requests


Server Software:
Server Hostname:        192.168.33.200
Server Port:            80

Document Path:          /
Document Length:        67 bytes

Concurrency Level:      30
Time taken for tests:   23.353 seconds
Complete requests:      10000
Failed requests:        0
Write errors:           0
Total transferred:      2480000 bytes
HTML transferred:       670000 bytes
Requests per second:    428.22 [#/sec] (mean)
Time per request:       70.058 [ms] (mean)
Time per request:       2.335 [ms] (mean, across all concurrent requests)
Transfer rate:          103.71 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        1    2   1.4      2      15
Processing:     5   68  59.5     51     259
Waiting:        4   67  59.3     51     259
Total:          5   70  59.5     54     260

Percentage of the requests served within a certain time (ms)
  50%     54
  66%     77
  75%     94
  80%    108
  90%    163
  95%    210
  98%    231
  99%    234
 100%    260 (longest request)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the cluster can handle &lt;strong&gt;428&lt;/strong&gt; Requests per second. Strangely enough we do not get three times the requests per second that we might have expected.
Right now we are not really sure what the reason for this behaviour is. This may or may not be due to the fact that the NIC of the Raspberry Pi is sharing its IO bandwidth via the USB2 port.&lt;/p&gt;

&lt;p&gt;Stopping our little webfarm is also easily done with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose stop
Killing rpinodehaproxyexample_haproxy_1...
Killing rpinodehaproxyexample_weba_1...
Killing rpinodehaproxyexample_webc_1...
Killing rpinodehaproxyexample_webb_1...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to learn more about Docker Compose, just head over to the official documentation at &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;https://docs.docker.com/compose/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find the code of this example on GitHub at &lt;a href=&#34;https://github.com/hypriot/rpi-node-haproxy-example&#34;&gt;https://github.com/hypriot/rpi-node-haproxy-example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We hope you enjoyed this little tour of Docker Compose!&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on our &lt;a href=&#34;https://news.ycombinator.com/item?id=9329890&#34;&gt;HackerNews-Thread&lt;/a&gt;, Twitter or Facebook.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>