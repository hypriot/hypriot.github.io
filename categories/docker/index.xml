<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Docker Pirates ARMed with explosive stuff</title>
    <link>https://blog.hypriot.com/categories/docker/index.xml</link>
    <description>Recent content in Docker on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://blog.hypriot.com/categories/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>We now accept donations. Buy us a beer!</title>
      <link>https://blog.hypriot.com/post/donation-liberapay-support-contribute/</link>
      <pubDate>Tue, 29 May 2018 16:30:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/donation-liberapay-support-contribute/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Many of our users have asked for it for quite a long time. Now, we finally took the time to setup a donation option.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since we startet Hypriot in 2015, we received great attention from a growing community around Docker on ARMed devices. We received numerous &amp;ldquo;kudos&amp;rdquo; and nice words. Even though we greatly appreciate this until today, words do not enable us to pay our infrastructure bills. Now you have the option to support us materialistically.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/donations/liberapay-hypriot.png&#34; alt=&#34;Donations Screenshot Liberpay&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;what-we-do-with-your-donation&#34;&gt;What we do with your donation&lt;/h2&gt;

&lt;p&gt;Open source software might seem to be &amp;ldquo;free&amp;rdquo; (as in free beer) at first sight - that&amp;rsquo;s a fallacy. Its development, testing and deployment requires a huuuge amount of scarce time, ARMed hardware for testing, costs for service providers that help us throughout the software lifecycle, and costs for software licenses.&lt;/p&gt;

&lt;p&gt;Today, everything at Hypriot we do in our leasure time and pay for related bills with our private wallet. It would be great if we could at least cover our basic costs for infrastructure. Many parts of our infrastructure are free of charge for us because many service providers for e.g. build pipelines or Github support open source projects (our software is 100% open source). However, some providers do not offer free subscriptions for open source projects. We&amp;rsquo;ll use your donation to cover the bills from them.&lt;/p&gt;

&lt;p&gt;If the infrastructure costs are completely funded, we&amp;rsquo;ll use the surplus to enjoy a good beer during our hacking sessions :-)&lt;/p&gt;

&lt;h2 id=&#34;why-liberapay&#34;&gt;Why Liberapay?&lt;/h2&gt;

&lt;p&gt;Liberapay is a relativley new and trendy donation platform for free software projects. The unique thing about ths platform: &lt;strong&gt;it pays its bills for development by receiving donations on its own platform&lt;/strong&gt;! As transaction fees for payments this platform only invoices for the fees they are charged by their financial provider. In addition, Liberapay is fully open source and based within the European Union. Using software stemming from within the EU got more important with the advent of the new data protection regulation.&lt;/p&gt;

&lt;p&gt;Thus Liberapay offers several advantages over other popular platforms like Patreon (closed source, high transaction fees, not EU based).&lt;/p&gt;

&lt;h2 id=&#34;buy-us-at-least-a-little-beer&#34;&gt;Buy us at least a little beer!&lt;/h2&gt;

&lt;p&gt;If many of our community only provide little portions, the sum can be high. So please click on the following button, create an account and charge the account with some euros or dollars. Finally, specify a little amount you&amp;rsquo;d like to donate to us.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://liberapay.com/Hypriot/donate&#34;&gt;&lt;img alt=&#34;Donate using Liberapay&#34; src=&#34;https://liberapay.com/assets/widgets/donate.svg&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thank you very much in advance!&lt;/p&gt;

&lt;p&gt;@MathiasRenner at &lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;Twitter&lt;/a&gt; or &lt;a href=&#34;https://mastodon.social/@mathiasrenner&#34;&gt;Mastodon&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Releasing HypriotOS 1.8.0: Raspberry Pi 3 B&#43;, Stretch and more</title>
      <link>https://blog.hypriot.com/post/releasing-HypriotOS-1-8/</link>
      <pubDate>Tue, 27 Mar 2018 16:30:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/releasing-HypriotOS-1-8/</guid>
      <description>&lt;p&gt;&lt;strong&gt;We&amp;rsquo;re proud to announce our 1.8.0 release of HypriotOS - the fasted way to get Docker up and running on any Raspberry Pi including the new Pi 3 B+.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At this years Pi day the Raspberry Pi foundation &lt;a href=&#34;https://www.raspberrypi.org/blog/raspberry-pi-3-model-bplus-sale-now-35/&#34;&gt;has announced a new model&lt;/a&gt; - the Raspberry Pi 3 B+ with improved networking and a faster CPU. A good reason for us to update our HypriotOS to support this new device. And while we were at it we also updated the OS to Raspbian Stretch and Linux Kernel version 4.9.80 - and of course the latest Docker 18.03.0-ce release.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/release-1-8/pi3-b-plus.jpg&#34; alt=&#34;Raspberry Pi 3 B+&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;features-of-hypriotos&#34;&gt;Features of HypriotOS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Latest Docker Engine 18.03.0-ce with Swarm Mode&lt;/strong&gt; &lt;/br&gt;
You can use the latest features of the freshly-baked Engine Docker 18.03.0-ce that is still warm. It includes the Swarm Mode, which allows high availability of services in a multi-node cluster within just a few simple commands.
&lt;a href=&#34;https://blog.docker.com/2016/07/swarm-mode-on-a-raspberry-pi-cluster/&#34;&gt;See this short video how it works.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Up to date with Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS with an up-to-date OS and Linux kernel which is in sync with Raspbian Lite. We have updated to Raspbian Stretch and also prepared a new Docker optimized kernel 4.9.80.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Support for the complete Raspberry Pi family&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS on every model of the Raspberry Pi family - we&amp;rsquo;re supporting Pi 1, 2, 3, the 3 B+, Zero and even the Compute Module.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Easy flashing and configuration&lt;/strong&gt; &lt;/br&gt;
We improved our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;, which puts HypriotOS onto a SD card that is ready to boot from with a single command. With additional command line options you can customize HypriotOS during the flash operation to have the best out-of-the-box first-boot experience.
HypriotOS includes &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/&#34;&gt;cloud-init&lt;/a&gt;, which makes the first boot of your Raspberry Pi customizable and you even are able connecting it to your Wi-Fi network during boot.
After booting, you can find the Raspberry Pi at your network with a simple &lt;code&gt;ping black-pearl.local&lt;/code&gt; – no more searching for IP addresses required thanks to the integrated Avahi service discovery.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enhanced security out of the box&lt;/strong&gt; &lt;/br&gt;
We think that security should be shipped out-of-the-box. We make HypriotOS more secure without you even noticing it. For instance, there is no built-in &amp;ldquo;root&amp;rdquo; user. Also, the default user &amp;ldquo;pirate&amp;rdquo; (password &amp;ldquo;hypriot&amp;rdquo;) is can be customized or removed before the first boot. Just look at the file &lt;code&gt;/boot/user-data&lt;/code&gt;. You can add your public SSH key, disable password logins and specify a different user account before you even boot your Raspberry Pi. WiFi can be customized and enabled to have Docker up and running through the air without attaching a keyboard and monitor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Smaller than Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
Even though HypriotOS 1.8.0 is fully packed with the complete and latest Docker tool set, it now comes at a size smaller than the tiniest version of Raspbian (&amp;ldquo;Raspbian Lite&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Please see all details in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases/tag/v1.8.0&#34;&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick start&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Download our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O https://raw.githubusercontent.com/hypriot/flash/2.0.0/flash
chmod +x flash
sudo mv flash /usr/local/bin/flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Now run this command to flash HypriotOS 1.8.0&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash https://github.com/hypriot/image-builder-rpi/releases/download/v1.8.0/hypriotos-rpi-v1.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Afterwards, put the SD card into the Raspberry Pi and power it. That&amp;rsquo;s all to get HypriotOS up and running!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;If you want to connect to the Raspberry Pi, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with password &amp;ldquo;hypriot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you want the Raspberry Pi to connect directly to your Wi-Fi after boot, change the hostname of the Raspberry Pi and more, edit &lt;code&gt;/boot/user-data&lt;/code&gt; of the SD card and have a look at &lt;a href=&#34;https://blog.hypriot.com/faq/#wifi&#34;&gt;our FAQ&lt;/a&gt;. Alternatively, checkout the parameters of the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt; that also allows you to define your own cloud-init user-data template file which will be copied onto the SD image for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n myHOSTNAME -u wifi.yml https://github.com/hypriot/image-builder-rpi/releases/download/v1.8.0/hypriotos-rpi-v1.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will improve the flash tool to bring back support of the &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options so you can add WiFi support without creating your own user-data template file.&lt;/p&gt;

&lt;h2 id=&#34;hands-free-projects&#34;&gt;Hands-free projects&lt;/h2&gt;

&lt;p&gt;We have put together a small sample YAML that shows what you can do with HypriotOS, cloud-init and Docker. You can prepare a wireless Raspberry Pi with an SD card image that creates a Docker Swarm and starts a service to drive some LED&amp;rsquo;s automatically. You don&amp;rsquo;t have to login to this device. It will also start the service again after a power outage.&lt;/p&gt;

&lt;p&gt;The sample &lt;a href=&#34;https://github.com/hypriot/flash/blob/master/sample/rainbow.yml&#34;&gt;rainbow.yml&lt;/a&gt; shows how to setup a user with SSH public key authentication, activate WiFi and run a rainbow service.
You only have to customize the YAML file at&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;line 16: insert your SSH public key for authentication&lt;/li&gt;
&lt;li&gt;line 32 and 33: insert your WiFi settings&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then flash an SD image with this command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -u rainbow.yml https://github.com/hypriot/image-builder-rpi/releases/download/v1.8.0/hypriotos-rpi-v1.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And after booting a Raspberry Pi Zero or Pi 3/Pi 3 B+ you will see some blinking LED&amp;rsquo;s once everything has been set up after the first boot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/release-1-8/rainbow.jpg&#34; alt=&#34;Raspberry Pi 3 B+ with rainbow service&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h2&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Bootstrapping a Cloud with Cloud-Init and HypriotOS</title>
      <link>https://blog.hypriot.com/post/cloud-init-cloud-on-hypriot-x64/</link>
      <pubDate>Sun, 29 Oct 2017 00:14:00 -0700</pubDate>
      
      <guid>https://blog.hypriot.com/post/cloud-init-cloud-on-hypriot-x64/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Things may come to those who wait, but only the things left by those who hustle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Over the last year, a lot has happened in the Raspberry Pi and Docker communities, there are Docker Captains helping lead the charge, one of those, &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;Dieter Reuter&lt;/a&gt; really has been pushing the cause for ARM64 support with both Raspberry Pi 3 and LinuxKit. He isn&amp;rsquo;t a single man army, the rest of the &lt;a href=&#34;http://blog.hypriot.com/crew/&#34;&gt;Docker Pirates&lt;/a&gt; over at &lt;a href=&#34;http://blog.hypriot.com/&#34;&gt;Hypriot&lt;/a&gt; have been doing some awesome things as well!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/cloud-init/brown-airplanes.jpg&#34; alt=&#34;airplanes&#34; /&gt;
&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/horiavarlan/5019447085/in/photolist-8DxYK8-6RFbEf-6RFfrw-6RLCGd-6RAH6n-6RF9gf-6RATnx-6RGCKM-6RB7L2-6REXqA-6T4VEQ-6RBeKg-brFbp6-6RAZU8-6RGwNk-6RAiLD-6RBgp6-6RLAvm-6RBbwM-6RAE5e-6RLJVj-6RLFdN-6RBsmr-6RFxxw-6RLJrY-6RFvGJ-6RFtZS-6REvrf-6RENUY-6RFwCC-6RGBEn-6RGz9n-6RFpb3-6RFzo1-if9tn-9NF66y-84UZy9-6RFew9-6RFq2m-6RLHWJ-6T4Wd9-9NChKc-6RAZ5V-9NCiK8-6T5Lbf-6RAUfp-6RBhb6-9NF3UW-9NF979-9NFaFW&#34;&gt;Horia Varlan&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Building on the backs of these outstanding community members, I was finally able to spin up a Raspberry Pi, exactly like I do in the &amp;ldquo;real world&amp;rdquo;, just turn it on, let it self-configure, then software just runs.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A lot of this is really about having &lt;a href=&#34;http://cloudinit.readthedocs.io/en/latest/index.html&#34;&gt;cloud-init &lt;/a&gt; available in the HypriotOS 64bit images thanks to another Pirate &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;Stefan Scherer&lt;/a&gt;. In the &amp;ldquo;cloud world&amp;rdquo;, you spin up instances, give it some user-data, then when it boots, the machines self-configures based on the instance meta-data and the user-data provided.&lt;/p&gt;

&lt;h2 id=&#34;before&#34;&gt;Before&lt;/h2&gt;

&lt;p&gt;Before we talk about the &amp;ldquo;new&amp;rdquo; pirate way, let&amp;rsquo;t talk about the &amp;ldquo;old&amp;rdquo; non-pirate way.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Download Raspbian Lite (the easiest for nubbies like me)&lt;/li&gt;
&lt;li&gt;Flash said image to an SD Card&lt;/li&gt;
&lt;li&gt;Optionally re-mount SD Card and monkey some stuff around&lt;/li&gt;
&lt;li&gt;Put the card in your RPi&lt;/li&gt;
&lt;li&gt;Power up the RPi&lt;/li&gt;
&lt;li&gt;If you don&amp;rsquo;t have avahi/bonjour, go find the IP in your router&lt;/li&gt;
&lt;li&gt;SSH into the server&lt;/li&gt;
&lt;li&gt;Update Packages&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;raspi-config&lt;/code&gt; and modify some junk&lt;/li&gt;
&lt;li&gt;Reboot&lt;/li&gt;
&lt;li&gt;Install Docker&lt;/li&gt;
&lt;li&gt;Initialize Docker Swarm&lt;/li&gt;
&lt;li&gt;Configure &lt;a href=&#34;http://portainer.io&#34;&gt;Portainer&lt;/a&gt; service (if not, are you broken?)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;try&amp;rdquo; and find some images you can run on arm&lt;/li&gt;
&lt;li&gt;Cheer at your glory based nginx hello world page!&lt;/li&gt;
&lt;li&gt;Figure out how to use automation tools like Ansible to make your life easier when you need a cluster&lt;/li&gt;
&lt;li&gt;Bang head on desk learning so much&amp;hellip;&lt;/li&gt;
&lt;li&gt;Do victory dances when you created a bunch of automation around setting up servers&lt;/li&gt;
&lt;li&gt;Go find out what the community is doing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is at that point, when the community really is an awesome place. Given the latest &lt;a href=&#34;https://github.com/DieterReuter/image-builder-rpi64/releases/tag/v20171013-172949&#34;&gt;HypriotOS-rpi64&lt;/a&gt;, the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash&lt;/a&gt; utility (also from Hypriot), Docker images now being multi-architecture supported through the &lt;a href=&#34;https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md&#34;&gt;manifest v2 API&lt;/a&gt; and Docker pushing to get all the &lt;a href=&#34;https://github.com/docker-library/official-images#architectures-other-than-amd64&#34;&gt;supported images covering a lot of architectures&lt;/a&gt;, life begins to get much &lt;strong&gt;much&lt;/strong&gt; easier.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: Before we continue, we need to talk about ARM 64 naming issues.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/ARM_architecture#64.2F32-bit_architecture&#34;&gt;ARM is complicated&lt;/a&gt; when it comes to the latest version of the architecture (v8). A lot of the distros still haven&amp;rsquo;t settled on what to call it, and you will find a lot of differences: &lt;code&gt;AArch64&lt;/code&gt; and &lt;code&gt;ARM64v8&lt;/code&gt; being the two most popular. When in doubt, do what &lt;a href=&#34;https://github.com/docker-library/official-images#architectures-other-than-amd64&#34;&gt;Docker does&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;after&#34;&gt;After&lt;/h2&gt;

&lt;p&gt;Now that we got that out of the way, let&amp;rsquo;s get into some code. Given the list of &lt;code&gt;arm64v8&lt;/code&gt; images in the &lt;a href=&#34;https://hub.docker.com/u/arm64v8/&#34;&gt;Docker registry&lt;/a&gt; I wanted to find something that would be interesting. Luckily, I was able to find &lt;a href=&#34;https://nextcloud.com/&#34;&gt;NextCloud&lt;/a&gt;. I have no idea if this software is worth keeping around, but it was something I could play with, try to break, reboot to see if it lives, and have something to play with when I succeed!&lt;/p&gt;

&lt;h3 id=&#34;user-data&#34;&gt;User Data&lt;/h3&gt;

&lt;p&gt;The first thing we need to do, is create our &lt;code&gt;user-data&lt;/code&gt; file. This will be placed inside of our SD card when we flash it and instruct &lt;code&gt;cloud-init&lt;/code&gt; what to do when the system boots for the first time.&lt;/p&gt;

&lt;p&gt;It should be noted, that at this time, the cloud-init version available for Debian distribution is &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/&#34;&gt;0.7.9&lt;/a&gt;, not the 17.1 you would have thought (as latest). Currently only Ubuntu is the only distribution I know of that is using 17.1.&lt;/p&gt;

&lt;p&gt;The next important fact to know is that the Data Source we are utilizing is the &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/topics/datasources/nocloud.html&#34;&gt;NoCloud&lt;/a&gt; data source. This basically means (in the 0.7.9 and below version) that the &lt;code&gt;user-data&lt;/code&gt; and &lt;code&gt;meta-data&lt;/code&gt; are on the local file system, not pulled from a remote resource or other means.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;user-data&lt;/code&gt; file is simply a YAML file, you can get a lot more complicated, but for the sake of simplicity, let&amp;rsquo;s just call it a YAML file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;user-data&lt;/code&gt; for this project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#cloud-config
# vim: syntax=yaml
#

hostname: nextcloud-pi64
manage_etc_hosts: true

resize_rootfs: true
growpart:
    mode: auto
    devices: [&amp;quot;/&amp;quot;]
    ignore_growroot_disabled: false

users:
  - name: pirate
    gecos: &amp;quot;Hypriot Pirate&amp;quot;
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    groups: users,docker,video
    plain_text_passwd: hypriot
    lock_passwd: false
    ssh_pwauth: true
    chpasswd: { expire: false }

package_update: true
package_upgrade: true
package_reboot_if_required: true
packages:
  - ntp

locale: &amp;quot;en_US.UTF-8&amp;quot;
timezone: &amp;quot;America/Los_Angeles&amp;quot;

write_files:
    - path: &amp;quot;/etc/docker/daemon.json&amp;quot;
      owner: &amp;quot;root:root&amp;quot;
      content: |
        {
          &amp;quot;labels&amp;quot;: [ &amp;quot;os=linux&amp;quot;, &amp;quot;arch=arm64&amp;quot; ],
          &amp;quot;experimental&amp;quot;: true
        }

runcmd:
  - [ systemctl, restart, avahi-daemon ]
  - [ systemctl, restart, docker ]
  - [docker, swarm, init ]
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;portainer&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;9000:9000&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=portainer_data,dst=/data&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock&amp;quot;,
      &amp;quot;portainer/portainer&amp;quot;, &amp;quot;-H&amp;quot;, &amp;quot;unix:///var/run/docker.sock&amp;quot;, &amp;quot;--no-auth&amp;quot;
    ]
  - [mkdir, &amp;quot;-p&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]
  - [setfacl, &amp;quot;-m&amp;quot;, &amp;quot;u:www-data:rwx&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;nextcloud&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;80:80&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=nextcloud,dst=/var/www/html&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/cloud/data,dst=/var/www/html/data&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;SQLITE_DATABASE=nextcloud&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_USER=pirate&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_PASSWORD=hypriot&amp;quot;,
      &amp;quot;nextcloud:latest&amp;quot;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is extremely important that before you flash this to a disk and attempt to boot, that you run this file through a YAML linter. There are some good ones &lt;a href=&#34;http://www.yamllint.com/&#34;&gt;available online&lt;/a&gt;, but you should never use an online linter if your &lt;code&gt;user-data&lt;/code&gt; contains real passwords or SSH keys, you can&amp;rsquo;t trust if they store the YAML or not on the server side.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s break this down into somewhat readable chunks&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;configure-host-name&#34;&gt;Configure Host Name&lt;/h4&gt;

&lt;p&gt;This will simply configure your hostname of the machine as well as make sure that &lt;code&gt;/etc/hosts&lt;/code&gt; is appropriately updated. You can specify an &lt;code&gt;fqdn&lt;/code&gt; here, as you will see below. However, the hostname in this file isn&amp;rsquo;t super important, as we will use the &lt;code&gt;--hostname&lt;/code&gt; option with the flash utility later to change this when we write the image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;hostname: nextcloud-pi64
manage_etc_hosts: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;resize-file-system&#34;&gt;Resize File System&lt;/h4&gt;

&lt;p&gt;This is something that had plagued RPi users for years, finally at some point the foundation images included this on first boot, but the wonderful thing about &lt;code&gt;cloud-init&lt;/code&gt; is it already had this built in. You &amp;ldquo;really&amp;rdquo; don&amp;rsquo;t need these settings in the file, I put these here to show that this is just built in functionality for &lt;code&gt;cloud-init&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;resize_rootfs: true
growpart:
    mode: auto
    devices: [&amp;quot;/&amp;quot;]
    ignore_growroot_disabled: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;create-users&#34;&gt;Create Users&lt;/h4&gt;

&lt;p&gt;Creating users is pretty simple, plop in an array element, give it some information, and your off to the races. The below is actually what is in the default &lt;code&gt;cloud-init&lt;/code&gt; for the HypriotOS image if you don&amp;rsquo;t overwrite it.  You can actually do a lot more with this, including adding SSH keys. Check out the &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/topics/modules.html#users-and-groups&#34;&gt;users documentation&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;users:
  - name: pirate
    gecos: &amp;quot;Hypriot Pirate&amp;quot;
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    groups: users,docker,video
    plain_text_passwd: hypriot
    lock_passwd: false
    ssh_pwauth: true
    chpasswd: { expire: false }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;update-and-add-packages&#34;&gt;Update and Add Packages&lt;/h4&gt;

&lt;p&gt;Because we live in a world of ever updating software, you really don&amp;rsquo;t know what is out of date in your image. This ensures that on first boot, all packages are updated. Additionally, you can install additional packages you might need. In this case I am installing NTP (there is a better way to do this, but there is an outstanding issue with it atm). Additionally, we instruct &lt;code&gt;cloud-init&lt;/code&gt; to reboot the server if the updates require one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;package_update: true
package_upgrade: true
package_reboot_if_required: true
packages:
  - ntp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NTP missing from the HypriotOS image is something I will be bringing up with the team to get fixed in the future!&lt;/p&gt;

&lt;h4 id=&#34;set-localized-settings&#34;&gt;Set Localized Settings&lt;/h4&gt;

&lt;p&gt;These will setup your server in your correct part of the world. The Raspbian comes with UK as default, at least HypriotOS came with a sane UTC default, but sometimes you just want your local time. This is definitely one of those time savers where most people used &lt;code&gt;raspi-config&lt;/code&gt; to set these (horrible horrible menus).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;locale: &amp;quot;en_US.UTF-8&amp;quot;
timezone: &amp;quot;America/Los_Angeles&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is something I feel like you should also be able to configure in the flash utility, and will be bringing it up as well with the Pirates.&lt;/p&gt;

&lt;h4 id=&#34;write-some-arbitrary-files&#34;&gt;Write some arbitrary files&lt;/h4&gt;

&lt;p&gt;The power to create files on boot&amp;hellip; This simple file output below is configuring docker labels as well as doing the (currently required) experimental features flag. This will require a Docker daemon restart, but we will cover that soon enough!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;write_files:
    - path: &amp;quot;/etc/docker/daemon.json&amp;quot;
      owner: &amp;quot;root:root&amp;quot;
      content: |
        {
          &amp;quot;labels&amp;quot;: [ &amp;quot;os=linux&amp;quot;, &amp;quot;arch=arm64&amp;quot; ],
          &amp;quot;experimental&amp;quot;: true
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;run-a-bunch-of-commands&#34;&gt;Run a bunch of commands&lt;/h4&gt;

&lt;p&gt;There are actually a few ways to run commands in &lt;code&gt;cloud-init&lt;/code&gt;, this is the most used, because it is the last thing that is done during initialization.&lt;/p&gt;

&lt;p&gt;In this, we are essentially restarting Docker and avahi to pickup our configuration changes, initializing Docker Swarm, running good ol Portainer (so we can see what is going on without SSH).&lt;/p&gt;

&lt;p&gt;The last steps are all specific to NextCloud. I create a new directory to store the files and SQL Lite database, set permissions for the &lt;code&gt;www-data&lt;/code&gt; user since NextCloud is using Apache, and running as a known user, we need to give that specific user permissions, and finally bootstrap NextCloud to self-configure and initialize.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;runcmd:
  # Pickup the hostname changes
  - [ systemctl, restart, avahi-daemon ]

  # Pickup the daemon.json changes
  - [ systemctl, restart, docker ]

  # Init a swarm, because why not
  - [docker, swarm, init ]

  # Run portainer, so we can see our logs and control stuff from a UI
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;portainer&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;9000:9000&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=portainer_data,dst=/data&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock&amp;quot;,
      &amp;quot;portainer/portainer&amp;quot;, &amp;quot;-H&amp;quot;, &amp;quot;unix:///var/run/docker.sock&amp;quot;, &amp;quot;--no-auth&amp;quot;
    ]

  # Create a specific directory to store all the data,
  # this way you could mount an external drive later (coming soon!)
  - [mkdir, &amp;quot;-p&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]

  # This gives the nextcloud permissions to write to this directory
  # since it runs as www-data
  - [setfacl, &amp;quot;-m&amp;quot;, &amp;quot;u:www-data:rwx&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]

  # Create the nextcloud instance configuring it on startup
  # - you should change the user/password below to something less obvious
  # or use the config UI
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;nextcloud&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;80:80&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=nextcloud,dst=/var/www/html&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/cloud/data,dst=/var/www/html/data&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;SQLITE_DATABASE=nextcloud&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_USER=pirate&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_PASSWORD=hypriot&amp;quot;,
      &amp;quot;nextcloud:latest&amp;quot;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are some important bits here, the &lt;code&gt;SQLITE_DATABASE=&amp;lt;name&amp;gt;&lt;/code&gt; is actually what triggers the &amp;ldquo;auto-configure&amp;rdquo; option, without that, the &lt;code&gt;NEXTCLOUD_*&lt;/code&gt; variables are ignored, despite what the documentation says.&lt;/p&gt;

&lt;h3 id=&#34;flash&#34;&gt;FLASH&lt;/h3&gt;

&lt;p&gt;If you don&amp;rsquo;t know about this utility yet, please head over to the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;github repo&lt;/a&gt; and check it out.&lt;/p&gt;

&lt;p&gt;Good, your back, now lets see my command line I use to run this on my Ubuntu 16.x Server.&lt;/p&gt;

&lt;p&gt;The following statements will install the prerequisites for flash, download the script, download this blog posts &lt;code&gt;user-data.yml&lt;/code&gt; file, then attempt to flash the image to an SD card.&lt;/p&gt;

&lt;p&gt;I highly recommend using a 32 or 64 GB flash card for this project, because if you decide to keep this cloud around, you might want to store one or two things in it.&lt;/p&gt;

&lt;p&gt;When prompted, insert your SD flash card into an available USB slot, then choose the right one, and verify the right one. You really don&amp;rsquo;t want DD to mount/flash/unmount your main drive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install pv unzip hdparm
curl -O https://raw.githubusercontent.com/hypriot/flash/master/$(uname -s)/flash
chmod +x flash
sudo mv flash /usr/local/bin/flash

# Just make sure the existing is gone
rm ./user-data.yml

# Download this yaml from this repo
curl -O https://gist.githubusercontent.com/RenEvo/6a9e244b670df334c42578b8fe95400b/raw/user-data.yml

// flash it
flash \
  --hostname mycloud.home.renevo.com \
  --userdata ./user-data.yml \
  https://github.com/DieterReuter/image-builder-rpi64/releases/download/v20171013-172949/hypriotos-rpi64-v20171013-172949.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When finished, pull out that sweet SD card, and let&amp;rsquo;s get ready to plug in.&lt;/p&gt;

&lt;h3 id=&#34;boot-and-forget&#34;&gt;Boot and Forget&lt;/h3&gt;

&lt;p&gt;For this, I simply put the SD card into a random RPi3 I had laying around, plugged in a network cable to my switch and the RPi, and then applied power to it.&lt;/p&gt;

&lt;p&gt;This is really where the waiting game begins, the RPi is going to boot up, self-name, self-update, possible reboot, pull down some Docker images, bootstrap a Docker Swarm, run Portainer, then finally&amp;hellip; start a personal cloud.&lt;/p&gt;

&lt;p&gt;At the time of writing this, you are still going to have to go fish out your IP from DNS unless you are on Mac or Linux with avahi, at that case, you can just navigate to &lt;code&gt;http://&amp;lt;hostname&amp;gt;.local&lt;/code&gt; or &lt;code&gt;http://&amp;lt;hostname&amp;gt;&lt;/code&gt; if you used an fqdn like I did. There are actually ways to get the RPi to phone home when it is finished bootstrapping, but I am going to save that for another post!&lt;/p&gt;

&lt;p&gt;So, after you get some coffee, you can try navigating to your RPi on port 9000 with your browser, that should get you into the Portainer instance without any type of authentication (don&amp;rsquo;t do this in a real environment please, go read the docs on securing it).&lt;/p&gt;

&lt;p&gt;After you go get a snack and take a short walk, you can try navigating to your RPi on port 80 with your browser, once you get prompted, login with user: &lt;code&gt;pirate&lt;/code&gt; and password: &lt;code&gt;hypriot&lt;/code&gt; to get access to your cloud. Click close on the annoying modal about downloading sync programs, and there you have it&amp;hellip; Your own personal cloud, bootstrapped from a simple YAML file, without you ever having to SSH into your PI.&lt;/p&gt;

&lt;p&gt;Here is the fun part, you can reflash that anytime you want to recreate the exact same baseline SD card image.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;This was a lot of fun for me, and without having to actually figure out some nitty gritty details, not over documenting things, and getting prepared to write this post, it realistically took me about 10 minutes to go from downloading the OS image to running NextCloud on my RPi. And that is all due to the hard work of the community, and especially the Docker Pirates at Hypriot, and to them, I thank you.&lt;/p&gt;

&lt;p&gt;I plan to continue playing with this, potentially updating the server to use an external USB drive for data and auto-mounting it on boot, possible setup a GlusterFS and run them in a small 2 or 3 node cluster, and call it my PiCloud.&lt;/p&gt;

&lt;p&gt;Who knows, it&amp;rsquo;s all about having fun and experimenting right?&lt;/p&gt;

&lt;p&gt;All the samples can be &lt;a href=&#34;https://gist.github.com/RenEvo/6a9e244b670df334c42578b8fe95400b&#34;&gt;found on on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;about-me&#34;&gt;About Me&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Who is this guy, and why is he posting on this blog?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My name is &lt;a href=&#34;https://twitter.com/TribalTom&#34;&gt;Tom Anderson&lt;/a&gt;, I am a Senior II Cloud Software Engineer by day at a killer gaming company, and by night I am a father, musician, tinkerer, and still&amp;hellip; a hobbiest programmer of all the things. Dieter Reuter was nice enough to ask me to guest post this topic, and I just felt it had to be done! The Pirates have given so much to the community, I felt I needed to give a little something back.&lt;/p&gt;

&lt;p&gt;Additionally, I build and talk about some things I think are cool on my own blog &lt;a href=&#34;http://tomanderson.me&#34;&gt;tomanderson.me&lt;/a&gt;, feel free to stop by and say hi!&lt;/p&gt;

&lt;p&gt;Finally, because legaleeze and stuff&amp;hellip; All opinions here are my own, and do not reflect the opinions of Blizzard Entertainment.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DockerCon 2017 Demo: Monitoring Docker Swarm with LED&#39;s</title>
      <link>https://blog.hypriot.com/post/dockerconaustin2017/</link>
      <pubDate>Thu, 20 Apr 2017 14:30:34 -0600</pubDate>
      
      <guid>https://blog.hypriot.com/post/dockerconaustin2017/</guid>
      <description>&lt;p&gt;At DockerCon 2017 in Austin I gave a presentation of a Raspberry Pi cluster mixed with some UP boards. The audience really liked the visual effects of the Docker Swarm scaling a service up and down. So I show you some background details what you need to run that demo on your Raspberry Pi cluster as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/stage2.jpg&#34; alt=&#34;PiCloud at DockerCon Austin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;All the effort played off to build that cluster, to find out how to drive LED&amp;rsquo;s in swarm mode, to put it into my bag and go through customs on my flight from Germany to Austin, Texas. It really was fun to show this the audience and everybody liked it.&lt;/p&gt;

&lt;p&gt;To enable you to replay the demo with some Pimoroni Blinkt! LED&amp;rsquo;s and Raspberry Pi - regardless if you only have Pi Zeros I want to show you the Docker images I used and the commands to show the scaling demo.&lt;/p&gt;

&lt;p&gt;The Docker image &lt;a href=&#34;https://hub.docker.com/r/stefanscherer/monitor/&#34;&gt;stefanscherer/monitor&lt;/a&gt; is available on the Docker Hub. It is a multi-architecture image that can be used on Linux with Intel or ARM CPU&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;So just create a Docker swarm with the usual commands &lt;code&gt;docker swarm init&lt;/code&gt; and then join some other workers with the swarm token shown in your terminal.&lt;/p&gt;

&lt;h2 id=&#34;start-the-led-monitor&#34;&gt;Start the LED monitor&lt;/h2&gt;

&lt;p&gt;First we have to start the LED monitor as a service so that it is running on each node of the Docker swarm. The option &lt;code&gt;--mode global&lt;/code&gt; will do this and start one instance on each node. We have to bind mount both the Docker socket and a part of the file system into the container so it can access the &lt;code&gt;/sys/class/fs&lt;/code&gt; file system.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service create --name monitor --mode global \
  --restart-condition any --mount type=bind,src=/sys,dst=/sys \
  --mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
  stefanscherer/monitor:1.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are all set to play with scaling an example service.&lt;/p&gt;

&lt;h2 id=&#34;scale-up&#34;&gt;Scale up&lt;/h2&gt;

&lt;p&gt;There is another multi-arch image that I used for the scaling demo. It is the &amp;ldquo;whoami&amp;rdquo; web service that responds the container&amp;rsquo;s hostname.&lt;/p&gt;

&lt;p&gt;First we create the service with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service create --name whoami stefanscherer/whoami:1.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As said this works with any Raspberry Pi or the UP board that has an Intel Atom CPU.
After the image has been downloaded the LED monitor should show one yellow LED lighting up.&lt;/p&gt;

&lt;p&gt;Now scale the service a little more eg. to the number of nodes you have to have one LED lighting up per node.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then scale it up a little more&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/scale-up.gif&#34; alt=&#34;Scale up&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And then light up all the LED&amp;rsquo;s by scaling up to the number of LED&amp;rsquo;s you have.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=32
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rolling-update&#34;&gt;Rolling update&lt;/h2&gt;

&lt;p&gt;Another thing that can be visualized is a rolling update. The LED monitor shows each container with a yellow color for version 1.1.0 of the service and blue for version 1.2.0.&lt;/p&gt;

&lt;p&gt;So start the rolling update by specifing &lt;code&gt;--update-parallelism&lt;/code&gt; with the number of containers that should be replaced in one step. So Docker Swarm kills that number of containers and starts the new version of it before stopping the next bulk of containers. Use the &lt;code&gt;--image&lt;/code&gt; option to specifiy the new version that should be used by the whoami service.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service update --update-parallelism 5 \
  --image stefanscherer/whoami:1.2.0 whoami
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now watch what happens. Each destroyed container lights up red and then dims. After a while Docker swarm manager starts the new version and so new LED&amp;rsquo;s with blue light up. After a while all LED&amp;rsquo;s have changed from yellow (version 1.1.0) to blue (version 1.2.0). And while this rolling update is going on you still can use this &amp;ldquo;whoami&amp;rdquo; service by curl&amp;rsquo;ing it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/rolling-update.gif&#34; alt=&#34;Rolling update&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;scale-down-to-one&#34;&gt;Scale down to one&lt;/h2&gt;

&lt;p&gt;Another nice effect is to scale down the service back to one as all LED&amp;rsquo;s will flash up in red and only one LED remains blue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/scale-down-to-one.gif&#34; alt=&#34;Scale down to one&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hope I did make you curious to try it out on your own cluster. Happy hacking and have fun! If you want to improve the visual effects have a look at the Node.js sources in the &lt;a href=&#34;https://github.com/StefanScherer/swarm-monitor&#34;&gt;GitHub repo&lt;/a&gt;. Rewrite it in Golang or anything else and suprise me with other nice visual effects.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building a 64bit Docker OS for the Raspberry Pi 3</title>
      <link>https://blog.hypriot.com/post/building-a-64bit-docker-os-for-rpi3/</link>
      <pubDate>Thu, 02 Mar 2017 11:28:42 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/building-a-64bit-docker-os-for-rpi3/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m happy to announce the start of a &amp;ldquo;short&amp;rdquo; workshop were I&amp;rsquo;m going through all the steps to build a complete 64bit operating system for the Raspberry Pi 3. This 64bit HypriotOS is mainly focused on running Docker containers easily on this popular DIY and IoT device.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/e/e6/Raspberry-Pi-3-Flat-Top.jpg&#34; alt=&#34;Raspi3-Image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll see that I&amp;rsquo;m using Docker heavily for each and every build step, because it really helps us a lot to run a local build with &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;Docker-for-Mac&lt;/a&gt; or later on the cloud build servers at &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/building-a-64bit-docker-os-for-rpi3/bee42-workshop.jpg&#34; alt=&#34;bee42-workshop.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This workshop is sponsored by &lt;a href=&#34;http://bee42.com&#34;&gt;bee42 solutions&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bee42solutions&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @bee42solutions&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background-and-contents&#34;&gt;Background and Contents&lt;/h3&gt;

&lt;p&gt;As you may already know, a complete Linux operating system consists of several important building blocks and I&amp;rsquo;d like to show you how to build all of these step by step.&lt;/p&gt;

&lt;p&gt;For this purpose I&amp;rsquo;m not going to reinvent the wheel and so I&amp;rsquo;ll reuse all of the existing parts which are already published by the Raspberry Pi Organisation, by the Debian Linux project and will add some more glue code.&lt;/p&gt;

&lt;p&gt;At the end you should have learned how to build all the necessary parts and how to automatically create a finished SD card image which could be flashed on an empty SD card. Then boot your Raspberry Pi 3 with and in less than a minute you have a fully running Docker Engine on a Debian-based 64bit Linux OS.&lt;/p&gt;

&lt;p&gt;Here is a short overview of the contents of the workshop:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 1: Bootloader&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 2: Kernel&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 3: Root filesystem&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 4: SD Card Image&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, that&amp;rsquo;s enough for explaining the background of this workshop. For more informations please follow along the details I&amp;rsquo;ll publish on the coming tweets at Twitter and in the GitHub repos until all the parts of this workshop are finished and available as OpenSource.&lt;/p&gt;

&lt;p&gt;Please be aware that this OS is in a development phase and far from being perfect. So you are encouraged to help me with reporting issues and filing pull-requests to add features and fix bugs.&lt;/p&gt;

&lt;h3 id=&#34;further-links&#34;&gt;Further Links&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to publish all the details and steps to build the new operating system in a public GitHub repo. All other details and necessary GitHub repos will be linked here in this section as a future reference.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Workshop Repo&lt;/strong&gt; &lt;a href=&#34;https://github.com/dieterreuter/workshop-raspberrypi-64bit-os&#34;&gt;https://github.com/dieterreuter/workshop-raspberrypi-64bit-os&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So please stay tuned, this link list will be extended over the next few days.&lt;/p&gt;

&lt;h3 id=&#34;acknowledgments&#34;&gt;Acknowledgments&lt;/h3&gt;

&lt;p&gt;Please follow along the detailed tweets about this workshop via&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; &lt;a href=&#34;https://twitter.com/Quintus23M&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @Quintus23M&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt; &lt;a href=&#34;https://twitter.com/HypriotTweets&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @HypriotTweets&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/bee42solutions&#34;&gt;@bee42solutions&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bee42solutions&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @bee42solutions&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Special thanks goes to &lt;a href=&#34;http://bee42.com&#34;&gt;bee42 solutions&lt;/a&gt; for giving me the time to work on this awesome topic to build a complete Docker-enabled 64bit OS for the Raspberry Pi 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/building-a-64bit-docker-os-for-rpi3/bee42-logo.jpg&#34; alt=&#34;bee42-logo.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Let&#39;s build the smallest possible Docker image</title>
      <link>https://blog.hypriot.com/post/build-smallest-possible-docker-image/</link>
      <pubDate>Wed, 22 Feb 2017 09:18:35 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/build-smallest-possible-docker-image/</guid>
      <description>&lt;p&gt;Imagine what happens if we&amp;rsquo;re starting to use Docker containers on IoT devices. On small and slow devices with limited system resources and connected via a damn slow network connection we do have to care differently on how to build and ship our apps. In these circumstances it pays off and it&amp;rsquo;s absolutely essential to optimize our applications and the resulting Docker images for size.&lt;/p&gt;

&lt;p&gt;SIZE DOES MATTER&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/build-smallest-possible-docker-image/docker-image-minimal.png&#34; alt=&#34;docker-image-minimal.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re doing it right we&amp;rsquo;ll get a lot of benefits such as blasting fast download speed for updating to a new or more secured version. On wireless networks we are also reducing the costs for data transfers as well.&lt;/p&gt;

&lt;p&gt;According to my &lt;a href=&#34;https://twitter.com/quintus23m/status/834132186211180544&#34;&gt;tweet&lt;/a&gt; I&amp;rsquo;d like to start a new Docker challenge:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How small is the smallest Docker image we could build, which prints a &amp;ldquo;Hello Docker World!&amp;rdquo;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Sometimes developing directly on an IoT device can be pretty hard or nearly impossible due to the lack of enough system resources. These resources can be the amount of memory, disk space or CPU capacity - or it can be just a limited network connectivity over a low-bandwith 64kbit/sec wireless network.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s assume we do have a Raspberry Pi already deployed in the field and this IoT device has such a low-bandwidth network connection. We&amp;rsquo;re preparing our developing system to run on a bare-metal cloud server and we are transfering our build artefacts as ready-to-run Docker images regularly with each and every new release in a DevOps driven manner. For this reason we&amp;rsquo;d like to speed up the deployment with minimized Docker image sizes.&lt;/p&gt;

&lt;p&gt;Wait, I thought a Docker image can be pretty heavy with up to 1 GByte or even larger? Well, that could happen if we&amp;rsquo;re packing a whole Operating System like Ubuntu or Debian into our Docker images. But as we&amp;rsquo;re building an IoT application we should take care about that situation. A Docker image can instead be build with an app consisting of a statically linked binary and when we start it as a Docker container it will run a single Linux process only.&lt;/p&gt;

&lt;h3 id=&#34;creating-our-app-in-arm-assembly&#34;&gt;Creating our App in ARM assembly&lt;/h3&gt;

&lt;p&gt;TL;DR all the source code and build instructions can be found in this public &lt;a href=&#34;https://github.com/DieterReuter/dockerchallenge-smallest-image&#34;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here is my starting example of an assembly program which just prints a single static text string. It is written in ARM assembly language and should be compiled into a really small binary we can run on any ARMv7 device.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat hello.S
.data
msg:
    .ascii      &amp;quot;Hello Docker World!\n&amp;quot;
len = . - msg

.text

.globl _start
_start:
    /* syscall write(int fd, const void *buf, size_t count) */
    mov     %r0, $1     /* fd -&amp;gt; stdout */
    ldr     %r1, =msg   /* buf -&amp;gt; msg */
    ldr     %r2, =len   /* count -&amp;gt; len(msg) */
    mov     %r7, $4     /* write is syscall #4 */
    swi     $0          /* invoke syscall */

    /* syscall exit(int status) */
    mov     %r0, $0     /* status -&amp;gt; 0 */
    mov     %r7, $1     /* exit is syscall #1 */
    swi     $0          /* invoke syscall */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s compile and link it as a static program&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ as -o hello.o hello.S
$ ld -s -o hello hello.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show details about the binary&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ file hello
hello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now as we do have our app as a single binary program, we can build our smallest Docker image easily from scratch. This new Docker image consists only our binary and nothing else of other components at all. But you have to know this only works if the binary is statically linked and has all necessary tools baked in.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat Dockerfile.armhf
FROM scratch
ADD hello /hello
CMD [&amp;quot;/hello&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Building the Docker image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t dieterreuter/hello -f Dockerfile.armhf .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;starting-point&#34;&gt;Starting point&lt;/h3&gt;

&lt;p&gt;With all the details I&amp;rsquo;ve shown above in this blog post I finally built a first super-small Docker image with an indicated size of 452 Bytes only.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
dieterreuter/hello           latest              b961df9c849e        27 hours ago        452 B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting this Docker container on a Raspberry Pi (or another ARMv7 machine) will print the requested text string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run dieterreuter/hello
Hello Docker World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, if you&amp;rsquo;re working with &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;Docker-for-Mac&lt;/a&gt; or &lt;a href=&#34;https://docs.docker.com/docker-for-windows/&#34;&gt;Docker-for-Windows&lt;/a&gt; you should try to run this command, too. I guess you&amp;rsquo;ll be surprised what happens on your Intel based system when you start this Docker container which is containing an ARM binary. But this is a topic for another future blog post.&lt;/p&gt;

&lt;h3 id=&#34;challenge-details&#34;&gt;Challenge details&lt;/h3&gt;

&lt;p&gt;There are not many rules for this challenge, but let&amp;rsquo;s give you some hints:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the Docker image should output the text &amp;ldquo;Hello Docker World!&amp;rdquo; on the console&lt;/li&gt;
&lt;li&gt;we measure the size of the Docker image with &lt;code&gt;docker images&lt;/code&gt; or &lt;code&gt;docker image ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;feel free to use a CPU architecture of your choice: Intel, ARMv7, ARMv8/AARCH64, &amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Please publish your results on DockerHub, source codes on GitHub and tweet about it on Twitter with the hashtag #DockerChallenge. The goal of this challenge is to get familiar with the techniques to build minimal sized Docker images not only for IoT use cases, to understand the fact that a Docker container can be just a single process, and that this process can be really extremely small itself. On the way we&amp;rsquo;ll learn to take care about all the necessary steps to reduce the size and how we can optimize our development workflow as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/build-smallest-possible-docker-image/docker-image-minimal2.png&#34; alt=&#34;docker-image-minimal2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s start the journey&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Setup Kubernetes on a Raspberry Pi Cluster easily the official way!</title>
      <link>https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/</link>
      <pubDate>Wed, 11 Jan 2017 14:03:34 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;kubernetes.io&#34;&gt;Kubernetes&lt;/a&gt; shares the pole position with Docker in the category &amp;ldquo;orchestration solutions for Raspberry Pi cluster&amp;rdquo;.
However it&amp;rsquo;s setup process has been elaborate – until &lt;a href=&#34;http://blog.kubernetes.io/2016/09/how-we-made-kubernetes-easy-to-install.html&#34;&gt;v1.4 with the kubeadm announcement&lt;/a&gt;.
With that effort, Kubernetes changed this game completely and can be up and running officially within no time.&lt;/p&gt;

&lt;p&gt;I am very happy to announce that this blog post has been written in collaboration with &lt;a href=&#34;https://github.com/luxas&#34;&gt;Lucas Käldström&lt;/a&gt;, an independent maintainer of Kubernetes (his story is very interesting,  you can read it in a &lt;a href=&#34;https://www.cncf.io/blog/2016/11/29/diversity-scholarship-series-programming-journey-becoming-kubernetes-maintainer&#34;&gt;CNCF blogpost&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/raspberry-pi-cluster.png&#34; alt=&#34;SwarmClusterHA&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;why-kubernetes&#34;&gt;Why Kubernetes?&lt;/h2&gt;

&lt;p&gt;As shown in my recent &lt;a href=&#34;http://www.slideshare.net/MathiasRenner/high-availability-performance-of-kubernetes-and-docker-swarm-on-a-raspberry-pi-cluster/&#34;&gt;talk&lt;/a&gt;, there are many software suites available to manage a cluster of computers. There is Kubernetes, Docker Swarm, Mesos, OpenStack, Hadoop YARN, Nomad&amp;hellip; just to name a few.&lt;/p&gt;

&lt;p&gt;However, at Hypriot we have always been in love with tiny devices. So when working with an orchestrator, the maximum power we wanna use is what&amp;rsquo;s provided by a Raspberry Pi. Why? We have IoT networks in mind that will hold a large share in tomorrow&amp;rsquo;s IT infrastructure. At their edges, the power required for large orchestrators simply is not available.&lt;/p&gt;

&lt;p&gt;This boundary of resources leads to several requirements that need to be checked before we start getting our hands dirty with an orchestrator:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lightweight:&lt;/strong&gt; Software should be fit on a Raspberry Pi or smaller. As proofed in my talk mentioned above, Kubernetes painlessly runs on a Raspberry Pi.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARM compatible:&lt;/strong&gt; Since the ARM CPU architecture is designed for low energy consumption but still able to deliver a decent portion of power, the Raspberry Pi runs an ARM CPU. Thanks to Lucas, Kubernetes is ARM compatible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;General purpose:&lt;/strong&gt; Hadoop or Apache Spark are great for data analysis. But what if your use case changes? We prefer general purpose software that allows to run &lt;strong&gt;anything&lt;/strong&gt;. Kubernetes uses a container runtime (with Docker as the 100% supported runtime for the time being) that allows to run whatever you want.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Production ready:&lt;/strong&gt; Since we compare Kubernetes against a production ready Docker suite, let&amp;rsquo;s be fair and only choose equivalents. Kubernetes itself is production ready, and while the ARM port has some small issues, it&amp;rsquo;s working exactly as expected when going the official kubeadm route, which also will mature with time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, Kubernetes seems to be a compelling competitor to Docker Swarm. Let&amp;rsquo;s get our hands on it!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;wait-what-about-kubernetes-on-arm&#34;&gt;Wait – what about &lt;em&gt;Kubernetes-on-ARM&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;If you followed the discussion of Kubernetes on ARM for some time, you probably know about Lucas&amp;rsquo; project &lt;a href=&#34;https://github.com/luxas/kubernetes-on-arm&#34;&gt;kubernetes-on-ARM&lt;/a&gt;. Since the beginning of the movement to bring Kubernetes on ARM in 2015, this project has always been the most stable and updated.&lt;/p&gt;

&lt;p&gt;However, during 2016, Lucas&amp;rsquo; contributions have successfully been merged into official Kubernetes repositories, such that there is no point any more for using the kubernetes-on-ARM project.
In fact, the features of that project are far behind of what&amp;rsquo;s now implemented in the official repos, &lt;strong&gt;and that has been Lucas&amp;rsquo; goal from the beginning.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So if you&amp;rsquo;re up to using Kubernetes, please stick to the official repos now. And as of the kubeadm documentation, &lt;strong&gt;the following setup is considered official for Kubernetes on ARM.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;at-first-flash-hypriotos-on-your-sd-cards&#34;&gt;At first: Flash HypriotOS on your SD cards&lt;/h2&gt;

&lt;p&gt;As hardware, take at least two Raspberry Pis and make sure they are connected to each other and to the Internet.&lt;/p&gt;

&lt;p&gt;First, we need an operating system. Download and flash &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases&#34;&gt;HypriotOS&lt;/a&gt;. The fastest way to download and flash HypriotOS on your SD cards is by using our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --hostname node01 https://github.com/hypriot/image-builder-rpi/releases/download/v1.4.0/hypriotos-rpi-v1.4.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Provision all Raspberry Pis you have like this and boot them up.&lt;/p&gt;

&lt;p&gt;Afterwards, SSH into the Raspberry Pis with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@node01.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The password &lt;code&gt;hypriot&lt;/code&gt; will grant you access.&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;install-kubernetes&#34;&gt;Install Kubernetes&lt;/h2&gt;

&lt;p&gt;The installation requries root privileges. Retrieve them by&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo su -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install Kubernetes and its dependencies, only some commands are required.
First, trust the kubernetes APT key and add the official APT Kubernetes repository on every node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
$ echo &amp;quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&amp;quot; &amp;gt; /etc/apt/sources.list.d/kubernetes.list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and then just install &lt;code&gt;kubeadm&lt;/code&gt; on every node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get update &amp;amp;&amp;amp; apt-get install -y kubeadm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the previous command has been finished, initialize Kubernetes on the &lt;strong&gt;master node&lt;/strong&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm init --pod-network-cidr 10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is important that you add the &lt;code&gt;--pod-network-cidr&lt;/code&gt; command as given here, because we will use &lt;a href=&#34;https://coreos.com/flannel/docs/latest/&#34;&gt;flannel&lt;/a&gt;. Read the next notes about flannel if you wanna know why.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Some notes about flannel&lt;/strong&gt;: We picked flannel here because that’s the only available solution for ARM at the moment (this is subject to change in the future though).&lt;/p&gt;

&lt;p&gt;flannel can use and is using in this example the Kubernetes API to store metadata about the Pod CIDR allocations, and therefore we need to tell &lt;em&gt;Kubernetes&lt;/em&gt; first which subnet we want to use. The subnet we chose here is somehow fixed, because the &lt;a href=&#34;https://github.com/coreos/flannel/blob/master/Documentation/kube-flannel.yml#L25&#34;&gt;flannel configuration file&lt;/a&gt; that we&amp;rsquo;ll use later in this guide predefines the equivalent subnet. Of course, you can adapt both.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you are connected via WIFI instead of Ethernet, add &lt;code&gt;--apiserver-advertise-address=&amp;lt;wifi-ip-address&amp;gt;&lt;/code&gt; as parameter to &lt;code&gt;kubeadm init&lt;/code&gt; in order to publish Kubernetes&amp;rsquo; API via WiFi. Feel free to explore the other options that exist for &lt;code&gt;kubeadm init&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After Kubernetes has been initialized, the last lines of your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/init.png&#34; alt=&#34;init&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To start using your cluster, you need to run (as a regular user):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo cp /etc/kubernetes/admin.conf $HOME/
$ sudo chown $(id -u):$(id -g) $HOME/admin.conf
$ export KUBECONFIG=$HOME/admin.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, as told by that output, let all other nodes join the cluster via the given &lt;code&gt;kubeadm join&lt;/code&gt; command. It will look something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm join --token=bb14ca.e8bbbedf40c58788 192.168.0.34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After some seconds, you should see all nodes in your cluster when executing the following &lt;strong&gt;on the master node&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/get-nodes.png&#34; alt=&#34;k8S&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, &lt;strong&gt;we need to setup flannel v0.9.1 as the Pod network driver&lt;/strong&gt;. Do not use &lt;a href=&#34;https://github.com/coreos/flannel/releases/tag/v0.8.0&#34;&gt;v0.8.0&lt;/a&gt; due to a known &lt;a href=&#34;https://github.com/coreos/flannel/issues/773&#34;&gt;bug&lt;/a&gt; that can cause a &lt;code&gt;CrashLoopBackOff&lt;/code&gt; error. Run this &lt;strong&gt;on the master node&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sSL https://rawgit.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml | sed &amp;quot;s/amd64/arm/g&amp;quot; | kubectl create -f -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/flannel.png&#34; alt=&#34;k8S&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then wait until all flannel and all other cluster-internal Pods are &lt;code&gt;Running&lt;/code&gt; before you continue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get po --all-namespaces
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice, it seems like they are all &lt;code&gt;Running&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/show-namespaces.png&#34; alt=&#34;show-namespaces&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all for the setup of Kubernetes! Next, let&amp;rsquo;s actually spin up a service on the cluster!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;test-your-setup-with-a-tiny-service&#34;&gt;Test your setup with a tiny service&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start a simple service so see if the cluster actually can publish a service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run hypriot --image=hypriot/rpi-busybox-httpd --replicas=3 --port=80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command starts set of containers called &lt;strong&gt;hypriot&lt;/strong&gt; from the image &lt;strong&gt;hypriot/rpi-busybox-httpd&lt;/strong&gt; and defines the port the container listens on at &lt;strong&gt;80&lt;/strong&gt;. The service will be &lt;strong&gt;replicated with 3 containers&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Next, expose the Pods in the above created Deployment in a Service with a stable name and IP:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl expose deployment hypriot --port 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! Now, let&amp;rsquo;s check if all three desired containers are up and running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get endpoints hypriot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see three endpoints (= containers) like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/show-endpoints.png&#34; alt=&#34;show-endpoints&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s curl one of them to see if the service is up:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/curl-service.png&#34; alt=&#34;curl-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The HTML is the response of the service. Good, it&amp;rsquo;s up and running! Next, let&amp;rsquo;s see how we can access it from outside the cluster!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;finally-access-your-service-from-outside-the-cluster&#34;&gt;Finally access your service from outside the cluster&lt;/h2&gt;

&lt;p&gt;We will now deploy an example Ingress Controller to manage incoming requests from the outside world onto our tiny service. Also, in this example we we&amp;rsquo;ll use &lt;a href=&#34;https://traefik.io&#34;&gt;Traefik&lt;/a&gt; as load balancer. Read the following notes if you wanna know more about Ingress and Traefik.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;In contrast to Docker Swarm, Kubernetes itself does not provide an option to define a specific port that you can use to access a service&lt;/strong&gt;. According to Lucas this is an important design decision; routing of incoming requests should be handled by a third party, such as a load balancer or a webserver, but not by the core product. The core Kubernetes should be lean and extensible, and encourage others to build tools on top of it for their specific needs.&lt;/p&gt;

&lt;p&gt;Regarding load balancers in front of a cluster, there is &lt;a href=&#34;http://kubernetes.io/docs/user-guide/ingress/&#34;&gt;the Ingress API object&lt;/a&gt; and some sample &lt;a href=&#34;https://github.com/kubernetes/ingress&#34;&gt;Ingress Controllers&lt;/a&gt;. Ingress is a built-in way of exposing Services to the outside world via an Ingress Controller that anyone can build. An &lt;em&gt;Ingress rule&lt;/em&gt; defines how traffic should flow from the node the Ingress controller runs on to services inside of the cluster.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;First, let&amp;rsquo;s deploy traefik as load balancer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/hypriot/rpi-traefik/master/traefik-k8s-example.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Label the node you want to be the load balancer. Then the Traefik Ingress Controller will land on the node you specified. Run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl label node &amp;lt;load balancer-node&amp;gt; nginx-controller=traefik
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, create an Ingress object that makes Traefik load balance traffic on port &lt;code&gt;80&lt;/code&gt; to the &lt;code&gt;hypriot&lt;/code&gt; service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;gt; hypriot-ingress.yaml &amp;lt;&amp;lt;EOF
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: hypriot
spec:
  rules:
  - http:
      paths:
      - path: /
        backend:
          serviceName: hypriot
          servicePort: 80
EOF
$ kubectl apply -f hypriot-ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visit the loadbalancing node&amp;rsquo;s IP address in your browser and you should see a nice web page:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/hypriot-website.png&#34; alt=&#34;curl-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t see a website there yet, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get pods
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and make sure all hypriot Pods are in the &lt;code&gt;Running&lt;/code&gt; state.&lt;/p&gt;

&lt;p&gt;Wait until you see that all Pods are running, and a nice Hypriot website should appear!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;tear-down-the-cluster&#34;&gt;Tear down the cluster&lt;/h2&gt;

&lt;p&gt;If you wanna reset the whole cluster to the state after a fresh install, just run this on each node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm reset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition, it is recommended to delete some additional files &lt;a href=&#34;http://stackoverflow.com/questions/41359224/kubernetes-failed-to-setup-network-for-pod-after-executed-kubeadm-reset/41372829#41372829&#34;&gt;as it is mentioned here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;optional-deploy-the-kubernetes-dashboard&#34;&gt;Optional: Deploy the Kubernetes dashboard&lt;/h2&gt;

&lt;p&gt;The dashboard is a wonderful interface to visualize the state of the cluster. Start it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard-arm.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the kubernetes-dashboard service to use &lt;code&gt;type: ClusterIP&lt;/code&gt; to &lt;code&gt;type: NodePort&lt;/code&gt;, see &lt;a href=&#34;https://github.com/kubernetes/dashboard/wiki/Accessing-Dashboard---1.7.X-and-above&#34;&gt;Accessing Kubernetes Dashboard&lt;/a&gt; for more details.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl -n kube-system edit service kubernetes-dashboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following command provides the port that the dashboard is exposed at on every node with the NodePort function of Services, which is another way to expose your Services to the outside of your cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl -n kube-system get service kubernetes-dashboard -o template --template=&amp;quot;{{ (index .spec.ports 0).nodePort }}&amp;quot; | xargs echo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can checkout the dashboard on any node&amp;rsquo;s IP address on that port! Make sure to use &lt;code&gt;https&lt;/code&gt; when accessing the dashboard, for example if running on port &lt;code&gt;31657&lt;/code&gt; access it at &lt;code&gt;https://node:31657&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Newer versions of the Kubernetes Dashboard require either a &lt;code&gt;Kubeconfig&lt;/code&gt; or &lt;code&gt;Token&lt;/code&gt; to view information on the dashboard. &lt;a href=&#34;https://github.com/kubernetes/dashboard/wiki/Access-control#introduction&#34;&gt;Bearer tokens&lt;/a&gt; are recommended to setup proper permissions for a user, but to test the &lt;code&gt;replicaset-controller-token&lt;/code&gt; Token may be used to test.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl -n kube-system describe secret `kubectl -n kube-system get secret | grep replicaset-controller-token | awk &#39;{print $1}&#39;` | grep token: | awk &#39;{print $2}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;you-like-a-follow-up&#34;&gt;You like a follow-up?&lt;/h2&gt;

&lt;p&gt;It was our goal to show that Kubernetes indeed works well on ARM (and ARM 64-bit!). For more examples including the AMD64 platform, check out the &lt;a href=&#34;http://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;official kubeadm documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We might follow-up this blog post with a more in-depth post about the current and planned state of Kubernetes officially on ARM and more, so stay tuned and tell Lucas if that&amp;rsquo;s something you&amp;rsquo;re interested in reading.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;Mathias Renner&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/kubernetesonarm&#34;&gt;Lucas Käldström&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Setup a simple CI pipeline to build Docker images for ARM</title>
      <link>https://blog.hypriot.com/post/setup-simple-ci-pipeline-for-arm-images/</link>
      <pubDate>Tue, 10 Jan 2017 07:25:23 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/setup-simple-ci-pipeline-for-arm-images/</guid>
      <description>&lt;p&gt;Recently I did an experiment: Can we build Docker images for ARM on ordinary cloud CI services that only provide Intel CPU&amp;rsquo;s?&lt;/p&gt;

&lt;p&gt;The idea was to get rid of self hosted CI build agents that you have to care for. If you want to provide an ARM Docker image for an open source project your task is to build it and not to setup and maintain a whole pipeline for it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/setup-simple-ci-pipeline-for-arm-images/github_yaml_arm.png&#34; alt=&#34;GitHub + YAML = ARM Docker image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;We at Hypriot have created several Dockerfiles for open source tools like &lt;a href=&#34;https://github.com/hypriot/rpi-mysql&#34;&gt;MySQL&lt;/a&gt;, &lt;a href=&#34;https://github.com/hypriot/rpi-traefik&#34;&gt;Træfɪk&lt;/a&gt; or &lt;a href=&#34;https://github.com/hypriot/rpi-node&#34;&gt;Node.js&lt;/a&gt; to make them available as Docker images for your ARM devices.&lt;/p&gt;

&lt;p&gt;Building such images and maintaining them over a longer period of time you have to care for updates. We are happy to receive pull requests from our community that help us updating the Dockerfiles.
But sometimes it happended that our ARM CI pipeline went offline and we had to put in some time and effort to fix it. There were pull requests lying around for some time without any CI checks.&lt;/p&gt;

&lt;p&gt;To get out of this trap I wanted a simpler CI pipeline without self hosted build agents. There are several cloud CI services like Travis, Codeship, Circle and so on, but they all only offer you Intel based CPU&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;But they have one thing in common: Just add a YAML file to your GitHub repo, connect it to their CI servers and you are done. There must be a way to use this convenient way for our ARM builds.&lt;/p&gt;

&lt;h3 id=&#34;qemu-for-the-rescue&#34;&gt;QEMU for the rescue&lt;/h3&gt;

&lt;p&gt;There are some blog posts how to use QEMU to emulate ARM on Intel CPU&amp;rsquo;s and many have even tried to build Docker images. I followed these tutorials, but many steps were needed to set up everything and it looked very complex.&lt;/p&gt;

&lt;p&gt;But after some hours of investigation I found out that all comes down to just two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;An Intel binary of QEMU for ARM must exist in the base Docker image&lt;/li&gt;
&lt;li&gt;The QEMU binary must be registered in the CI build agent&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fortunately both steps can be done in a very simple way.&lt;/p&gt;

&lt;h3 id=&#34;choose-a-base-image-with-qemu-binary&#34;&gt;Choose a base image with QEMU binary&lt;/h3&gt;

&lt;p&gt;The Raspbian Docker images from &lt;a href=&#34;https://resin.io&#34;&gt;Resin&lt;/a&gt; already have the QEMU binary in it. As these are the most common base images used you are already prepared.&lt;/p&gt;

&lt;p&gt;So if you use the following line in your &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM resin/rpi-raspbian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you are done with the first step. But what about Alpine? Well we have created a similar - still small - Docker image &lt;a href=&#34;https://github.com/hypriot/rpi-alpine&#34;&gt;hypriot/rpi-alpine&lt;/a&gt; that uses the &amp;ldquo;official&amp;rdquo; &lt;a href=&#34;https://hub.docker.com/r/armhf/alpine/&#34;&gt;armhf/alpine&lt;/a&gt; image and just append the QEMU binary. If you want to build ARM Alpine images just use this line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM hypriot/rpi-alpine
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;register-qemu-in-the-build-agent&#34;&gt;Register QEMU in the build agent&lt;/h3&gt;

&lt;p&gt;The next step is to register QEMU in the build agent. There is a Docker image available that can do this for us in just one line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm --privileged multiarch/qemu-user-static:register --reset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. Just add this line to your YAML file before the other docker commands.&lt;/p&gt;

&lt;h3 id=&#34;travis-builds-mysql-arm-image&#34;&gt;Travis builds MySQL ARM image&lt;/h3&gt;

&lt;p&gt;I have done the tests with Travis CI to build ARM images. But if you prefer another cloud CI services that offers Docker builds, it should be the same.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s put all pieces together and have a look at the final &lt;code&gt;.travis.yml&lt;/code&gt; file that is used to build the &lt;a href=&#34;https://github.com/hypriot/rpi-mysql&#34;&gt;hypriot/rpi-mysql&lt;/a&gt; Docker image for ARM.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo: required
services:
- docker
language: bash
script:
# prepare qemu
- docker run --rm --privileged multiarch/qemu-user-static:register --reset
# build image
- docker build -t hypriot/rpi-mysql .
# test image
- docker run hypriot/rpi-mysql mysql --version
# push image
- &amp;gt;
  if [ &amp;quot;$TRAVIS_BRANCH&amp;quot; == &amp;quot;master&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;$TRAVIS_PULL_REQUEST&amp;quot; == &amp;quot;false&amp;quot; ]; then
    docker login -u=&amp;quot;$DOCKER_USER&amp;quot; -p=&amp;quot;$DOCKER_PASS&amp;quot;
    TAG=$(grep &amp;quot;ENV MYSQL_VERSION&amp;quot; Dockerfile | awk &#39;NF&amp;gt;1{print $NF}&#39;)
    docker tag hypriot/rpi-mysql hypriot/rpi-mysql:$TAG
    docker push hypriot/rpi-mysql:$TAG
    docker push hypriot/rpi-mysql
  fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference to an Intel build is to just register QEMU here. The rest is activating Docker builds and do a simple docker build, test, push of that image.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;You only have to remember two things to let the cloud build your ARM images:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FROM resin/rpi-raspbian&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run --rm --privileged multiarch/qemu-user-static:register --reset&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are using this setup for more and more GitHub repos to gain speed and respond to pull requests much faster.&lt;/p&gt;

&lt;p&gt;For example we also are using &lt;a href=&#34;https://github.com/hypriot/rpi-node/blob/33d6ea9bebeca9bf31abac1b5dbc66a9f9902184/.travis.yml#L5-L8&#34;&gt;matrix builds&lt;/a&gt; for all major versions of Node.js to build new Docker images with Travis.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker is supported on the $9 C.H.I.P. computer</title>
      <link>https://blog.hypriot.com/post/docker-supported-on-chip-computer/</link>
      <pubDate>Sun, 11 Dec 2016 13:22:15 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/docker-supported-on-chip-computer/</guid>
      <description>&lt;p&gt;I guess you&amp;rsquo;re already knowing, one of the cheapest but powerful ARM boards is the $9 C.H.I.P. computer from Next Thing Co. &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt;. It has an ARMv7 1GHz CPU with 512 MByte of main memory, 4 GByte flash memory as disk storage and is equipped with onboard WiFi and bluetooth as well.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-photo2.jpg&#34; alt=&#34;chip-photo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Some time ago I wrote a detailed blog post about how to &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt; with the help of a custom Linux kernel which I built from source for this purpose and included all the necessary kernel modules which are required to run Docker. As an outlook I mentioned that one of the kernel developers from &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt;, namely Wynter Woods &lt;a href=&#34;https://twitter.com/zerotri&#34;&gt;@zerotri&lt;/a&gt;, is working to support Docker officially.&lt;/p&gt;

&lt;p&gt;Kernel development and testing takes time and finally here it is!&lt;br&gt;
&lt;strong&gt;Docker is running on the C.H.I.P. with their latest standard kernel!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-and-banana.jpg&#34; alt=&#34;chip-and-banana&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;short-overview&#34;&gt;Short overview&lt;/h3&gt;

&lt;p&gt;With the new Docker-enabled Linux kernel for the C.H.I.P. it&amp;rsquo;s really easy to install and use Docker on these tiny cute ARM devices. Basically you just have to update/upgrade to the latest software packages through the standard &lt;code&gt;apt&lt;/code&gt; package management commands, have to install Docker and you&amp;rsquo;re good to go.&lt;/p&gt;

&lt;p&gt;As I&amp;rsquo;ve already covered all these steps in detail in my post &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt;, we can take a shortcut and I&amp;rsquo;m explaining only the new and shorter steps.&lt;/p&gt;

&lt;h3 id=&#34;necessary-steps-to-install-docker&#34;&gt;Necessary steps to install Docker&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Flash the latest available firmware (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Connect to the C.H.I.P. via USB or UART console cable (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Configure WiFi connection (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Configure SSH to access the C.H.I.P. (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Checking the OS and Linux kernel version&lt;/li&gt;
&lt;li&gt;Upgrade the Linux kernel and operating system&lt;/li&gt;
&lt;li&gt;Install the Docker Engine the official way&lt;/li&gt;
&lt;li&gt;Run your first Docker Container on the C.H.I.P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;step-5-checking-the-os-and-linux-kernel-version&#34;&gt;Step 5: Checking the OS and Linux kernel version&lt;/h4&gt;

&lt;p&gt;Here I&amp;rsquo;ve flashed the C.H.I.P. with the latest available firmware&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.13-ntc-mlc #1 SMP Thu Nov 3 01:28:54 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we can see it&amp;rsquo;s running a Linux kernel version &lt;code&gt;4.4.13-ntc-mlc&lt;/code&gt; which is compiled at &lt;code&gt;Thu Nov 3 01:28:54 UTC 2016&lt;/code&gt;. If you&amp;rsquo;ve flashed your device weeks or months before, you could maybe see a different and older kernel version.&lt;/p&gt;

&lt;h4 id=&#34;step-6-upgrade-the-linux-kernel-and-operating-system&#34;&gt;Step 6: Upgrade the Linux kernel and operating system&lt;/h4&gt;

&lt;p&gt;The new Docker-enabled Linux kernel for the C.H.I.P. computer is already available in the standard APT package repository, but it&amp;rsquo;s not yet included in the latest firmware you can flash with the &lt;a href=&#34;http://flash.getchip.com/&#34;&gt;C.H.I.P. Flasher&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In order to update/upgrade the C.H.I.P. kernel we are going the easy way and performing a complete update and upgrade process of the operating system as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update
apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see on the &lt;code&gt;apt-get upgrade&lt;/code&gt; command, you&amp;rsquo;ll be asked to confirm to install a few new software packages which also includes the new kernel packages.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
The following packages will be upgraded:
  apt apt-utils base-files chip-mali-modules-4.4.13-ntc-mlc cpio dmsetup dpkg e2fslibs e2fsprogs
  gnupg gpgv libapt-inst1.5 libapt-pkg4.12 libc-bin libc6 libcomerr2 libdevmapper1.02.1
  libdns-export100 libgcrypt20 libhogweed2 libicu52 libidn11 libirs-export91 libisc-export95
  libisccfg-export90 libnettle4 libpam-modules libpam-modules-bin libpam0g libpcre3 libss2
  libtasn1-6 libudev1 linux-image-4.4.13-ntc-mlc multiarch-support
  rtl8723bs-mp-driver-modules-4.4.13-ntc-mlc tar tzdata udev vim-common vim-tiny wget
42 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Need to get 39.8 MB of archives.
After this operation, 8562 kB of additional disk space will be used.
Do you want to continue? [Y/n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of the upgrade you have to reboot the device in order to boot the new Linux kernel. That&amp;rsquo;s all, really!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you log in again, you can see&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.13-ntc-mlc #1 SMP Tue Dec 6 21:38:00 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the new Linux kernel has the same version, but a newer build time from &lt;code&gt;Tue Dec 6 21:38:00 UTC 2016&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;step-6-install-the-docker-engine-the-official-way&#34;&gt;Step 6: Install the Docker Engine the official way&lt;/h4&gt;

&lt;p&gt;To install Docker the official way is quite easy today because we can use the APT packages and install scripts directly provided by the &lt;a href=&#34;https://github.com/docker/docker&#34;&gt;Docker project&lt;/a&gt;. And Debian for ARMv7 is one of the officially supported OS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://get.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will take some time, but after a while the Docker Engine is installed on your C.H.I.P. computer with just a few commands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/apt/sources.list.d/docker.list
deb [arch=armhf] https://apt.dockerproject.org/repo debian-jessie main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the version of the Docker client command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker --version
Docker version 1.12.2, build bb80604
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the versions of the Docker client, Docker API and Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker version
Client:
 Version:      1.12.2
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   bb80604
 Built:        Tue Oct 11 17:52:51 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.2
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   bb80604
 Built:        Tue Oct 11 17:52:51 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get some more details about the running Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.12.2
Storage Driver: devicemapper
 Pool Name: docker-0:16-33578-pool
 Pool Blocksize: 65.54 kB
 Base Device Size: 10.74 GB
 Backing Filesystem: ext4
 Data file: /dev/loop0
 Metadata file: /dev/loop1
 Data Space Used: 305.7 MB
 Data Space Total: 107.4 GB
 Data Space Available: 6.596 GB
 Metadata Space Used: 729.1 kB
 Metadata Space Total: 2.147 GB
 Metadata Space Available: 2.147 GB
 Thin Pool Minimum Free Space: 10.74 GB
 Udev Sync Supported: true
 Deferred Removal Enabled: false
 Deferred Deletion Enabled: false
 Deferred Deleted Device Count: 0
 Data loop file: /var/lib/docker/devicemapper/devicemapper/data
 WARNING: Usage of loopback devices is strongly discouraged for production use. Use `--storage-opt dm.thinpooldev` to specify a custom block storage device.
 Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata
 Library Version: 1.02.90 (2014-09-01)
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: overlay bridge null host
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Security Options:
Kernel Version: 4.4.13-ntc-mlc
Operating System: Debian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 1
Total Memory: 491 MiB
Name: chip
ID: Z7U2:2DYF:G54F:2QLU:AAG3:TD7Y:YWSQ:6PRM:6ZW3:WIC5:7DEA:HFFK
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
WARNING: No swap limit support
WARNING: No kernel memory limit support
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we could see, the latest Docker Engine v1.12.2 for Debian/ARMv7 is now installed and is successfully running.&lt;/p&gt;

&lt;h4 id=&#34;step-8-run-your-first-docker-container-on-the-c-h-i-p&#34;&gt;Step 8: Run your first Docker Container on the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;As a last step we&amp;rsquo;d like to start a first Docker container, a small web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
fec2773baaec570ba8b6e00296dfd11b4b4768d1b51e574d851968b9225b9d22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start your web browser and point it to the website from our Docker container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open http://192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/first-container-on-chip.jpg&#34; alt=&#34;first-container-on-chip&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;using-latest-rc-of-docker-engine&#34;&gt;Using latest RC of Docker Engine&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to get the latest Docker Engine for testing, like release candidates, you can install it pretty easily with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://test.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can upgrade your current system with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#edit /etc/apt/sources.list.d/docker.list # change &#39;main&#39; to &#39;testing&#39;
cat /etc/apt/sources.list.d/docker.list
deb [arch=armhf] https://apt.dockerproject.org/repo debian-jessie testing

apt-get update
apt-get install -y docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can test the latest available release candidate of the Docker Engine with all the newest features with Docker Swarm mode and other goodies.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker version
Client:
 Version:      1.13.0-rc3
 API version:  1.25
 Go version:   go1.7.3
 Git commit:   4d92237
 Built:        Mon Dec  5 19:00:08 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.13.0-rc3
 API version:  1.25 (minimum version 1.12)
 Go version:   go1.7.3
 Git commit:   4d92237
 Built:        Mon Dec  5 19:00:08 2016
 OS/Arch:      linux/arm
 Experimental: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tl-dr-install-docker-on-the-c-h-i-p-computer&#34;&gt;TL;DR - Install Docker on the C.H.I.P. computer&lt;/h3&gt;

&lt;p&gt;For all the impatient users, these are the minimal steps to install the latest Linux kernel and the latest Docker Engine on the C.H.I.P. computer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update
apt-get upgrade -y
reboot
curl -sSL https://get.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DONE !!!!&lt;/p&gt;

&lt;h3 id=&#34;acknowledgments&#34;&gt;Acknowledgments&lt;/h3&gt;

&lt;p&gt;Again, I like to thank Wynter Woods &lt;a href=&#34;https://twitter.com/zerotri&#34;&gt;@zerotri&lt;/a&gt; from &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt; for his efforts and hard work to include all the Linux kernel changes necessary to run the Docker Engine pretty slick on the C.H.I.P. computer. It&amp;rsquo;s so great to see when all the changes will be accepted and implemented in the upstream version, so everybody can use the new features without spending too much time.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s the important point to work in opensource, contributing back so that all users benefit from the results!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fix Dirty COW on Raspberry Pi the Docker way</title>
      <link>https://blog.hypriot.com/post/fix-dirty-cow-on-raspberry-pi/</link>
      <pubDate>Tue, 01 Nov 2016 13:42:20 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/fix-dirty-cow-on-raspberry-pi/</guid>
      <description>&lt;p&gt;Have you seen the latest reports about the Linux kernel security vulnerability called &amp;ldquo;Dirty COW&amp;rdquo;?
Dirty COW is a &lt;a href=&#34;http://www.theregister.co.uk/2016/10/21/linux_privilege_escalation_hole/&#34;&gt;race condition in Linux&lt;/a&gt; arising from how Copy-On-Write (the COW in the name) is handled by the kernel&amp;rsquo;s memory subsystem&amp;rsquo;s use of private mappings.&lt;/p&gt;

&lt;p&gt;The really dangerous point here is, it can be used to &lt;a href=&#34;http://www.theregister.co.uk/2016/11/01/docker_user_havent_patched_dirty_cow_yet_bad_news/&#34;&gt;escape Docker containers&lt;/a&gt;.
&lt;img src=&#34;https://blog.hypriot.com/images/fix-dirty-cow-on-raspberry-pi/dirty-cow-001.jpg&#34; alt=&#34;dirty-cow-001&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, we&amp;rsquo;re encourage you to immediately fix it with upgrading your Linux kernel on the Raspberry Pi !!!&lt;/p&gt;

&lt;p&gt;No matter if you&amp;rsquo;re running an official Raspbian or HypriotOS, please upgrade your Linux kernel to be safe again&amp;hellip;
&lt;/p&gt;

&lt;h3 id=&#34;tl-dr-fast-fixing&#34;&gt;TL;DR - Fast Fixing&lt;/h3&gt;

&lt;p&gt;For all the impatient users, here are the essential steps to upgrade your Linux kernel in an easy way on your Raspberry Pi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS&lt;/strong&gt; and &lt;strong&gt;Raspbian Jessie&lt;/strong&gt; (more details can be found &lt;a href=&#34;https://www.raspberrypi.org/blog/#fix-dirty-cow-raspberry-pi&#34;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For both operating systems it requires a system reboot to exchange the running Linux kernel in memory. But once you&amp;rsquo;ve done these easy steps you have successfully fixed the Dirty COW vulnerability.&lt;/p&gt;

&lt;h3 id=&#34;testing-for-dirty-cow-with-the-help-of-docker&#34;&gt;Testing for Dirty COW with the help of Docker&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to know whether your system is vulnerable against Dirty COW you can easily run a test with the help of a Docker Image. The complete source code can be found in my Github repo &lt;a href=&#34;https://github.com/DieterReuter/rpi-dirtycow&#34;&gt;DieterReuter/rpi-dirtycow&lt;/a&gt;, so you can build everything on your own, too.&lt;/p&gt;

&lt;p&gt;Running this single command is just absolutely easy and this is one of the benefits of Docker, you don&amp;rsquo;t have to install anything on your host machine. Just run a Docker container in a secure way and get instant results within seconds.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s do some testing on two different operating systems for the Raspberry Pi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Raspbian Jessie LITE (2016-09-23)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve used a freshly installed Raspbian Lite for these tests and you can see, we do have a Linux kernel 4.4.21.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux raspberrypi 4.4.21-v7+ #911 SMP Thu Sep 15 14:22:38 BST 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t have the Docker Engine already installed on Raspbian, you can perform it with this few commands - YEAH, it&amp;rsquo;s just so easy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sSL https://get.docker.com | bash
$ sudo usermod -aG docker pi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, logout and login again to get access to the Docker CLI from your default &amp;ldquo;pi&amp;rdquo; user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker --version
Docker version 1.12.3, build 6b644ec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have Docker installed, we can test against Dirty COW.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm hypriot/rpi-dirtycow
Unable to find image &#39;hypriot/rpi-dirtycow:latest&#39; locally
latest: Pulling from hypriot/rpi-dirtycow
38070c4d0c33: Pull complete
a3ed95caeb02: Pull complete
2d2e2d46b9b5: Pull complete
Digest: sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Status: Downloaded newer image for hypriot/rpi-dirtycow:latest

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are VULNERABLE!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s upgrade the Linux kernel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;ll test it again. Hopefully we&amp;rsquo;ve fixed it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux raspberrypi 4.4.26-v7+ #915 SMP Thu Oct 20 17:08:44 BST 2016 armv7l GNU/Linux

$ docker run --rm hypriot/rpi-dirtycow

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are SAFE!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New Linux kernel 4.4.26 is installed for Raspbian and Dirty COW is fixed!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Did you mentioned the different output from the &lt;code&gt;docker run&lt;/code&gt; commands? The first time, Docker has detected that the Docker Image &amp;ldquo;hypriot/rpi-dirtycow&amp;rdquo; is not on the machine and downloads/pulls the required image layers. The second time it can just start the Docker container.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS 1.1.0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;m using the latest HypriotOS 1.1.0 release, but the Linux kernel upgrade works even for an older 0.8 release.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux black-pearl 4.4.24-hypriotos-v7+ #1 SMP PREEMPT Tue Oct 11 17:15:58 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test for Dirty COW.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time docker run --rm hypriot/rpi-dirtycow
Unable to find image &#39;hypriot/rpi-dirtycow:latest&#39; locally
latest: Pulling from hypriot/rpi-dirtycow
38070c4d0c33: Pull complete
a3ed95caeb02: Pull complete
2d2e2d46b9b5: Pull complete
Digest: sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Status: Downloaded newer image for hypriot/rpi-dirtycow:latest

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are VULNERABLE!!!

real	0m14.514s
user	0m0.200s
sys	0m0.180s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You can see, it takes just under 15 seconds to pull the Docker Image and to perform the test against the Dirty COW vulnerability. We didn&amp;rsquo;t installed anything on the host machine for these tests and we can get rid of the Docker image later on and clean our host system easily.&lt;/p&gt;

&lt;p&gt;Upgrade the Linux kernel for HypriotOS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we have the latest Linux kernel 4.4.27 for HypriotOS installed and we&amp;rsquo;re safe again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux black-pearl 4.4.27-hypriotos-v7+ #1 SMP PREEMPT Fri Oct 28 09:06:49 UTC 2016 armv7l GNU/Linux

$ time docker run --rm hypriot/rpi-dirtycow

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are SAFE!

real	0m4.504s
user	0m0.100s
sys	0m0.050s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we&amp;rsquo;ll remove the Docker Image we&amp;rsquo;ve used for the tests and free some disk space.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
hypriot/rpi-dirtycow   latest              31229be9ea1d        3 days ago          5.512 MB

$ docker rmi -f 31229be9ea1d
Untagged: hypriot/rpi-dirtycow:latest
Untagged: hypriot/rpi-dirtycow@sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Deleted: sha256:31229be9ea1d01ed2df47cc23ab50efdc84be3b49572bb4b6047a449dea4e596

$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This is another great advantage by Docker - get rid of all the tools we don&amp;rsquo;t need anymore.&lt;/p&gt;

&lt;h3 id=&#34;conclusion-upgrade-your-system-regularly&#34;&gt;Conclusion: upgrade your system regularly&lt;/h3&gt;

&lt;p&gt;Your Raspberry Pi system is now SAFE again. In the future don&amp;rsquo;t forget to upgrade it from time to time. On both operating systems, Raspbian and HypriotOS, you can do the upgrade procedure with these few commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with this way you&amp;rsquo;ll get some other tools updated as well, like the Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker version
Client:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 19:06:36 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 19:06:36 2016
 OS/Arch:      linux/arm
HypriotOS/armv7: pirate@black-pearl in ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all and STAY SAFE !!!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Visualize your Raspberry Pi containers with Portainer or UI for Docker</title>
      <link>https://blog.hypriot.com/post/new-docker-ui-portainer/</link>
      <pubDate>Mon, 31 Oct 2016 15:18:33 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/new-docker-ui-portainer/</guid>
      <description>&lt;p&gt;At home I use some Raspberry Pi&amp;rsquo;s for some home network services, and I run
these services inside Docker containers. From time to time I want to see or
manage one of these containers. But I&amp;rsquo;m too lazy to get to my laptop and use
the Docker CLI for that. There are two nice Docker UI&amp;rsquo;s to access your Docker engine with a web browser. Let&amp;rsquo;s have a look at both.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-docker.png&#34; alt=&#34;Portainer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;ui-for-docker-formerly-known-as-dockerui&#34;&gt;UI for Docker, formerly known as DockerUI&lt;/h2&gt;

&lt;p&gt;I have started using the DockerUI, an open source project from Michael Crosby and Kevan Ahlquist. You can find the source code on GitHub at &lt;a href=&#34;https://github.com/kevana/ui-for-docker&#34;&gt;https://github.com/kevana/ui-for-docker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://github.com/StefanScherer/docker-at-home/blob/eb451b954809393e8536259aff6daf27bfb7b7b8/docker-compose.yml#L27-L35&#34;&gt;my home setup&lt;/a&gt; I use Docker Compose to configure how to run my services.&lt;/p&gt;

&lt;p&gt;This is my configuration to start the UI so I can reach it on port 80 of the Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ui:
  image: hypriot/rpi-dockerui
  restart: always
  volumes:
    - &#39;/var/run/docker.sock:/var/run/docker.sock&#39;
  expose:
    - 9000
  ports:
    - 80:9000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we provide a Docker image &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-dockerui/&#34;&gt;hypriot/rpi-dockerui&lt;/a&gt; on the Docker hub so it is very easy to use it in your environment.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look at the dashboard which shows you an overview of your running or stopped containers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-dashboard.png&#34; alt=&#34;DockerUI Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can click on each container and see more details and so some actions with them like stopping and starting them again.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-container.png&#34; alt=&#34;DockerUI Container&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The UI provides some more views to list for example all local Docker images and information about your Docker engine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-images.png&#34; alt=&#34;DockerUI Images&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;portainer&#34;&gt;Portainer&lt;/h2&gt;

&lt;p&gt;Last week I found &lt;a href=&#34;http://portainer.io&#34;&gt;portainer.io&lt;/a&gt; which also looks very good. They provide Docker images for Linux and Windows, &lt;del&gt;but not for ARM right now&lt;/del&gt; and as well an image for ARM.&lt;/p&gt;

&lt;p&gt;The source code is also available on GitHub &lt;a href=&#34;https://github.com/portainer/portainer&#34;&gt;https://github.com/portainer/portainer&lt;/a&gt; and it&amp;rsquo;s based on the work of DockerUI.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/portainer/portainer/pull/299&#34;&gt;pull request&lt;/a&gt; to add Linux ARM support was merged and now you can get the Docker image for the Rapsberry Pi using the image &lt;a href=&#34;https://hub.docker.com/r/portainer/portainer/&#34;&gt;portainer/portainer:arm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Just use the same Docker Compose sample from above and replace the image name. Killing the old container and running a new one with &lt;code&gt;docker-compose up -d ui&lt;/code&gt; you have Portainer up and running.&lt;/p&gt;

&lt;p&gt;The dashboard also gives you an overview of all running containers, all images etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-dashboard.png&#34; alt=&#34;Portainer Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the container list you can see all running and stopped containers as well as some actions you can do with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-container.png&#34; alt=&#34;Portainer Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clicking on one of the running containers you have access to the details, environment variables, port mappings, volumes.
You can also access some CPU/memory and network statistics as well as the logs of your container, as well as the processes running inside the container.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-stats.png&#34; alt=&#34;Portainer Stats&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you want to remote control your Raspberry Pi Docker containers from a nice Web UI, then try
one of these prebuilt Docker images. Of course be aware that everyone in your home network
is able to manipulate your Docker containers with it as there is no login dialog.
But for some private projects it is still an advantage to simplify starting and stopping containers from your mobile phone.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Testing High Availability of Docker Swarm on a Raspberry Pi Cluster (Updated)</title>
      <link>https://blog.hypriot.com/post/high-availability-with-docker/</link>
      <pubDate>Wed, 26 Oct 2016 18:03:34 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/high-availability-with-docker/</guid>
      <description>&lt;p&gt;In its release in June this year, Docker announced two exciting news about the Docker Engine: First, the Engine 1.12 comes with built-in high availability features, called &amp;ldquo;Docker Swarm Mode&amp;rdquo;. And second, Docker started providing official support for the ARM architecture.&lt;/p&gt;

&lt;p&gt;These two news combined beg for testing the new capabilities in reality.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/high-availability-docker-swarm.png&#34; alt=&#34;SwarmClusterHA&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;old&amp;rdquo; Docker Swarm already offered some high availability features, but the new called &amp;ldquo;Swarm Mode&amp;rdquo; goes far beyond: To me, the most important capabilities to mention are: built-in security, rolling updates and - maybe one of the most important benefits - super user-friendliness. Production ready clustering based on powerful container technology has probably never been easier before.&lt;/p&gt;

&lt;p&gt;Also, the release of Docker 1.12 comes with official support for the ARM architecture. Running Docker on ARM has been possible for long time, but now, users can install it the same way on their Raspberry Pis as they do it on any other architecture: Using Docker&amp;rsquo;s official repositories. If you are one of our regular readers, you know that our team at Hypriot intensively collaborated with Docker to make this official support possible. So we are also very happy that this huge milestone that many people asked for is eventually checked!&lt;/p&gt;

&lt;p&gt;Now, with these two news, let&amp;rsquo;s get our hands dirty and test if the announced promises hold.&lt;/p&gt;

&lt;h2 id=&#34;setup-the-cluster&#34;&gt;Setup the cluster&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;As hardware&lt;/strong&gt;, I have 5x Raspberry Pi 3, connected in a network with Internet access.&lt;/p&gt;

&lt;p&gt;The Raspberry Pis with their SD cards, the network switch, power input and all cables live in a &lt;a href=&#34;https://www.picocluster.com/collections/starter-picocluster-kits/products/pico-5-raspberry-pi-starter-kit?variant=29344698892&#34;&gt;hardware kit from PicoCluster&lt;/a&gt;. Thanks to PicoCluster for providing the kit to us for testing!&lt;/p&gt;

&lt;p&gt;See how the cluster looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/PicoCluster.jpg&#34; alt=&#34;PicoClusterBuilt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;As software&lt;/strong&gt;, I chose HypriotOS. I also tried Raspbian, but it requires a large system upgrade after the first boot in order to provide all features required by Docker (e.g. VXLAN kernel module). Before and after the system upgrade, I also had to run &lt;a href=&#34;https://github.com/docker/docker/blob/master/contrib/check-config.sh&#34;&gt;Docker&amp;rsquo;s test script&lt;/a&gt; to make sure everything is ok. All of this is not a big deal, but if there is an OS available that comes out of the box with all that Docker needs (and even adds lots of useful optimizations), it simply saves time and provides a hassle-free experience. So I flashed all SD cards with HypriotOS using our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;To connect to the cluster&lt;/strong&gt;, I SSHed into all the nodes via &lt;a href=&#34;http://gnometerminator.blogspot.de/p/introduction.html&#34;&gt;Terminator&lt;/a&gt;. Terminator is my preferred tool to organize multiple terminals in a single window. It allows to send commands to several terminals at once. Soon, I&amp;rsquo;ll have a look at tmux and might switch, but for now I recommend Terminator :)&lt;/p&gt;

&lt;p&gt;Finally, we have 5 terminals opened, all waiting for commands as you see in the following image. Please don&amp;rsquo;t care about the commands running in each terminal for now.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/terminal.png&#34; alt=&#34;Terminator&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all to do before getting our hands on Docker itself!&lt;/p&gt;

&lt;h2 id=&#34;setup-docker-swarm-on-the-cluster&#34;&gt;Setup Docker Swarm on the cluster&lt;/h2&gt;

&lt;p&gt;On HypriotOS, you&amp;rsquo;ll have the latest Docker installed, so we can instantly start playing.&lt;/p&gt;

&lt;p&gt;On an arbitrary node of the cluster, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker swarm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output should look similar to that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Swarm initialized: current node (node-master) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-1acm9qa7b0hmzz5v8t40d75v5fsgckeu2z5ds6ls0x7cny7l8p-307wqrc8756akpxjxls9abbbs \
    [2a02:810d:8600:2a78:f6c6:d67d:6912:17ca]:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As explained in this output, now you need to run the presented &lt;code&gt;docker swarm join ...&lt;/code&gt; command on all other nodes, which you want to join the cluster.&lt;/p&gt;

&lt;p&gt;Finally, on the node at which you executed &lt;code&gt;docker swarm init&lt;/code&gt;, check if all nodes of your cluster successfully formed a swarm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker node ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the terminal prints a list of all nodes of your cluster, the setup is all done! Forming a cluster cannot be easier, can it?&lt;/p&gt;

&lt;h2 id=&#34;execution-of-tests&#34;&gt;Execution of tests&lt;/h2&gt;

&lt;p&gt;My tests of Docker&amp;rsquo;s ability to recover from failures comprise the following use cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The ethernet interface of a random node (master or slave) got unavailable&lt;/li&gt;
&lt;li&gt;A random node completely rebooted&lt;/li&gt;
&lt;li&gt;A random node instantly crashed (unplug power source)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I documented one of the test runs in the following screencast.&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;iframe src=&#34;https://player.vimeo.com/video/185361173&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&#34;https://vimeo.com/185361173&#34;&gt;Testing High Availability Docker Swarm Mode&lt;/a&gt; from &lt;a href=&#34;https://vimeo.com/user54109827&#34;&gt;Mathias Renner&lt;/a&gt; on &lt;a href=&#34;https://vimeo.com&#34;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;results&#34;&gt;Results&lt;/h2&gt;

&lt;p&gt;As shown in the screencast, Docker is able to recover from failure of the ethernet interface. After testing the other use cases later on, Docker recovered flawlessly from a reboot and crash as well. Note that this also holds for master nodes, not only for slave nodes! This is remarkable because in contrast to slave nodes, master nodes hold important data of the cluster state. A master nodes&amp;rsquo;s outage is critical for the health of the cluster. With e.g. &lt;a href=&#34;https://github.com/luxas/kubernetes-on-arm&#34;&gt;Kubernetes-on-arm&lt;/a&gt;, the cluster does not recover after rebooting or crashing a master node.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Edit on 6.11.2016&lt;/strong&gt;: Jérémy Derussé and Nikolay Kushin reported in the discussion below that for them a reboot or crash of a node did not result in a healthy cluster state after bringing up the node again. As of today, unfortunately I can confirm this, with Docker version 1.12.1, 1.12.2 as well as 1.12.3. I cannot explain why during my tests for this post a crashed node recovered smoothly.&lt;/p&gt;

&lt;p&gt;Based on Jeremy&amp;rsquo;s report, I was able to create a quick fix for this issue. On a node, simply run:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;sudo crontab -e&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There, insert the following line (without quotation marks) and save the file.&lt;/p&gt;

&lt;p&gt;&amp;rdquo;@reboot docker ps&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Having this configured, after a crash or reboot the node recovered correctly in my tests. I look forward for feedback about this issue! Please use the discussion below.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;more-to-come-soon&#34;&gt;More to come soon&lt;/h2&gt;

&lt;p&gt;This post is only a small chunk of the data I gathered during the tests. The next option to get the details is during my talk at the &lt;a href=&#34;http://highload.co/&#34;&gt;HighLoad++ Conference&lt;/a&gt; in Moskow, Russia. I&amp;rsquo;d be happy if you can make it there!&lt;/p&gt;

&lt;p&gt;Also, this is not the end of the story of course. Thorough testing requires also measuring incoming requests from an external load tester to the cluster while a failure occurs. After some research, I have not found any evidence that someone has ever performed that tests (please correct me if I&amp;rsquo;m wrong!).&lt;/p&gt;

&lt;p&gt;Moreover, Kubernetes received much attention lately since its support for ARM became better and better. So wouldn&amp;rsquo;t it be interesting to see if Docker or Kubernetes is better in keeping a service available and performing well, even if there are outages in the cluster?&lt;/p&gt;

&lt;p&gt;So there&amp;rsquo;s more coming soon, just stay tuned for the upcoming posts :)&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Deploying an IoT Swarm with Docker Machine</title>
      <link>https://blog.hypriot.com/post/deploy-swarm-on-chip-with-docker-machine/</link>
      <pubDate>Sun, 04 Sep 2016 19:45:58 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/deploy-swarm-on-chip-with-docker-machine/</guid>
      <description>&lt;p&gt;With the new SwarmMode in Docker 1.12 it is really damn easy to build a Docker Swarm and connect different ARM devices to an IoT cluster.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-flashing1.jpg&#34; alt=&#34;swarm-chip-flashing1.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s connect a few of the $9 C.H.I.P. computers and a Raspberry Pi Zero all through a WiFi network&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;step-1-install-docker-machine&#34;&gt;Step 1: Install Docker Machine&lt;/h4&gt;

&lt;p&gt;First of all, we need to make sure we do have Docker Machine installed on our local computer. I&amp;rsquo;m using a Mac for this tutorial, but you can use Docker Machine on Linux or Windows too. If not already done, you should install the latest Docker Machine binary following the &lt;a href=&#34;https://docs.docker.com/machine/install-machine/&#34;&gt;Install Docker Machine&lt;/a&gt; instructions.&lt;/p&gt;

&lt;p&gt;You can easily check the version of Docker Machine with the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine --version
docker-machine version 0.8.0, build b85aac1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-2-prepare-all-c-h-i-p-s-with-docker-machine&#34;&gt;Step 2: Prepare all C.H.I.P.&amp;rsquo;s with Docker Machine&lt;/h4&gt;

&lt;p&gt;In order to connect a couple of C.H.I.P. computers to a Docker Swarm cluster, we have to install Docker 1.12.1 first. This can be done easily by following the steps of my last tutorial &lt;a href=&#34;https://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt;. Then we&amp;rsquo;re using the standard Docker Machine from a Mac to attach each C.H.I.P. device via a secured Docker API port and give each device an individual hostname on the network. With the help of Docker Machine it&amp;rsquo;s easier to access all the C.H.I.P. devices we&amp;rsquo;d like to connect to the Swarm cluster from a Mac, Linux or Windows machine.&lt;/p&gt;

&lt;p&gt;Here are the basic steps we have to follow for each single C.H.I.P. computer:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;flash C.H.I.P. and install Docker 1.12.1&lt;/li&gt;
&lt;li&gt;detect the IP address and use Docker Machine&lt;/li&gt;
&lt;li&gt;restart Avahi daemon or reboot C.H.I.P.&lt;/li&gt;
&lt;li&gt;check the device connectivity via network and Docker API&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Flashing the C.H.I.P. computer in FEL mode with UART console cable attached: &lt;br&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-flashing2.jpg&#34; alt=&#34;swarm-chip-flashing2.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As soon as we&amp;rsquo;ve installed our first C.H.I.P. with Docker we&amp;rsquo;ll use its IP address and run &lt;code&gt;docker-machine create&lt;/code&gt; and let&amp;rsquo;s do some Docker magic and we have secured the network access to its Docker Engine easily. In this command I&amp;rsquo;m using the flag &lt;code&gt;--debug&lt;/code&gt; to get a more verbose output, so you can see all the details whats going on in the background, but you can omit this flag for the remaining C.H.I.P.&amp;rsquo;s.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CHIP_IP_ADDRESS=192.168.2.112
CHIP_NODENAME=swarm-chip01

docker-machine --debug create \
  --driver=generic \
  --engine-storage-driver=overlay \
  --generic-ip-address=$CHIP_IP_ADDRESS \
  $CHIP_NODENAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After successfully running this command, the C.H.I.P. device is attached to Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME           ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01   -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the C.H.I.P. itself you can see that the hostname has changed. So let&amp;rsquo;s check this in detail to get a better understanding what&amp;rsquo;s happening behind the scene. Now we&amp;rsquo;re using some Docker Machine fu to connect to the device.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01
root@swarm-chip01:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hostname has changed to &lt;code&gt;swarm-chip01&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/hostname
swarm-chip01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so there is a new local loopback address included as &lt;code&gt;127.0.1.1 swarm-chip01&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/hosts
127.0.0.1      	chip
127.0.0.1      	localhost
::1    		localhost ip6-localhost ip6-loopback
ff02::1		ip6-allnodes
ff02::2		ip6-allrouters

127.0.1.1 swarm-chip01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check if we can reach the C.H.I.P. from the network with its new hostname.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-chip01.local
ping: cannot resolve swarm-chip01.local: Unknown host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately the Avahi service discovery daemon didn&amp;rsquo;t changed the hostname, so we have to restart it manually to get the changes in order to reach the C.H.I.P. with it&amp;rsquo;s new hostname from the WiFi network. Alternatively we can just reboot the C.H.I.P. to activate these changes. So let&amp;rsquo;s do it through Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 systemctl restart avahi-daemon.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And check with ping again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-chip01.local
PING swarm-chip01.local (192.168.2.112): 56 data bytes
64 bytes from 192.168.2.112: icmp_seq=0 ttl=64 time=105.129 ms
64 bytes from 192.168.2.112: icmp_seq=1 ttl=64 time=3.529 ms
64 bytes from 192.168.2.112: icmp_seq=2 ttl=64 time=48.178 ms

--- swarm-chip01.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 3.529/52.279/105.129/41.579 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s up to you to repeat these steps for all the remaining C.H.I.P. devices. After some time you should be ready and having a list of devices connected to Docker Machine. I&amp;rsquo;ve done this with six C.H.I.P.&amp;rsquo;s, and one of them is an Alpha unit which works exactly the same way without any differences.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME            ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01    -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
swarm-chip02    -        generic   Running   tcp://192.168.2.116:2376           v1.12.1
swarm-chip03    -        generic   Running   tcp://192.168.2.117:2376           v1.12.1
swarm-chip04    -        generic   Running   tcp://192.168.2.118:2376           v1.12.1
swarm-chip05    -        generic   Running   tcp://192.168.2.120:2376           v1.12.1
swarm-chip06    -        generic   Running   tcp://192.168.2.104:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-3-initialize-the-swarm-create-a-swarm-manager&#34;&gt;Step 3: Initialize the Swarm, create a Swarm manager&lt;/h4&gt;

&lt;p&gt;As soon as all the C.H.I.P.&amp;rsquo;s are prepared we are able to initiate a Swarm cluster. We are creating a Swarm manager first and then we can attach the other C.H.I.P.&amp;rsquo;s as additional Swarm managers or Swarm workers pretty easily. All the steps to form a Swarm cluster are literally a single command per device only!&lt;/p&gt;

&lt;p&gt;With this command the Swarm will be initialized.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker swarm init
Swarm initialized: current node (8174iszkmn4u4wwjogam8bsrw) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
    192.168.2.112:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we do have our first Swarm manager running.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
8174iszkmn4u4wwjogam8bsrw *  swarm-chip01  Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-4-set-up-swarm-for-high-availability-attach-more-swarm-managers&#34;&gt;Step 4: Set up Swarm for high-availability, attach more Swarm managers&lt;/h4&gt;

&lt;p&gt;In order to build a high-availability Swarm cluster, we like to join two additional Swarm managers. So, first we have to ask the Swarm Leader for an access token to join new Swarm managers. You have to know that the complete control traffic between Swarm nodes is secured by default.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
    192.168.2.112:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this given command we can now join the nodes &lt;code&gt;swarm-chip02&lt;/code&gt; and &lt;code&gt;swarm-chip02&lt;/code&gt; as Swarm managers with a single command for each of the nodes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip02 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
  192.168.2.112:2377
This node joined a swarm as a manager.

docker-machine ssh swarm-chip03 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
  192.168.2.112:2377
This node joined a swarm as a manager.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Swarm status and the list of all Swarm nodes can be determined by asking any of the three Swarm managers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1    swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw *  swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02  Ready   Active        Reachable
OSX: dieter@DietersMacBookPro in ~/code/github/hypriot/blog on deploy-swarm-on-chip-with-docker-machine

docker-machine ssh swarm-chip02 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1    swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw    swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c *  swarm-chip02  Ready   Active        Reachable
OSX: dieter@DietersMacBookPro in ~/code/github/hypriot/blog on deploy-swarm-on-chip-with-docker-machine

docker-machine ssh swarm-chip03 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1 *  swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw    swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02  Ready   Active        Reachable
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-5-let-s-grow-the-swarm-attach-all-swarm-workers&#34;&gt;Step 5: Let&amp;rsquo;s grow the Swarm, attach all Swarm workers&lt;/h4&gt;

&lt;p&gt;Now it&amp;rsquo;s time to join our remaining C.H.I.P. devices as Swarm workers to our Swarm cluster. For this purpose we just pick the token from the initial Swarm creation command. But if we can&amp;rsquo;t remember we can just ask one of the Swarm managers for the access token with the command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip02 docker swarm join-token worker
To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
    192.168.2.116:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s join our workers one by one now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip04 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.

docker-machine ssh swarm-chip05 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.

docker-machine ssh swarm-chip06 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a result we have joined all of the six C.H.I.P. devices to the Swarm cluster, three as Swarm managers and three as Swarm workers.&lt;/p&gt;

&lt;h4 id=&#34;step-6-attach-an-additional-pi-zero-as-swarm-worker&#34;&gt;Step 6: Attach an additional Pi Zero as Swarm worker&lt;/h4&gt;

&lt;p&gt;But we&amp;rsquo;re not limited in using only one kind of ARM devices for our Swarm cluster. So I&amp;rsquo;d like to add a different device, a Raspberry Pi Zero which is equipped with a &lt;a href=&#34;https://twitter.com/redbearlab&#34;&gt;RedBear IoT pHAT&lt;/a&gt; for WiFi/Bluetooth connectivity.
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-pi-zero.jpg&#34; alt=&#34;swarm-chip-pi-zero.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here you can see that using &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;HypriotOS for RPi&lt;/a&gt; and the Hypriot &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; it&amp;rsquo;s damn easy to create another ARM device with Docker 1.12.1 and attach it via WiFi to our network.&lt;/p&gt;

&lt;p&gt;Flash the SD card, and power up the Raspberry Pi Zero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n swarm-raspi01 -s &amp;quot;WLAN-R46VFR&amp;quot; -p &amp;quot;************&amp;quot; https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Determine the IP address of the Pi Zero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-raspi01.local
PING swarm-raspi01.local (192.168.2.119): 56 data bytes
64 bytes from 192.168.2.119: icmp_seq=0 ttl=64 time=617.658 ms
64 bytes from 192.168.2.119: icmp_seq=1 ttl=64 time=26.326 ms
64 bytes from 192.168.2.119: icmp_seq=2 ttl=64 time=1187.048 ms

--- swarm-raspi01.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 26.326/610.344/1187.048/473.891 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare SSH access to the Pi Zero, use username=&lt;code&gt;pirate&lt;/code&gt; and password=&lt;code&gt;hypriot&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -R 192.168.2.119
ssh-copy-id pirate@192.168.2.119
ssh pirate@192.168.2.119
uname -a
Linux swarm-raspi01 4.4.15-hypriotos+ #2 PREEMPT Mon Jul 25 09:18:11 UTC 2016 armv6l GNU/Linux
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Login and install a fix on the Pi so we can use the standard Docker Machine binary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@192.168.2.119
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/001-fix-docker-machine-1.8.0-create-for-arm/apply-fix-001.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back on our Mac we are able to run Docker Machine and attach the Raspi. As you can see, we do use another flag &lt;code&gt;--generic-ssh-user=pirate&lt;/code&gt; because we&amp;rsquo;re using a different username instead of the default &lt;code&gt;root&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RASPI_IP_ADDRESS=192.168.2.119
RASPI_NODENAME=swarm-raspi01

docker-machine --debug create \
  --driver=generic \
  --engine-storage-driver=overlay \
  --generic-ip-address=$RASPI_IP_ADDRESS \
  --generic-ssh-user=pirate \
  $RASPI_NODENAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few minutes only, the Raspberry Pi Zero can be accessed through Docker Machine with the exactly same methods and commands like the C.H.I.P. devices.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME            ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01    -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
swarm-chip02    -        generic   Running   tcp://192.168.2.116:2376           v1.12.1
swarm-chip03    -        generic   Running   tcp://192.168.2.117:2376           v1.12.1
swarm-chip04    -        generic   Running   tcp://192.168.2.118:2376           v1.12.1
swarm-chip05    -        generic   Running   tcp://192.168.2.120:2376           v1.12.1
swarm-chip06    -        generic   Running   tcp://192.168.2.104:2376           v1.12.1
swarm-raspi01   -        generic   Running   tcp://192.168.2.119:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we join our last Swarm worker, a lonely Raspberry Pi Zero running HypriotOS 1.0.1 and Docker 1.12.1, to the Swarm cluster.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-raspi01 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-7-check-the-complete-swarm&#34;&gt;Step 7: Check the complete Swarm&lt;/h4&gt;

&lt;p&gt;With the &lt;code&gt;docker node ls&lt;/code&gt; command issued on any of the Swarm managers we can list all the Swarm nodes, get their roles and status shown in the printed output on our terminal window.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip03 docker node ls
ID                           HOSTNAME       STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1 *  swarm-chip03   Ready   Active        Reachable
3inlk62a6l3afqp570nnus12f    swarm-raspi01  Ready   Active
7jvz6c8a852rve1r21fordkfa    swarm-chip04   Ready   Active
8174iszkmn4u4wwjogam8bsrw    swarm-chip01   Ready   Active        Leader
91ee08vkwuh3f6yelc4ci46se    swarm-chip05   Ready   Active
agglzv8ju0diwpd665nbhdtti    swarm-chip06   Ready   Active
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02   Ready   Active        Reachable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-node-ls.jpg&#34; alt=&#34;swarm-chip-node-ls.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-result-a-mixed-iot-swarm-running-docker-1-12&#34;&gt;THE RESULT: a mixed IoT Swarm running Docker 1.12&lt;/h3&gt;

&lt;p&gt;This is our newly created Swarm cluster, built with an USB power supply from Anker, 6x C.H.I.P. computers and a lonely Raspberry Pi Zero - all devices attached through a WiFi network and running Docker 1.12.1 with SwarmMode: &lt;br&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-complete-cluster.jpg&#34; alt=&#34;swarm-chip-complete-cluster.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;With this hardware setup we&amp;rsquo;ve now built a network of seven ARM devices for IoT which are all connected through WiFi. All the control traffic between the nodes are secured be default and can be centrally controlled through the Swarm managers and we can connect them securely from a local computer via Docker Machine. The ARM boards can be spread out in your house and can run different tasks as Docker containers&amp;hellip; but these details I&amp;rsquo;d like to cover in a future blog post.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Install Docker 1.12 on the $9 C.H.I.P. computer</title>
      <link>https://blog.hypriot.com/post/install-docker-on-chip-computer/</link>
      <pubDate>Sat, 03 Sep 2016 22:53:12 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/install-docker-on-chip-computer/</guid>
      <description>&lt;p&gt;Did you see the successfully launch of a really cheap ARM board for $9 only - the C.H.I.P. computer? It has an ARMv7 CPU with 512 MByte of main memory, 4 GByte flash memory as disk storage and is equipped with onboard WiFi and bluetooth as well.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-and-banana.jpg&#34; alt=&#34;chip-and-banana&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With these awesome features built-in it would be really a great device to run Docker containers if only the recent Linux kernel 4.4  has the correct modules included, but it doesn&amp;rsquo;t - what a bummer!&lt;/p&gt;

&lt;p&gt;But with spending a lot of time in building a custom Linux kernel and tweaking &amp;amp; testing I was finally able to install the latest Docker Engine for ARM on the C.H.I.P. &amp;mdash; and as a result you can easily follow this tutorial and within a few minutes only you can run your first Docker container on this cute ARM board&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-photo.jpg&#34; alt=&#34;chip-photo&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Preparing your operating system and your Linux kernel to be able to run the Docker Engine efficiently can be a hard thing and can consume a lot of labor time.&lt;/p&gt;

&lt;p&gt;Fortunately in this tutorial I&amp;rsquo;ll show you the basic steps to get Docker running on the $9 C.H.I.P. computer, so every normal user should be able to do it on her own within a short time only - even without the need being an expert in this area. And if you&amp;rsquo;re in a hurry you can skip most of the tutorial and go straight ahead to the &lt;code&gt;Lessons learned - TL;DR&lt;/code&gt; section and install Docker with just two single commands.&lt;/p&gt;

&lt;h3 id=&#34;necessary-steps-to-install-docker&#34;&gt;Necessary steps to install Docker&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Flash the latest available firmware&lt;/li&gt;
&lt;li&gt;Connect to the C.H.I.P. via USB or UART console cable&lt;/li&gt;
&lt;li&gt;Configure WiFi connection&lt;/li&gt;
&lt;li&gt;Configure SSH to access the C.H.I.P.&lt;/li&gt;
&lt;li&gt;Checking the OS and Linux kernel version&lt;/li&gt;
&lt;li&gt;Install the Docker Engine 1.12.1 the easy way&lt;/li&gt;
&lt;li&gt;Upgrade the Linux kernel to a custom built version&lt;/li&gt;
&lt;li&gt;Run your first Docker Container on the C.H.I.P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;step-1-flash-the-latest-available-firmware&#34;&gt;Step 1: Flash the latest available firmware&lt;/h4&gt;

&lt;p&gt;Use a Chrome browser and flash the latest firmware and OS on your C.H.I.P. computer. For detailed instructions go to the appropriate web site at &lt;a href=&#34;http://flash.getchip.com/&#34;&gt;http://flash.getchip.com/&lt;/a&gt;.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/flash-getchip-com.jpg&#34; alt=&#34;flash-getchip-com&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To run Docker on the C.H.I.P. we&amp;rsquo;re using the OS image for &lt;code&gt;Debian Headless 4.4&lt;/code&gt;, which is a server installation without any GUI and thus it&amp;rsquo;s quite smaller is size, so we do have more space left for running apps and Docker containers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; You can even see all the detailed log messages while flashing via an UART console cable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Starting download of 6291508 bytes
................................................
downloading of 6291508 bytes finished
Flashing sparse image on partition UBI at offset 0x26800000 (ID: 10)
start 0x9a00 blkcnt 0x180 partition 0x400 size 0x7fc00
Writing at offset 0x26800000
New offset 0x27400000
........ wrote 384 blocks to &#39;UBI&#39;

*****************[ FLASHING DONE ]*****************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-successfully-flashed.jpg&#34; alt=&#34;chip-successfully-flashed&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;step-2-connect-to-the-c-h-i-p-via-usb-or-uart-console-cable&#34;&gt;Step 2: Connect to the C.H.I.P. via USB or UART console cable&lt;/h4&gt;

&lt;p&gt;Once the C.H.I.P. is successfully flashed you can connect it directly with an USB cable to a Mac or Linux machine. The C.H.I.P. is getting power over the USB cable and connects via an USB serial console driver, so you can easily connect to.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find the booted C.H.I.P. on the USB wire:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -al /dev/cu.usb*
crw-rw-rw-  1 root  wheel   20, 159 Sep  3 16:52 /dev/cu.usbmodem141113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note 1:&lt;/em&gt; you have to wait a few minutes until the device can be detected as the C.H.I.P. has to be fully booted. &lt;br&gt;
&lt;em&gt;Note 2:&lt;/em&gt; it&amp;rsquo;s strongly recommended to use a powered USB hub, otherwise you&amp;rsquo;ll hit some power problems and the C.H.I.P. can&amp;rsquo;t access or can immediately shuts off&lt;/p&gt;

&lt;p&gt;Now we can connect to the ARM device via the &lt;code&gt;screen&lt;/code&gt; utility:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo screen /dev/cu.usbmodem141113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, and this is my preferred way, you can attach an UART console cable (e.g. from &lt;a href=&#34;https://www.adafruit.com/product/954&#34;&gt;AdaFruit&lt;/a&gt;) which is typically shown as a device on the Mac like &lt;code&gt;/dev/cu.usbserial&lt;/code&gt;. With this setup you can even watch the complete boot logs of the C.H.I.P. computer and you are able to see all early boot messages from U-Boot and from loading and starting the Linux kernel. This gives you all details in case there are any problems and issues with a homegrown kernel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo screen /dev/cu.usbserial 115200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you get to the login message, you can use username &lt;code&gt;root&lt;/code&gt; and password &lt;code&gt;chip&lt;/code&gt; to login:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Debian GNU/Linux 8 chip ttyS0

chip login: root
Password:
Linux chip 4.4.11-ntc #1 SMP Sat May 28 00:27:07 UTC 2016 armv7l

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@chip:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-3-configure-wifi-connection&#34;&gt;Step 3: Configure WiFi connection&lt;/h4&gt;

&lt;p&gt;Following the instruction here &lt;a href=&#34;http://docs.getchip.com/chip.html#wifi-connection&#34;&gt;http://docs.getchip.com/chip.html#wifi-connection&lt;/a&gt; you can list all the available WiFi networks and then connect the C.H.I.P. to your preferred network.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi list
*  SSID         MODE   CHAN  RATE       SIGNAL  BARS  SECURITY
   HITRON-FEE0  Infra  11    54 Mbit/s  67      ▂▄▆_  WPA2
   WLAN-R46VFR  Infra  1     54 Mbit/s  65      ▂▄▆_  WPA2
   My ASUS      Infra  6     54 Mbit/s  64      ▂▄▆_  WPA2
   WLAN-718297  Infra  1     54 Mbit/s  59      ▂▄▆_  WPA2
   WLAN-MCQYPS  Infra  1     54 Mbit/s  30      ▂___  WPA2
   Telekom_FON  Infra  1     54 Mbit/s  27      ▂___  --

*  SSID  MODE  CHAN  RATE  SIGNAL  BARS  SECURITY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connect to the WiFi station with the SSID &lt;code&gt;mySSID&lt;/code&gt; and password &lt;code&gt;myPASSWORD&lt;/code&gt;, please insert you own SSID and PASSWORD. In this example I&amp;rsquo;m using the SSID &lt;code&gt;WLAN-R46VFR&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi connect &#39;WLAN-R46VFR&#39; password &#39;**********&#39; ifname wlan0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you are connected you can see the &amp;lsquo;*&amp;rsquo; in front of your connected WiFi network:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi list
*  SSID         MODE   CHAN  RATE       SIGNAL  BARS  SECURITY
   HITRON-FEE0  Infra  11    54 Mbit/s  67      ▂▄▆_  WPA2
   My ASUS      Infra  6     54 Mbit/s  64      ▂▄▆_  WPA2
   WLAN-718297  Infra  1     54 Mbit/s  59      ▂▄▆_  WPA2
   WLAN-MCQYPS  Infra  1     54 Mbit/s  30      ▂___  WPA2
   Telekom_FON  Infra  1     54 Mbit/s  27      ▂___  --
*  WLAN-R46VFR  Infra  1     54 Mbit/s  100     ▂▄▆█  WPA2

*  SSID  MODE  CHAN  RATE  SIGNAL  BARS  SECURITY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the C.H.I.P. should have got an IP address from the DHCP server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifconfig wlan0
wlan0     Link encap:Ethernet  HWaddr cc:79:cf:20:6d:d8
          inet addr:192.168.2.112  Bcast:192.168.2.255  Mask:255.255.255.0
          inet6 addr: fe80::ce79:cfff:fe20:6dd8/64 Scope:Link
          inet6 addr: 2003:86:8c18:1a37:ce79:cfff:fe20:6dd8/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:119 errors:0 dropped:1 overruns:0 frame:0
          TX packets:102 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:24656 (24.0 KiB)  TX bytes:16973 (16.5 KiB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re connected to the network and can access the internet and the C.H.I.P. can be reached from our Mac or Linux machine.&lt;/p&gt;

&lt;h4 id=&#34;step-4-configure-ssh-to-access-the-c-h-i-p&#34;&gt;Step 4: Configure SSH to access the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;Here we have to use the same username &lt;code&gt;root&lt;/code&gt; and password &lt;code&gt;chip&lt;/code&gt; to login via SSH:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-add
ssh-keygen -R 192.168.2.112
ssh-copy-id root@192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we can login to the C.H.I.P. computer via SSH:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh root@192.168.2.112

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Thu Jan  1 00:32:25 1970
-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
root@chip:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-5-checking-the-os-and-linux-kernel-version&#34;&gt;Step 5: Checking the OS and Linux kernel version&lt;/h4&gt;

&lt;p&gt;As a first step we&amp;rsquo;d like to check the current Linux kernel version and operating system.&lt;/p&gt;

&lt;p&gt;Kernel version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.11-ntc #1 SMP Sat May 28 00:27:07 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operating system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /etc/os-release
PRETTY_NAME=&amp;quot;Debian GNU/Linux 8 (jessie)&amp;quot;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;
VERSION_ID=&amp;quot;8&amp;quot;
VERSION=&amp;quot;8 (jessie)&amp;quot;
ID=debian
HOME_URL=&amp;quot;http://www.debian.org/&amp;quot;
SUPPORT_URL=&amp;quot;http://www.debian.org/support&amp;quot;
BUG_REPORT_URL=&amp;quot;https://bugs.debian.org/&amp;quot;
BUILD_ID=Wed Jun  1 05:34:36 UTC 2016
VARIANT=&amp;quot;Debian on C.H.I.P&amp;quot;
VARIANT_ID=SERVER
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-6-install-the-docker-engine-1-12-1-the-easy-way&#34;&gt;Step 6: Install the Docker Engine 1.12.1 the easy way&lt;/h4&gt;

&lt;p&gt;In order to install Docker I&amp;rsquo;ve prepared a complete installation script which can be downloaded and executed in a single command line. I&amp;rsquo;ve you&amp;rsquo;re interested into the details you should check the script at &lt;a href=&#34;https://github.com/DieterReuter/arm-docker-fixes/blob/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install Docker
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of running the install script we&amp;rsquo;ll see some errors occurred and the start of the Docker Engine has failed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Errors were encountered while processing:
 docker-engine
E: Sub-process /usr/bin/dpkg returned an error code (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is OK for now as it just indicates the default Linux kernel isn&amp;rsquo;t able to run Docker on the C.H.I.P. and we have to build and install a custom Linux kernel which has all the necessary kernel settings for Docker enabled.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re interested in analyzing these errors in more detail you can run the command &lt;code&gt;systemctl status docker.service&lt;/code&gt; and you&amp;rsquo;ll get more detailed log messages from &lt;code&gt;systemd&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# systemctl status docker.service -l
● docker.service - Docker Application Container Engine
   Loaded: loaded (/etc/systemd/system/docker.service; enabled)
   Active: failed (Result: exit-code) since Sat 2016-09-03 13:20:49 UTC; 2min 23s ago
     Docs: https://docs.docker.com
 Main PID: 10840 (code=exited, status=1/FAILURE)

Sep 03 13:20:48 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:48.580271961Z&amp;quot; level=info msg=&amp;quot;libcontainerd: new containerd process, pid: 10848&amp;quot;
Sep 03 13:20:49 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:49.652832502Z&amp;quot; level=error msg=&amp;quot;&#39;overlay&#39; not found as a supported filesystem on this host. Please ensure kernel is new enough and has overlay support loaded.&amp;quot;
Sep 03 13:20:49 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:49.656854332Z&amp;quot; level=fatal msg=&amp;quot;Error starting daemon: error initializing graphdriver: driver not supported&amp;quot;
Sep 03 13:20:49 chip systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE
Sep 03 13:20:49 chip systemd[1]: Failed to start Docker Application Container Engine.
Sep 03 13:20:49 chip systemd[1]: Unit docker.service entered failed state.
Sep 03 13:20:50 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:52 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:53 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:54 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-7-upgrade-the-linux-kernel-to-a-custom-built-version&#34;&gt;Step 7: Upgrade the Linux kernel to a custom built version&lt;/h4&gt;

&lt;p&gt;In order to keep this tutorial short and easy to follow, I&amp;rsquo;d like to use an already prepared custom kernel which has nearly all the possible kernel modules and settings enabled to run the Docker Engine in an optimized way on the C.H.I.P. computer.&lt;/p&gt;

&lt;p&gt;Therefore we only have to install our new Linux kernel and have to reboot the system to activate it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install custom Linux Kernel and reboot
curl -sSL https://github.com/hypriot/binary-downloads/releases/download/chip-kernel-4.4.11/4.4.11-hypriotos.tar.bz2 | tar xvfj - -C /
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After rebooting we&amp;rsquo;re going to check the kernel version again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.11-hypriotos #1 SMP Mon Aug 29 19:18:49 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the Docker client version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker -v
Docker version 1.12.1, build 23cf638
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the Docker server version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker version
Client:
 Version:      1.12.1
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   23cf638
 Built:        Thu Aug 18 05:31:15 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.1
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   23cf638
 Built:        Thu Aug 18 05:31:15 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting the detailed informations about the Docker Engine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.12.1
Storage Driver: overlay
 Backing Filesystem: &amp;lt;unknown&amp;gt;
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: null host bridge overlay
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Security Options:
Kernel Version: 4.4.11-hypriotos
Operating System: Debian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 1
Total Memory: 491 MiB
Name: chip
ID: SSJ5:7OTQ:BCAZ:4MDL:VEW6:VKND:3J6W:UI3O:UTBB:7H5V:LQ4W:ABRP
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we could see, the latest Docker Engine v1.12.1 is now installed and is successfully running.&lt;/p&gt;

&lt;h4 id=&#34;step-8-run-your-first-docker-container-on-the-c-h-i-p&#34;&gt;Step 8: Run your first Docker Container on the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;As a last step we&amp;rsquo;d like to start a first Docker container, a small web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
fec2773baaec570ba8b6e00296dfd11b4b4768d1b51e574d851968b9225b9d22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start your web browser and point it to the website from our Docker container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open http://192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/first-container-on-chip.jpg&#34; alt=&#34;first-container-on-chip&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Additional tip:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After installing some packages via &lt;code&gt;apt-get&lt;/code&gt; it&amp;rsquo;s a good idea to clean the APT cache from time to time and save disk space.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# apt-get clean
root@chip:~# df -h
Filesystem      Size  Used Avail Use% Mounted on
ubi0:rootfs     3.7G  373M  3.3G  11% /
devtmpfs        213M     0  213M   0% /dev
tmpfs           246M     0  246M   0% /dev/shm
tmpfs           246M  6.7M  239M   3% /run
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           246M     0  246M   0% /sys/fs/cgroup
tmpfs            50M     0   50M   0% /run/user/0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lessons-learned-tl-dr&#34;&gt;Lessons learned - TL;DR&lt;/h3&gt;

&lt;p&gt;Currently the C.H.I.P. isn&amp;rsquo;t able to run Docker out-of-the-box, but it just needs to install a custom built Linux kernel to prepare this awesome ARM board to run Docker easily. And now we&amp;rsquo;re able to install the officially built Docker Engine from the Docker project&amp;rsquo;s APT repository.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/em&gt; &lt;BR&gt;
these are the only commands you need to install Docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install Docker
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh | bash

# install custom Linux Kernel and reboot
curl -sSL https://github.com/hypriot/binary-downloads/releases/download/chip-kernel-4.4.11/4.4.11-hypriotos.tar.bz2 | tar xvfj - -C /
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the best thing is, according to this &lt;a href=&#34;https://twitter.com/zerotri/status/771218366845497344&#34;&gt;tweet&lt;/a&gt;, the developers at &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt; have already started to include all the required kernel settings into the standard OS images. So we can expect that the Docker Engine can be installed in the future even without tweaking the Linux kernel.&lt;/p&gt;

&lt;h3 id=&#34;outlook&#34;&gt;Outlook&lt;/h3&gt;

&lt;p&gt;As I told you at the beginning of this tutorial, these are just the basic steps for a normal user to install and use Docker on the C.H.I.P. computer. But if you&amp;rsquo;re interested in all the technical details behind the scene, how to check and analyze your Linux kernel and how to optimize it for running Docker efficiently, then please drop me a comment or tweet me and I&amp;rsquo;ll write even more about all the technical details so you can follow the path along on to an expert level too. With these skills you then should be able to install Docker on any Linux-based ARM device.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Releasing HypriotOS 1.0.0 &#34;Blackbeard&#34;</title>
      <link>https://blog.hypriot.com/post/releasing-HypriotOS-1-0/</link>
      <pubDate>Sun, 21 Aug 2016 12:30:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/releasing-HypriotOS-1-0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Today we proudly present our 1.0.0 release of HypriotOS – a container OS that takes you from Zero to Docker within 5 Minutes only, on any device of the complete Raspberry Pi family.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For this major release we&amp;rsquo;ve taken an especially great deal of trouble. Out of the box, you not only get the breaking features of the Docker Engine 1.12.1 and the latest versions of Docker Compose and Docker Machine, but also many improvements that enhance the performance, reliability and usability.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/release-1-0/docker_pirate_650px_full-width.jpg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Therefore, this release illustrates very much how we work as Hypriot Team: We don&amp;rsquo;t stop after a &lt;code&gt;docker run&lt;/code&gt; just works on a Raspberry Pi. Meanwhile this has been possible for a long time. We only stop, when we went all the way down the rabbit whole and identified all adjusting screws of the operating system that can be used to improve the &lt;strong&gt;performance, reliability and usability&lt;/strong&gt; to run containers efficiently on ARM. Just to name a few examples: we include a Linux Kernel that is optimized for running Docker, we set all recommended configuration settings stated by Docker (and more), and provide tools that make the process of downloading HypriotOS and flashing it on a SD card super easy (see our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; and &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;As a result, you can be sure that we fine-tuned all adjusting screws to ensure we provide not some container OS, but an awesome one.&lt;/p&gt;

&lt;h2 id=&#34;feature-highlights-of-hypriotos&#34;&gt;Feature Highlights of HypriotOS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Latest Docker Engine 1.12.1 with Swarm Mode&lt;/strong&gt; &lt;/br&gt;
You can get your hands on the new features of the freshly-baked Engine Docker 1.12.1 that is still warm. It includes the new Swarm Mode, which allows high availability of services in a multi-node cluster within just a few commands.
&lt;a href=&#34;https://blog.docker.com/2016/07/swarm-mode-on-a-raspberry-pi-cluster/&#34;&gt;See this short video how it works.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Support for the complete Raspberry Pi family&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS on each and every model of the Raspberry Pi family - we&amp;rsquo;re supporting Pi 1, 2, 3, Zero and even the Compute Module. Thus, all Raspberry Pi devices ever built are fully supported. This is possible through the dual kernels for ARMv6 and ARMv7 architecure we included on the SD card. Guess what: you can even switch your SD card from one Pi model to the other and it just works.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Easy flashing and configuration&lt;/strong&gt; &lt;/br&gt;
We improved our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;, which puts HypriotOS onto a SD card that is ready to boot from with a single command. After you flashed the SD card, you can store the settings of your environment, e.g. Wi-Fi connection parameters into a configuration file on the SD card &lt;code&gt;/boot/device-init.yaml&lt;/code&gt;. HypriotOS includes &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;, which makes your Raspberry Pi directly connecting to your Wi-Fi network after booting.
After booting, you can find the Raspberry Pi at your network with a simple &lt;code&gt;ping black-pearl.local&lt;/code&gt; – no more searching for IP addresses required thanks to the integrated Avahi service discovery.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enhanced security out of the box&lt;/strong&gt; &lt;/br&gt;
We think that security should be shipped out-of-the-box. We make HypriotOS more secure without you even noticing it. For instance, there is no built-in &amp;ldquo;root&amp;rdquo; user any more. Also, the default user &amp;ldquo;pirate&amp;rdquo; (password &amp;ldquo;hypriot&amp;rdquo;) is able to run Docker commands directly, which usually requires sudo rights. For an even better security, we strongly recommend to change the default user password and to restrict SSH access to pre-shared keys only with disabling SSH password authentication.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maximum performance out of the box&lt;/strong&gt; &lt;/br&gt;
As with security, running Docker with high performance comes out-of-the-box with HypriotOS. This includes faster booting times (15-17 sec.), an optimized file system to support more Inodes, minimal memory footprint and disk usage, and the reliable overlay storage driver for Docker by default.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Now 50% smaller in size, even smaller than Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
Even though HypriotOS 1.0.0 is fully packed with the complete and latest Docker tool set, it now comes at a size smaller than the tiniest version of Raspbian (&amp;ldquo;Raspbian Lite&amp;rdquo;). We achieved this mainly by reducing the cache&amp;rsquo;s footprint and leaving out some unused packages, so you won&amp;rsquo;t miss any features you are used to. You just need to download only 232 MB instead of 504 MB as before. With this improvements the minimum disk usage is reduced down to 600 MB.&lt;/p&gt;

&lt;p&gt;Please see all details in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases/tag/v1.0.0&#34;&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick start&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Download our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; and run&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Afterwards, put the SD card into the Raspberry Pi and power it. That&amp;rsquo;s all to get HypriotOS up and running!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;If you wanna connect to the Raspberry Pi, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with password &amp;ldquo;hypriot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you want the Raspberry Pi to connect directly to your Wi-Fi after boot, change the hostname of the Raspberry Pi and more, edit &lt;code&gt;/boot/device-init.yaml&lt;/code&gt; of the SD card and have a look at the &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;documentation of device-init&lt;/a&gt;. Alternatively, checkout the parameters of the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt; that also allows you to define configurations. Really, it&amp;rsquo;s just so damn easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n myHOSTNAME -s mySSID -p myWIFIPASSWORD https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h2&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Your Hypriot Team:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Andreas &lt;a href=&#34;https://twitter.com/firecyberice&#34;&gt;@firecyberice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mathias &lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>