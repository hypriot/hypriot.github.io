<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Docker Pirates ARMed with explosive stuff</title>
    <link>http://blog.hypriot.com/categories/docker/</link>
    <description>Recent content in Docker on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 21 Mar 2016 00:00:00 +0100</lastBuildDate>
    <atom:link href="http://blog.hypriot.com/categories/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Come to our Docker Birthday Party</title>
      <link>http://blog.hypriot.com/post/docker-birthday-party-announcement/</link>
      <pubDate>Mon, 21 Mar 2016 00:00:00 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/docker-birthday-party-announcement/</guid>
      <description>

&lt;p&gt;As you all know tomorrow will be a really special day.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We will celebrate the 3rd Docker birthday.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;And of course we from Hypriot are in the thick of it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/docker-mini-cake-cover.jpg&#34; alt=&#34;Come to the Docker Birthday Party 2016&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;We had to find a suitable location (we now have space for 450 people), prepare the location and computers for all the attendees,
make a birthday cake, learn all about Docker so we could be mentors and finally we had to find sponsors &amp;hellip;&lt;/p&gt;

&lt;p&gt;And we actually found some and want to say thank you here for their support:&lt;/p&gt;

&lt;p&gt;We thank &lt;strong&gt;Paessler AG&lt;/strong&gt; for the Birthday Cake:
&lt;a href=&#34;http://www.paessler.com/&#34;&gt;&lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/paessler.jpg&#34; alt=&#34;Paessler AG&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We thank &lt;strong&gt;TAO &amp;amp; University of Bamberg&lt;/strong&gt; for the great location:
&lt;a href=&#34;http://www.tao-oberfranken.de//&#34;&gt;&lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/tao.jpg&#34; alt=&#34;TAO&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.uni-bamberg.de/&#34;&gt;&lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/uni-bamberg.jpg&#34; alt=&#34;University of Bamberg&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We thank &lt;strong&gt;SEAL Systems AG&lt;/strong&gt; for the pizza:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sealsystems.de/&#34;&gt;&lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/seal.jpg&#34; alt=&#34;Seal Systems AG&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Please drop them a line at their twitter account and give them a virtual hug!&lt;/p&gt;

&lt;p&gt;So we mostly finished our preparations and are super excited.&lt;/p&gt;

&lt;p&gt;If you have not yet decided if you want to come, here are some reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a totally free Docker Training&lt;/li&gt;
&lt;li&gt;the best Mentors you can find in good old Germany&lt;/li&gt;
&lt;li&gt;a special kind of Pizza that you usually will only get in Italy&lt;/li&gt;
&lt;li&gt;a really one-of-its-kind birthday cake&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And to wet your appetite some more we have prepared some pictures:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;
&lt;div class=&#34;title&#34;&gt;Docker Birthday Party Warm-Up&lt;/div&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/come-to-birthday-party/docker-mini-cake.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1062&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/thumbnails/thumb_docker-mini-cake.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Come to the Docker Birthday Party!&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Come to the Docker Birthday Party!
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/come-to-birthday-party/docker-gopher.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1062x1600&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/thumbnails/thumb_docker-gopher.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Go, the concurrency wizard handles three balloons at once...&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Go, the concurrency wizard handles three balloons at once...
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/come-to-birthday-party/docker-pinguin.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1062&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/thumbnails/thumb_docker-pinguin.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;And here comes Linux who can even party in realtime...&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    And here comes Linux who can even party in realtime...
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/come-to-birthday-party/docker-squid.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1062x1600&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/come-to-birthday-party/thumbnails/thumb_docker-squid.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;And the squid will manage the bar. Nobody composes better cocktails...&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    And the squid will manage the bar. Nobody composes better cocktails...
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;h2 id=&#34;join-the-docker-bamberg-meetup:6518e7e8108f06aa4add69ce96f55bcc&#34;&gt;Join the Docker Bamberg Meetup&lt;/h2&gt;

&lt;p&gt;So come and join us tomorrow. RSVP now at our &lt;strong&gt;&lt;a href=&#34;http://www.meetup.com/de-DE/Docker-Bamberg/events/228784029/&#34;&gt;Docker Bamberg Meetup Page&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting up 100 nodes Jenkins cluster with Docker Swarm in less than 10 minutes</title>
      <link>http://blog.hypriot.com/post/setting-up-100-nodes-jenkins-cluster-with-docker-swarm-in-less-than-10-minutes/</link>
      <pubDate>Sun, 20 Mar 2016 23:00:00 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/setting-up-100-nodes-jenkins-cluster-with-docker-swarm-in-less-than-10-minutes/</guid>
      <description>

&lt;p&gt;A week ago Scaleway announced their new C2 server. I was so excited to see that they were introducing new ARM C2 servers with 8 CPUs and 32 GB of RAM. Wow!
Not until I logged in and did &lt;code&gt;lscpu&lt;/code&gt; did I realize that those servers were &amp;ldquo;just&amp;rdquo; Intel Atom servers.&lt;/p&gt;

&lt;p&gt;A bit disappointed I thought what to do now? In my enthusiasm I had spun up 3 servers with 82 GB of RAM and 24 CPUs.
Still with my thoughts firmly rooted in the &lt;a href=&#34;https://blog.docker.com/2016/03/swarmweek-join-your-first-swarm/&#34;&gt;Docker #SwarmWeek&lt;/a&gt; I could not resist to find out how easy it would be to set up a Swarm Cluster on those servers.&lt;/p&gt;

&lt;p&gt;But a Swarm Cluster on its own is like a container ship without any containers - so I decided to run a Jenkins Cluster on top of the Swarm Cluster.&lt;/p&gt;

&lt;p&gt;You might not believe me, but I was able to set up a 100 node Jenkins Cluster in less than 10 minutes.
And you can do that, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/100-nodes-jenkins/scaleway.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;There are couple of reasons why it was so simple.&lt;/p&gt;

&lt;h2 id=&#34;meet-the-new-scaleway-c2-servers:42ed33cefda8a6f74e4e47b0527e1f17&#34;&gt;Meet the new Scaleway C2 servers&lt;/h2&gt;

&lt;p&gt;The first reason is that I was using the new Scaleway Cloud servers.&lt;/p&gt;

&lt;p&gt;You might think &amp;ldquo;well, just ordinary cloudservers like those Amazon EC2 instances&amp;rdquo;, but the Scaleway offering is really quite different.
By buying a Scaleway server you get access to real hardware that only belongs to you. It is not a virtual machine running on shared hardware.
Still you have all the flexibilty of an - say Amazon EC2 instance - you can start and stop the instance on demand and pay as you go on an hourly rate.
Furthermore you can completely control the Scaleway servers with an API and a great command line interface.&lt;/p&gt;

&lt;p&gt;Did I already talk about the pricing model?&lt;/p&gt;

&lt;p&gt;As the Scaleway offering feels quite similar to Amazons AWS EC2 offering I looked for an instance type that was more or less comparable to the top model from Scaleway.
I ended up with an &lt;a href=&#34;http://www.ec2instances.info/?selected=m4.2xlarge&#34;&gt;m4.2xlarge instance type&lt;/a&gt;.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Product&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;CPU&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;RAM&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Hourly Price&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Price per Month&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Amazon EC2 m4.2xlarge&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8 vCore&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;32 GB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;€ 0,5059&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;€ 364,24&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Scaleway Baremetal C2L&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8 Core&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;32 GB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;€ 0,0333&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;€ 23,99&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you can see the EC2 instance costs roughly 15 times what the Scaleway server costs.
Even if those two offerings are not 100% comparable I find the pricing of the Scaleway server very impressive.&lt;/p&gt;

&lt;p&gt;After introducing the new Scaleway C2 server let&amp;rsquo;s get started by setting up a couple of the C2 servers.&lt;/p&gt;

&lt;p&gt;If you do not have an account with Scaleway you need to &lt;a href=&#34;https://cloud.scaleway.com/#/signup&#34;&gt;sign up&lt;/a&gt; with them first.
Afterwards you can use the &lt;a href=&#34;https://github.com/scaleway/scaleway-cli&#34;&gt;Scaleway Command Line Interface&lt;/a&gt; to create the servers.&lt;/p&gt;

&lt;p&gt;Download the latest version for your operating system from the &lt;a href=&#34;https://github.com/scaleway/scaleway-cli/releases/tag/v1.8.0&#34;&gt;release page&lt;/a&gt;.
For working with the new C2 server you need at the latest version 1.8.0 of the Scaleway CLI.&lt;/p&gt;

&lt;p&gt;For Mac user the easiest way to install it is via &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install scw
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/scw-1.7.1.mavericks.bottle.tar.gz
Already downloaded: /Library/Caches/Homebrew/scw-1.7.1.mavericks.bottle.tar.gz
==&amp;gt; Pouring scw-1.7.1.mavericks.bottle.tar.gz
==&amp;gt; Caveats
Bash completion has been installed to:
  /usr/local/etc/bash_completion.d

zsh completion has been installed to:
  /usr/local/share/zsh/site-functions
==&amp;gt; Summary
🍺  /usr/local/Cellar/scw/1.7.1: 4 files, 10.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check if the Scaleway CLI works with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw --version
scw version v1.7.1, build homebrew
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks good.&lt;/p&gt;

&lt;p&gt;To be able to do anything meaningful with the CLI we need first to log into our account.
Use the email and password you got when you registered as credentials.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw login
Login (cloud.scaleway.com): somemail@somewhere.com
Password:
Do you want to upload an SSH key ?
[0] I don&#39;t want to upload a key !
[3] id_rsa.pub
Which [id]:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you are asked to upload the public part of your SSH key you should do so.
This allows us later to securely connect to our Scaleway ARM servers via SSH.&lt;/p&gt;

&lt;p&gt;After a successful login we are now able to interact with our Scaleway account remotely.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s create three servers for our Swarm Cluster.
The C2 server type is currently in preview which means there is a quota that allows only to spin up a limited number of each instance type.
So I settled for two C2L and one C2M.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw create --commercial-type=C2L --name=cl-leader Docker
16ca1b31-f94e-4d6c-be46-ade4641054e4

$ scw create --commercial-type=C2L --name=&amp;quot;cl-follower1&amp;quot; Docker
16ca1b31-f94e-4d6c-be46-ade4641052e4

$ scw create --commercial-type=C2M --name=&amp;quot;cl-follower2&amp;quot; Docker
16ca1b31-f94e-4d6c-be46-ade4641053e4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was easy, right?&lt;/p&gt;

&lt;p&gt;We can list our current servers by using&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw ps
SERVER ID           IMAGE               COMMAND             CREATED             STATUS              PORTS               NAME
f20a3a57            Docker_1_10_0                           1 days              running             212.47.235.237      cl-leader
8cae4fd4            Docker_1_10_0                           1 days              running             163.172.135.05      cl-follower1
6al5b4e4            Docker_1_10_0                           1 days              running             163.172.135.28      cl-follower2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check what we have by logging into one of our new servers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw exec cl-leader

root@cl-leader:~# docker info
root@cl-leader:~# docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.10.3
Storage Driver: aufs
 Root Dir: /var/lib/docker/aufs
 Backing Filesystem: extfs
 Dirs: 0
 Dirperm1 Supported: true
Execution Driver: native-0.2
Logging Driver: json-file
Plugins:
 Volume: local
 Network: bridge null host
Kernel Version: 4.4.5-docker-1
Operating System: Ubuntu 15.10
OSType: linux
Architecture: x86_64
CPUs: 8
Total Memory: 31.34 GiB
Name: cl-leader
ID: GUOI:LSEY:LASQ:XACT:M7D2:DVA3:LYLV:5YGT:6M7O:2P7T:5VXX:HKMO
Labels:
 provider=scaleway
Codename:wily
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we do have up-to-date software:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu 15.10&lt;/li&gt;
&lt;li&gt;a  4.4 Linux Kernel&lt;/li&gt;
&lt;li&gt;Docker 1.10.3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seems the Scaleway servers are a perfect place to run Docker and we have everything ready to move forward.&lt;/p&gt;

&lt;p&gt;The next step is setting up a private network between those three servers.
I am going to use a VPN solution called &lt;a href=&#34;https://www.tinc-vpn.org/&#34;&gt;tinc&lt;/a&gt; for that.
It is a really great peer-to-peer Mesh VPN solution, but basically you can use any VPN solution that works for you.
I am not going into the details of the tinc configuration now, because I am going to write about it in another blog post soon.&lt;/p&gt;

&lt;p&gt;So after configuring tinc we do have an additional network device on each server that is part of our private tinc network:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scw exec cl-leader &amp;quot; ip a | grep tun&amp;quot;
92: tun0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 500
    inet 10.0.0.2/24 scope global tun0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure that you can ping all the other nodes in your private network like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw exec cl-follower1 &amp;quot;ping 10.0.0.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That we have the name of tinc network device is important for the configuration of the Hypriot Cluster Lab which we gonna use in the next section.&lt;/p&gt;

&lt;h2 id=&#34;easy-swarming-with-the-hypriot-cluster-lab:42ed33cefda8a6f74e4e47b0527e1f17&#34;&gt;Easy swarming with the Hypriot Cluster Lab&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;Hypriot Cluster Lab&lt;/a&gt; is the second reason why it is so easy to set up our 100 node Jenkins cluster.
The Cluster Lab helps us to set up a Docker Swarm Cluster without any manual configuration in minutes.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s configure the Hypriot package repository and install the Hypriot Cluster Lab.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for server in cl-leader cl-follower1 cl-follower2; do
  scw exec $server &amp;quot;curl -s https://packagecloud.io/install/repositories/Hypriot/Schatzkiste/script.deb.sh | sudo bash; apt-get install -y hypriot-cluster-lab&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the Cluster Lab itself can be used in different scenarios we still need to configure some settings of the Cluster Lab to make it play nice with a VPN solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for server in cl-leader cl-follower1 cl-follower2; do
  scw exec $server \&amp;quot;sed -i -e &#39;s|ENABLE_VLAN=&amp;quot;true&amp;quot;|ENABLE_VLAN=&amp;quot;false&amp;quot;|g&#39; -e &#39;s|ENABLE_DHCP=&amp;quot;true&amp;quot;|ENABLE_DHCP=&amp;quot;false&amp;quot;|g&#39; -e &#39;s|INTERFACE=&amp;quot;eth0&amp;quot;|INTERFACE=&amp;quot;tun0&amp;quot;|g&#39; /etc/cluster-lab/cluster.conf\&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are changing the Cluster Lab configuration to disable VLAN and DHCP support and we are also changing the Cluster Lab network interface to &amp;lsquo;tun0&amp;rsquo; which we created with tinc before.
Those settings ensure that the Cluster Lab uses our private tinc network for all cluster communication. That means also that all the Docker networks are created on top of the encrypted tinc network.&lt;/p&gt;

&lt;p&gt;The last thing we need to adjust is the Avahi daemon configuration. We need to adjust it for the peer-to-peer nature of the tinc network and restart the Avahi daemon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for server in cl-leader cl-follower1 cl-follower2; do
  scw exec $server &amp;quot;sed -i &#39;s|#allow-point-to-point=no|allow-point-to-point=yes|g&#39; /etc/avahi/avahi-daemon.conf; systemctl restart avahi-daemon&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK. Now we are ready to start the Cluster Lab on the leader node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw exec cl-leader &amp;quot;VERBOSE=true cluster-lab start&amp;quot;

Internet Connection
  [PASS]   tun0 exists
  [PASS]   tun0 has an ip address
  [PASS]   Internet is reachable
  [PASS]   DNS works

Networking
  [PASS]   tun0 exists
  [PASS]   Cluster leader is reachable
  [PASS]   tun0 has exactly one IP
  [PASS]   tun0 has no local link address
  [PASS]   Avahi process exists
  [PASS]   Avahi is using tun0

Docker
  [PASS]   Docker is running
  [PASS]   Docker is configured to use Consul as key-value store
  [PASS]   Docker is configured to listen via tcp at port 2375
  [PASS]   Docker listens on 10.0.0.2 via tcp at port 2375 (Docker-Engine)

Consul
  [PASS]   Consul Docker image exists
  [PASS]   Consul Docker container is running
  [PASS]   Consul is listening on port 8300
  [PASS]   Consul is listening on port 8301
  [PASS]   Consul is listening on port 8302
  [PASS]   Consul is listening on port 8400
  [PASS]   Consul is listening on port 8500
  [PASS]   Consul is listening on port 8600
  [PASS]   Consul API works
  [PASS]   Cluster-Node is pingable with IP 10.0.0.3
  [PASS]   Cluster-Node is pingable with IP 10.0.0.4
  [PASS]   Cluster-Node is pingable with IP 10.0.0.2
  [PASS]   No Cluster-Node is in status &#39;failed&#39;
  [PASS]   Consul is able to talk to Docker-Engine on port 7946 (Serf)

Swarm
  [PASS]   Swarm-Join Docker container is running
  [PASS]   Swarm-Manage Docker container is running
  [PASS]   Number of Swarm and Consul nodes is equal which means our cluster is healthy scw exec cl-leader &amp;quot;VERBOSE=true cluster-lab start&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the &lt;code&gt;VERBOSE=true&lt;/code&gt; environment variable we tell the Cluster Lab to print out all the self-tests when it starts up.
If you see any failed tests it is usually a good idea to run a &lt;code&gt;cluster-lab health&lt;/code&gt; command, which does just the self-tests again.
Usually those should be green now and have only failed the first time because of timing issues.&lt;/p&gt;

&lt;p&gt;If you still have problems check our &lt;a href=&#34;https://github.com/hypriot/cluster-lab#troubleshooting&#34;&gt;trouble shooting&lt;/a&gt; section of the Cluster Lab project.&lt;/p&gt;

&lt;p&gt;It is important that the leader is started up first because the other nodes need him for the self-configuration.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s start the Cluster Lab on the rest of the nodes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for server in cl-follower1 cl-follower2; do
  scw exec $server &amp;quot;VERBOSE=true cluster-lab start&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now check if our Swarm Cluster is fully functional by running a &lt;code&gt;docker info&lt;/code&gt; against the Docker Swarm port:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw exec cl-leader
root@cl-leader:~# DOCKER_HOST=tcp://10.0.0.2:2378 docker info
Containers: 20
 Running: 9
 Paused: 0
 Stopped: 11
Images: 27
Role: replica
Primary: 10.0.0.3:2378
Strategy: spread
Filters: health, port, dependency, affinity, constraint
Nodes: 3
 cl-follower1: 10.0.0.3:2375
  └ Status: Healthy
  └ Containers: 7
  └ Reserved CPUs: 0 / 8
  └ Reserved Memory: 0 B / 32.91 GiB
  └ Labels: executiondriver=native-0.2, hypriot.arch=x86_64, hypriot.hierarchy=follower, kernelversion=4.4.5-docker-1, operatingsystem=Ubuntu 15.10, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-20T15:07:55Z
 cl-follower2: 10.0.0.4:2375
  └ Status: Healthy
  └ Containers: 7
  └ Reserved CPUs: 0 / 8
  └ Reserved Memory: 0 B / 16.4 GiB
  └ Labels: executiondriver=native-0.2, hypriot.arch=x86_64, hypriot.hierarchy=leader, kernelversion=4.4.5-docker-1, operatingsystem=Ubuntu 15.10, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-20T15:08:09Z
 cl-leader: 10.0.0.2:2375
  └ Status: Healthy
  └ Containers: 6
  └ Reserved CPUs: 0 / 8
  └ Reserved Memory: 0 B / 32.91 GiB
  └ Labels: executiondriver=native-0.2, hypriot.arch=x86_64, hypriot.hierarchy=follower, kernelversion=4.4.5-docker-1, operatingsystem=Ubuntu 15.10, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-20T15:07:52Z
Plugins:
 Volume:
 Network:
Kernel Version: 4.4.5-docker-1
Operating System: linux
Architecture: amd64
CPUs: 24
Total Memory: 82.22 GiB
Name: 4b3fd589316c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the &lt;code&gt;docker info&lt;/code&gt; command now runs against the Swarm TCP port we get plenty of information about the Swarm cluster.
For instance we can see the number of nodes we have as well as the total number of CPUs and RAM we do have in the cluster: 24 CPUs and a whopping amount of 82 GB of RAM.
That&amp;rsquo;s nice isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;starting-a-100-nodes-jenkins-cluster-with-docker-compose:42ed33cefda8a6f74e4e47b0527e1f17&#34;&gt;Starting a 100 Nodes Jenkins cluster with Docker-Compose&lt;/h2&gt;

&lt;p&gt;Ok, now comes the last reason why it is so fast and easy to set up 100 node Jenkins cluster.
The reason is called &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker-Compose&lt;/a&gt; and makes it ridiculous easy to get multi-container applications up and running.&lt;/p&gt;

&lt;p&gt;To use it we need to first install it on our cluster leader node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scw exec cl-leader &amp;quot;curl -L https://github.com/docker/compose/releases/download/1.6.2/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose; chmod +x /usr/local/bin/docker-compose&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a file called &amp;ldquo;docker-compose.yml&amp;rdquo; on the cluster leader with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: &amp;quot;2&amp;quot;

networks:
  jenkins_swarm:
    driver: overlay
    ipam:
      driver: default
      config:
        - subnet: 10.10.2.0/16
          ip_range: 10.10.2.0/24

services:
  jenkins:
    image: csanchez/jenkins-swarm
    expose:
      - 8080
      - 50000
    ports:
      - 8080:8080
    restart: always
    networks:
      - jenkins_swarm
    environment:
      - &amp;quot;constraint:NODE==cl-leader&amp;quot;

  worker:
    image: csanchez/jenkins-swarm-slave
    command: -username jenkins -password jenkins -executors 1
    networks:
      - jenkins_swarm
    environment:
      - &amp;quot;JENKINS_PORT_8080_TCP_ADDR=jenkins&amp;quot;
      - &amp;quot;JENKINS_PORT_8080_TCP_PORT=8080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: Replace the &amp;lsquo;subnet&amp;rsquo; and &amp;lsquo;ip_range&amp;rsquo; attributes in the file with configuration values that fit your private network configuration.
This is a Docker-Compose file that describes an overlay network and two services: a Jenkins Master and a Jenkins worker.
The overlay network will stretch across our Swarm Cluster and runs on top of our private network.
Because of IP adress conflicts between our private tinc network and the standard network configuration we had to add the &amp;lsquo;ipam&amp;rsquo; part.&lt;/p&gt;

&lt;p&gt;Now we are nearly finished and can start some Jenkins nodes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@cl-leader:~# DOCKER_HOST=tcp://10.0.0.3:2378 docker-compose -p jenkins up -d
Starting jenkins_jenkins_1
Starting jenkins_worker_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the important part is that the docker-compose command is running against our Swarm Cluster.
&amp;lsquo;-p&amp;rsquo; option creates a project namespace and the &amp;lsquo;-d&amp;rsquo; option tell Docker-Compose to start the container in the background.
This command initally created two container: one Jenkins master node and one worker.&lt;/p&gt;

&lt;p&gt;We now need to scale the worker nodes to 99 to finally reach our goal of a 100 nodes Jenkins Cluster.&lt;/p&gt;

&lt;p&gt;And that is really easy with Docker-Compose:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@cl-leader:~# COMPOSE_HTTP_TIMEOUT=180 DOCKER_HOST=tcp://10.0.0.3:2378 docker-compose -p jenkins scale worker=20
Creating and starting 2 ...
Creating and starting 3 ...
Creating and starting 4 ...
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If those twenty nodes are up repeat the command with 40, 60, 80 until you reach 99.
You could of course go for 99 at once but I experienced errors and timeouts so I prefer to take it slowly.&lt;/p&gt;

&lt;p&gt;To visit the GUI of the Jenkins master server we need to find out the IP address of our cluster leader node.
We can do that with the &lt;code&gt;inspect&lt;/code&gt; subcommand of the Scaleway CLI:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw inspect leader | grep address
   &amp;quot;address&amp;quot;: &amp;quot;212.47.225.127&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the Jenkins master can be found at: &lt;a href=&#34;http://212.47.225.127:8080&#34;&gt;http://212.47.225.127:8080&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You should see a page similar to&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/100-nodes-jenkins/jenkins01.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;And at &lt;a href=&#34;http://212.47.225.127:8080/computer&#34;&gt;http://212.47.225.127:8080/computer&lt;/a&gt; we can find all the slave nodes, too:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/100-nodes-jenkins/jenkins02.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So to wrap it up I can say that the combination of&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the on-demand Scaleway Servers&lt;/li&gt;
&lt;li&gt;the Hypriot Cluster Lab&lt;/li&gt;
&lt;li&gt;Docker-Compose&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;allowed me to get the Jenkins Cluster running in a really short time.&lt;/p&gt;

&lt;p&gt;It might not be 10 minutes for you - especially if you first need to set up the Scaleway account and the CLI tool. But if everything is in place it can be done in 5 to 10 minutes.&lt;/p&gt;

&lt;p&gt;Hope you had some fun following along&amp;hellip;.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker on Raspberry Pi Workshop in Brussels</title>
      <link>http://blog.hypriot.com/post/docker-on-arm-workshops/</link>
      <pubDate>Thu, 17 Mar 2016 00:00:00 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/docker-on-arm-workshops/</guid>
      <description>&lt;p&gt;A couple of weeks ago we have been invited by the fine folks over at the Docker User Group in Brussels to help conduct a workshop.
And of course this workshop was about Docker. Still it was not your ordinary Docker workshop.&lt;/p&gt;

&lt;p&gt;It was special because instead of being a workshop about Docker on big servers it was about Docker on really small ARM devices.
The very same devices that power the upcoming IoT revolution.&lt;/p&gt;

&lt;p&gt;Turns out it is really amazing what you can do with Docker on those tiny machines.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/docker_workshop.jpg&#34; alt=&#34;Raspberry Pi Workshop in Brussels&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;In this workshop attendees learned how to get started with Docker on their Raspberry Pi&amp;rsquo;s.
Starting with the basics they soon turned to advanced topics like building a Docker cluster.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What is Raspberry Pi and how is it working&lt;/li&gt;
&lt;li&gt;How to flash an SD card with HypriotOS&lt;/li&gt;
&lt;li&gt;How to log in to a Raspberry Pi via SSH or serial console&lt;/li&gt;
&lt;li&gt;How to do basic stuff with Docker&lt;/li&gt;
&lt;li&gt;What is different when using Docker on ARM compared to Intel&lt;/li&gt;
&lt;li&gt;How to build a Docker Cluster with Docker Swarm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dieter Reuter from our team gave an introductory talk and showed off some of the cool things we did at Hypriot.
About 70 people attended the workshop and worked in small groups and helped each other to learn new stuff.
Even days after the event Dieter was still raving about the cool event and the amazing, open-minded and friendly people.&lt;/p&gt;

&lt;p&gt;As you can see from the pictures it was a lot of fun to be there.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;
&lt;div class=&#34;title&#34;&gt;Docker &amp;amp; Raspberry Pi Workshop in Brussels&lt;/div&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-02.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-02.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Dieter giving a talk&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Dieter giving a talk
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-01.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-01.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-03.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-03.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-04.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-04.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-05.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-05.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-06.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-06.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;Special thanks for making the workshop possible need to go to Damien Duportal.
His workshop presentation can be found &lt;a href=&#34;http://dduportal.github.io/presentations/docker-meetup-brussels-20160210/#1&#34;&gt;here&lt;/a&gt;.
The example app that was used during the workshop was ported to ARM and can be found &lt;a href=&#34;https://github.com/jmMeessen/rpi-voting-app/commits/master&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We - at the Hypriot team - are really excited to see how more and more people start to see the potential in Docker on ARM.&lt;/p&gt;

&lt;p&gt;Last week I was approached by Bastiaan Schaap from the DevOps Oost-Nederland Meetup Group to help organize a similar workshop.
It will take place on &lt;strong&gt;June, 1st in Wageningen in the Netherlands&lt;/strong&gt;. You can read more about the agenda on the &lt;a href=&#34;http://www.meetup.com/de-DE/DevOps-OostNL/events/229287742/?eventId=229287742&#34;&gt;Meetup-Website&lt;/a&gt;.
Make sure to RSVP early as there will only be a limited number of seats available.&lt;/p&gt;

&lt;p&gt;We plan to do some more workshops in the next couple of months. So if you like to see one happen in your area - please come and talk to us.
We really have a lot of fun organizing and conducting these kind of events and can come up with a ton of different workshop topics.&lt;/p&gt;

&lt;p&gt;So in this sense - hope to see you soon in person.
Happy ARM hacking until then. :)&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s run Docker on the ClearFog Pro router board</title>
      <link>http://blog.hypriot.com/post/clearfog-pro-part-2-lets-run-docker/</link>
      <pubDate>Wed, 16 Mar 2016 18:14:02 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/clearfog-pro-part-2-lets-run-docker/</guid>
      <description>

&lt;p&gt;Here is the follow up of our blog post series about the new ARM-based router board
from SolidRun which is powered by a dual core Marvell ARMADA ARMv7 CPU. In case
you missed the intro a few days ago, we highly recommend reading the technical
specifications first to get an impression of this board.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part 1: &lt;a href=&#34;http://blog.hypriot.com/post/introducing-the-clearfog-pro-router-board/&#34;&gt;Introducing the new ClearFog Pro Router Board from SolidRun&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This time we&amp;rsquo;ll get our hands on this new board and try to install Linux with a
recent kernel version and hopefully we&amp;rsquo;re able to install and run the Docker Engine
the first time on this powerful device.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s get started and for our second episode we connect the ClearFog Pro to a
MacBookPro and powering this thing up&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-part2/clearfog-pro-eth2-cabled.jpg&#34; alt=&#34;ClearFog Pro Eth2 Cabled&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;first-contact:df574ad27518dffc38341295be8d9782&#34;&gt;First contact&lt;/h3&gt;

&lt;p&gt;We can connect the ClearFog Pro to a MacBookPro with a standard USB cable, because
SolidRun added a FTDI chip on the board (Note: you&amp;rsquo;ll need to install the appropriate
FTDI device drivers).
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-part2/clearfog-pro-serial-console.jpg&#34; alt=&#34;ClearFog Pro Serial Console&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The microUSB connector acts as a debugging console and gives us access to the
Linux console as well. As soon as we&amp;rsquo;re powering the board, we can see the console
output of the boot loader. Here we don&amp;rsquo;t have a microSD card inserted and the bootloader
stops it&amp;rsquo;s boot sequence and we proved that we are successfully connected.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BootROM - 1.73

Booting from MMC
Card did not respond to voltage select!
Error initializing MMC - FFFFFFEF

Trying Uart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-linux:df574ad27518dffc38341295be8d9782&#34;&gt;Install Linux&lt;/h3&gt;

&lt;p&gt;Normally we would start building our own HypriotOS for a new board, in order to get a
perfect Linux kernel with tuned settings and a Debian-based Linux distro to run Docker
in an optimized way. But this time it turns out we are able to jump start pretty fast
and using Armbian for this first testing.&lt;/p&gt;

&lt;p&gt;For this purpose we&amp;rsquo;ve created Armbian for the ClearFog Pro from source and getting a brand-new
Linux kernel 4.4.5 and all things packaged into a ready-to-install SD card image. Now, we
only have to flash the image to a microSD card with the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt;
and boot up the board.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash Armbian_5.05_Armada_Debian_jessie_4.4.5.raw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the login prompt we&amp;rsquo;re using username &lt;code&gt;root&lt;/code&gt; with the initial password &lt;code&gt;1234&lt;/code&gt;
to login the first time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Debian GNU/Linux 8 armada ttyS0

armada login:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;rsquo;ve changed the root password and created another user account, we do have
access to the console and can check the Armbian Linux system in detail.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# uname -a
Linux armada 4.4.5-marvell #2 SMP Wed Mar 16 09:42:31 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, this is indeed a current Linux kernel version 4.4.5. The very latest
Linux kernel release is 4.5 and it was just released a few days ago and we should expect
it will be supported soon for the ClearFog Pro board too.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive a little bit deeper and we can see our board is running with 1 GByte
of main memory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# cat /proc/meminfo
MemTotal:        1027860 kB
MemFree:          910964 kB
MemAvailable:     973540 kB
Buffers:           11104 kB
Cached:            66864 kB
SwapCached:            0 kB
Active:            56388 kB
Inactive:          37856 kB
Active(anon):      17536 kB
Inactive(anon):     6540 kB
Active(file):      38852 kB
Inactive(file):    31316 kB
Unevictable:           0 kB
Mlocked:               0 kB
HighTotal:        262144 kB
HighFree:         237664 kB
LowTotal:         765716 kB
LowFree:          673300 kB
SwapTotal:        131068 kB
SwapFree:         131068 kB
Dirty:                 8 kB
Writeback:             0 kB
AnonPages:         16340 kB
Mapped:            10092 kB
Shmem:              7804 kB
Slab:              11668 kB
SReclaimable:       5004 kB
SUnreclaim:         6664 kB
KernelStack:         720 kB
PageTables:          360 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:      644996 kB
Committed_AS:      56040 kB
VmallocTotal:     245760 kB
VmallocUsed:           0 kB
VmallocChunk:          0 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And a dual core ARMv7 from a Marvell Armada 380 / 385 CPU. To be precise, it&amp;rsquo;s a
Marvell ARMADA 388 CPU with up to 1.6GHz.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# cat /proc/cpuinfo
processor       : 0
model name      : ARMv7 Processor rev 1 (v7l)
BogoMIPS        : 50.00
Features        : half thumb fastmult vfp edsp thumbee neon vfpv3 tls vfpd32
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x4
CPU part        : 0xc09
CPU revision    : 1

processor       : 1
model name      : ARMv7 Processor rev 1 (v7l)
BogoMIPS        : 50.00
Features        : half thumb fastmult vfp edsp thumbee neon vfpv3 tls vfpd32
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x4
CPU part        : 0xc09
CPU revision    : 1

Hardware        : Marvell Armada 380/385 (Device Tree)
Revision        : 0000
Serial          : 0000000000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a detailed picture of the SOM (System On Module), which includes the CPU
and the DDR3 memory chips.
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-part2/clearfog-pro-microsom-a388-top-transparent.jpg&#34; alt=&#34;ClearFog Pro MicroSOM&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Once we attach an ethernet cable to the ethernet connector next to the USB plug,
we should have the network interface &lt;code&gt;eth2&lt;/code&gt; running. If there is no IP address
assigned we can use &lt;code&gt;dhclient eth2&lt;/code&gt; to fetch a new TCP/IP address via DHCP.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# dhclient eth2
[  262.372335] mvneta f1070000.ethernet eth2: PHY [f1072004.mdio-mi:00] driver [Marvell 88E1510]
[  262.380889] mvneta f1070000.ethernet eth2: configuring for link AN mode phy
[  262.387949] IPv6: ADDRCONF(NETDEV_UP): eth2: link is not ready
[  265.371548] mvneta f1070000.ethernet eth2: Link is Up - 100Mbps/Full - flow control rx/tx
[  265.379757] IPv6: ADDRCONF(NETDEV_CHANGE): eth2: link becomes ready
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# ifconfig eth2
eth2      Link encap:Ethernet  HWaddr 00:50:43:25:fb:84
          inet addr:192.168.2.108  Bcast:192.168.2.255  Mask:255.255.255.0
          inet6 addr: fe80::250:43ff:fe25:fb84/64 Scope:Link
          inet6 addr: 2003:86:8c11:a703:250:43ff:fe25:fb84/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:57 errors:0 dropped:0 overruns:0 frame:0
          TX packets:44 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:532
          RX bytes:7746 (7.5 KiB)  TX bytes:4300 (4.1 KiB)
          Interrupt:41
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally let&amp;rsquo;s check if we have an internet connection to proceed with our installation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# ping -c 3 google.com
PING google.com (173.194.116.206) 56(84) bytes of data.
64 bytes from fra07s64-in-f14.1e100.net (173.194.116.206): icmp_seq=1 ttl=57 time=27.0 ms
64 bytes from fra07s64-in-f14.1e100.net (173.194.116.206): icmp_seq=2 ttl=57 time=26.8 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2003ms
rtt min/avg/max/mdev = 26.828/26.959/27.091/0.210 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, that&amp;rsquo;s great. We do have now a Debian Jessie Linux distro called &lt;code&gt;Armbian&lt;/code&gt;
with a most recent Linux kernel 4.4.5 running on the ClearFog Pro.&lt;/p&gt;

&lt;h3 id=&#34;installing-the-docker-engine:df574ad27518dffc38341295be8d9782&#34;&gt;Installing the Docker Engine&lt;/h3&gt;

&lt;p&gt;Before we try to install Docker, we&amp;rsquo;d like to know about if the Linux kernel settings
are sufficient to run Docker in a decent way. Remember, most of the standard Linux
kernels for dev boards lacks the support for a few important kernel options, and this
could cause major problems to run Docker.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s have a look here and check the kernel settings with a check script which
is thankfully provided by the Docker core team.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://github.com/docker/docker/raw/master/contrib/check-config.sh
chmod +x check-config.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;./check-config.sh
info: reading kernel config from /proc/config.gz ...

Generally Necessary:
- cgroup hierarchy: properly mounted [/sys/fs/cgroup]
- CONFIG_NAMESPACES: enabled
- CONFIG_NET_NS: enabled
- CONFIG_PID_NS: enabled
- CONFIG_IPC_NS: enabled
- CONFIG_UTS_NS: enabled
- CONFIG_DEVPTS_MULTIPLE_INSTANCES: missing
- CONFIG_CGROUPS: enabled
- CONFIG_CGROUP_CPUACCT: enabled
- CONFIG_CGROUP_DEVICE: enabled
- CONFIG_CGROUP_FREEZER: enabled
- CONFIG_CGROUP_SCHED: enabled
- CONFIG_CPUSETS: enabled
- CONFIG_MEMCG: enabled
- CONFIG_KEYS: enabled
- CONFIG_MACVLAN: enabled
- CONFIG_VETH: enabled
- CONFIG_BRIDGE: enabled
- CONFIG_BRIDGE_NETFILTER: enabled (as module)
- CONFIG_NF_NAT_IPV4: enabled (as module)
- CONFIG_IP_NF_FILTER: enabled (as module)
- CONFIG_IP_NF_TARGET_MASQUERADE: enabled (as module)
- CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: enabled (as module)
- CONFIG_NETFILTER_XT_MATCH_CONNTRACK: enabled (as module)
- CONFIG_NF_NAT: enabled (as module)
- CONFIG_NF_NAT_NEEDED: enabled
- CONFIG_POSIX_MQUEUE: enabled

Optional Features:
- CONFIG_USER_NS: missing
- CONFIG_SECCOMP: missing
- CONFIG_CGROUP_PIDS: missing
- CONFIG_MEMCG_KMEM: enabled
- CONFIG_MEMCG_SWAP: enabled
- CONFIG_MEMCG_SWAP_ENABLED: enabled
- CONFIG_BLK_CGROUP: enabled
- CONFIG_IOSCHED_CFQ: enabled
- CONFIG_BLK_DEV_THROTTLING: enabled
- CONFIG_CGROUP_PERF: enabled
- CONFIG_CGROUP_HUGETLB: missing
- CONFIG_NET_CLS_CGROUP: missing
- CONFIG_CGROUP_NET_PRIO: missing
- CONFIG_CFS_BANDWIDTH: enabled
- CONFIG_FAIR_GROUP_SCHED: enabled
- CONFIG_RT_GROUP_SCHED: enabled
- CONFIG_EXT3_FS: missing
- CONFIG_EXT3_FS_XATTR: missing
- CONFIG_EXT3_FS_POSIX_ACL: missing
- CONFIG_EXT3_FS_SECURITY: missing
    (enable these ext3 configs if you are using ext3 as backing filesystem)
- CONFIG_EXT4_FS: enabled
- CONFIG_EXT4_FS_POSIX_ACL: enabled
- CONFIG_EXT4_FS_SECURITY: enabled
- Storage Drivers:
  - &amp;quot;aufs&amp;quot;:
    - CONFIG_AUFS_FS: missing
  - &amp;quot;btrfs&amp;quot;:
    - CONFIG_BTRFS_FS: enabled
  - &amp;quot;devicemapper&amp;quot;:
    - CONFIG_BLK_DEV_DM: missing
    - CONFIG_DM_THIN_PROVISIONING: missing
  - &amp;quot;overlay&amp;quot;:
    - CONFIG_OVERLAY_FS: enabled (as module)
  - &amp;quot;zfs&amp;quot;:
    - /dev/zfs: missing
    - zfs command: missing
    - zpool command: missing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This report tells us that the kernel 4.4.5 provided by Armbian is quite well,
but it&amp;rsquo;s not perfectly optimized for Docker usage. Anyway, we&amp;rsquo;ll give it a try
and will see how far we can go before we&amp;rsquo;re trying to optimize the kernel settings
even further.&lt;/p&gt;

&lt;p&gt;As this board has a standard ARMv7 CPU we can easily install the Docker Engine from
the Hypriot package repository. BTW, that&amp;rsquo;s exactly the same version we&amp;rsquo;re running
on all the Raspberry Pi&amp;rsquo;s, ODROID&amp;rsquo;s and other ARMv6 or ARMv7 boards as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install -y apt-transport-https
wget -q https://packagecloud.io/gpg.key -O - | apt-key add -
echo &#39;deb https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy main&#39; &amp;gt;&amp;gt; /etc/apt/sources.list.d/hypriot.list
apt-get update
apt-get install -y docker-hypriot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;rsquo;s check the Docker version and infos and see if all is installed the
right way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker version
Client:
 Version:      1.10.3
 API version:  1.22
 Go version:   go1.4.3
 Git commit:   20f81dd
 Built:        Thu Mar 10 22:23:48 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.10.3
 API version:  1.22
 Go version:   go1.4.3
 Git commit:   20f81dd
 Built:        Thu Mar 10 22:23:48 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.10.3
Storage Driver: overlay
 Backing Filesystem: extfs
Execution Driver: native-0.2
Logging Driver: json-file
Plugins:
 Volume: local
 Network: host bridge null
Kernel Version: 4.4.5-marvell
Operating System: Debian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 2
Total Memory: 1004 MiB
Name: armada
ID: CH4K:7X5P:SF47:C6NN:CRIF:OIUS:66TM:PJFL:D5ET:APW2:KCKT:DWBT
Debug mode (server): true
 File Descriptors: 12
 Goroutines: 20
 System Time: 2016-03-16T16:34:52.01930928Z
 EventsListeners: 0
 Init SHA1: 0db326fc09273474242804e87e11e1d9930fb95b
 Init Path: /usr/lib/docker/dockerinit
 Docker Root Dir: /var/lib/docker
WARNING: No memory limit support
WARNING: No swap limit support
WARNING: No oom kill disable support
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perfect! As you can see, we do have now the latest Docker Engine release v1.10.3 up and running
on the ClearFog Pro. And it&amp;rsquo;s using Overlay filesystem which is really great. But
there are also some warnings displayed - this will be fixed later with our own
Linux distro HypriotOS.&lt;/p&gt;

&lt;p&gt;Checking the status of the &lt;code&gt;docker service&lt;/code&gt; reveals, that the service is running
but it&amp;rsquo;s not enabled yet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl status docker
● docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; disabled)
   Active: active (running) since Wed 2016-03-16 16:34:27 UTC; 49s ago
     Docs: https://docs.docker.com
 Main PID: 4219 (docker)
   CGroup: /system.slice/docker.service
           └─4219 /usr/bin/docker daemon -H fd:// --storage-driver=overlay -D...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus we should enable it to get the Docker Engine automatically started on the next
reboot of the board.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable docker
Synchronizing state for docker.service with sysvinit using update-rc.d...
Executing /usr/sbin/update-rc.d docker defaults
Executing /usr/sbin/update-rc.d docker enable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, this was really damn easy. Nothing complicated and nothing special until now.
It seems that with Armbian the Docker Engine 1.10.3 is just running almost out-of-the-box.&lt;/p&gt;

&lt;h3 id=&#34;running-the-first-docker-container:df574ad27518dffc38341295be8d9782&#34;&gt;Running the first Docker container&lt;/h3&gt;

&lt;p&gt;Now, we&amp;rsquo;d like to start a first Docker container and we&amp;rsquo;re just using a very small
web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
c6bf2a8a534dea6b5afd2cf466ed1828bae2f77ba06e7563732e3b416c607d6b
[  705.631098] device vethe5d37f3 entered promiscuous mode
[  705.636762] IPv6: ADDRCONF(NETDEV_UP): vethe5d37f3: link is not ready
[  706.011850] eth0: renamed from veth4dd291a
[  706.052008] IPv6: ADDRCONF(NETDEV_CHANGE): vethe5d37f3: link becomes ready
[  706.058946] docker0: port 1(vethe5d37f3) entered forwarding state
[  706.065096] docker0: port 1(vethe5d37f3) entered forwarding state
[  706.071820] IPv6: ADDRCONF(NETDEV_CHANGE): docker0: link becomes ready
[  706.095771] devpts: called with bogus options
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, the web server seems to be running fine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps -a
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                NAMES
c6bf2a8a534d        hypriot/rpi-busybox-httpd   &amp;quot;/bin/busybox httpd -&amp;quot;   21 seconds ago      Up 19 seconds       0.0.0.0:80-&amp;gt;80/tcp   sharp_hugle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can check the web server via a simple &lt;code&gt;curl&lt;/code&gt; command on the ClearFog console or
from the MacBookPro.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl 192.168.2.108
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Pi armed with Docker by Hypriot&amp;lt;/title&amp;gt;
  &amp;lt;body style=&amp;quot;width: 100%; background-color: black;&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;main&amp;quot; style=&amp;quot;margin: 100px auto 0 auto; width: 800px;&amp;quot;&amp;gt;
      &amp;lt;img src=&amp;quot;pi_armed_with_docker.jpg&amp;quot; alt=&amp;quot;pi armed with docker&amp;quot; style=&amp;quot;width: 800px&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, we just point our web browser with &lt;code&gt;open http://192.168.2.108/&lt;/code&gt; to the main web page.
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-part2/clearfog-pro-webbrowser.jpg&#34; alt=&#34;ClearFog Pro WebBrowser&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;current-status-and-key-takeaways:df574ad27518dffc38341295be8d9782&#34;&gt;Current status and key takeaways&lt;/h3&gt;

&lt;p&gt;The web site of SolidRun says, they&amp;rsquo;re supporting a Linux kernel 3.x only and this would
be way too old and outdated. But luckily we figured out there is already support for
the very latest Linux kernel 4.x versions available. SolidRun has an own kernel repo
on GitHub where you can find all the changes and patches, these patches are already
included by Armbian as well.&lt;/p&gt;

&lt;p&gt;We just double-checked this directly with SolidRun and they told us, they&amp;rsquo;re already
working on it, to get all the Marvell related kernel patches for the ClearFog Pro
into the mainline Linux kernel. They plan to get everything merged into LK 4.6. This could
maybe mean that not all the special features of the board will be supported right now
with a kernel 4.x, but we&amp;rsquo;ll test this later on.&lt;/p&gt;

&lt;p&gt;This engagement of SolidRun sounds pretty fantastic and we highly encourage them to proceed
with this strategy. With supporting the latest mainline Linux kernel with hopefully
all hardware features this could become one of the best router boards on the market.
It&amp;rsquo;s powerful with high-speed networking and supports Docker container technology too.&lt;/p&gt;

&lt;h3 id=&#34;next-steps:df574ad27518dffc38341295be8d9782&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;The Linux kernel and SD image provided by Armbian looks really good at this point
and can be used for the first steps with Docker. But we think there is almost a
lot of room for improvements which we&amp;rsquo;d like to pick up and optimize the kernel
settings. As soon as this ground work is done, we&amp;rsquo;ll create a SD card image with
HypriotOS for the ClearFog Pro router board and release this soon.&lt;/p&gt;

&lt;p&gt;But this will be covered in the next detailed posts of this series, so please
stay tuned&amp;hellip;&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker Sensor Fu on a Raspberry Pi</title>
      <link>http://blog.hypriot.com/post/docker-sensor-fu-on-a-raspberry-pi/</link>
      <pubDate>Tue, 15 Mar 2016 23:02:30 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/docker-sensor-fu-on-a-raspberry-pi/</guid>
      <description>&lt;p&gt;For many people it comes as a surprise that one can access all the hardware of an IoT device from within a Docker container.
Interestingly enough Docker is a perfect tool for managing and distributing IoT development and production environments.&lt;/p&gt;

&lt;p&gt;To illustrate this use case we are going to create a Docker image that allows us to read the data from a temperature sensor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/docker-sensor-fu-on-a-raspberry-pi/temperature.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;

&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/tmib/3336410263/in/photolist-65PYwT-hKwdXx-6Gvfse-8sZyde-hKwe8n-bsrVBM-aTuQm-suTVL-4keeLT-9HAaQv-6owaBS-pcKw75-ktYU9-7fCvHx-aMp4hZ-9CJPmM-5kQCwW-9uhoBD-i6h8R-8eACxB-73fGHE-ecUmhW-4ayKHW-coQnPs-x2g2w-qTtWEg-6afv15-7zQM2j-coQoDf-6uLDRM-5srT3L-hpQH9p-q1QZca-9S8ygg-mHCs1e-aZ3SJT-b3ejpi-qvDRpB-mBUjjp-mJTYFr-nhZUoo-6dRUnb-9tuUnt-eMRL2K-6K6ars-dhBwB7-5Cr4jF-5rq6uU-yzubv-q7g6xP&#34;&gt;tmib_seattle&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;To follow along you gonna need:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a Raspberry Pi 1, 2 or 3&lt;/li&gt;
&lt;li&gt;our HypriotOS &lt;a href=&#34;https://downloads.hypriot.com/hypriot-rpi-20160306-192317.img.zip&#34;&gt;SD card image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;a DHT22 temperature sensor, which you can buy at &lt;a href=&#34;http://www.amazon.de/gp/product/B00LHJUU1M?psc=1&amp;amp;redirect=true&amp;amp;ref_=oh_aui_detailpage_o02_s00&#34;&gt;Amazon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From the hardware side we need to first attach the sensor to our Raspberry Pi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/docker-sensor-fu-on-a-raspberry-pi/temperature_sensor.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Looking at the picture of the sensor from left to right we need to attach&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the yellow cable to the 3,3V Pin of the RPi (Pin 1)&lt;/li&gt;
&lt;li&gt;the green cable (data) to one of the many GPIO; here it is GPIO2 (Pin 3)&lt;/li&gt;
&lt;li&gt;and finally the blue cable to GND (Pin 6)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The information in brackets corresponds to the pin numbers in this &lt;a href=&#34;http://raspi.tv/wp-content/uploads/2013/07/Rev2-GPIO-bold.jpg&#34;&gt;GPIO overview image&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/docker-sensor-fu-on-a-raspberry-pi/sensor_connected_to_pi.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;After our hardware is settled we need to look at the software side of things.&lt;/p&gt;

&lt;p&gt;As foundation for our next steps we will use the &lt;a href=&#34;http://wiringpi.com/&#34;&gt;WiringPi&lt;/a&gt; project.
WiringPi is a library that allows to access the GPIO (General Purpose Input Output) connectors of the Raspberry Pi.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s put WiringPi into a Docker image, shall we?&lt;/p&gt;

&lt;p&gt;The Dockerfile for this looks like this:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/Govinda-Fichtner/1d48543a6b9c2e21b7c1.js?file=Dockerfile.start&#34;&gt;&lt;/script&gt;

&lt;p&gt;Using this Dockerfile we can now build our image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t hypriot/wiringpi:latest .
...
$ docker images
REPOSITORY                            TAG                 IMAGE ID            CREATED             SIZE
hypriot/wiringpi                      latest              599e98bd4c20        30 seconds ago      302.2 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the image has everything that we need to compile software. On top of that it also has the WiringPi libraries on board.&lt;/p&gt;

&lt;p&gt;Next we can run this image to build the software that actually reads the sensor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --device /dev/ttyAMA0:/dev/ttyAMA0 --device /dev/mem:/dev/mem --privileged -ti hypriot/wiringpi bash
root@84f66e14df05:/data#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test if we can access the GPIO&amp;rsquo;s we can run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@84f66e14df05:/data# gpio readall
 +-----+-----+---------+------+---+---Pi 2---+---+------+---------+-----+-----+
 | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |
 +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+
 |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |
 |   2 |   8 |   SDA.1 |   IN | 1 |  3 || 4  |   |      | 5V      |     |     |
 |   3 |   9 |   SCL.1 |   IN | 1 |  5 || 6  |   |      | 0v      |     |     |
 |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 1 | ALT0 | TxD     | 15  | 14  |
 |     |     |      0v |      |   |  9 || 10 | 1 | ALT0 | RxD     | 16  | 15  |
 |  17 |   0 | GPIO. 0 |   IN | 0 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |
 |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |
 |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |
 |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |
 |  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |
 |   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |
 |  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |
 |     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |
 |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |
 |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |
 |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |
 |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |
 |  19 |  24 | GPIO.24 |   IN | 0 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |
 |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |
 |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |
 +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+
 | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |
 +-----+-----+---------+------+---+---Pi 2---+---+------+---------+-----+-----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far so good.&lt;/p&gt;

&lt;p&gt;Now we need to clone the source of our sensor reading software:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@84f66e14df05:/data# git clone https://github.com/technion/lol_dht22
root@84f66e14df05:/data# cd lol_dht22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To compile the lol_dht22 software we do the usual &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@84f66e14df05:/data/lol_dht22# ./configure
...
root@84f66e14df05:/data/lol_dht22# make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should produce a small executable that we can now test.&lt;/p&gt;

&lt;p&gt;If you followed the wiring instructions above closely you should now be able to read the temperature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@84f66e14df05:/data/lol_dht22# ./loldht 8
Raspberry Pi wiringPi DHT22 reader
www.lolware.net
Humidity = 34.00 % Temperature = 22.80 *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome. We just have been accessing the hardware sensor that is attached to our Pi from inside a Docker container.&lt;/p&gt;

&lt;p&gt;So why is this so exciting? Well, it basically allows us to deploy our sensor reading software easily and reliably to every device that is running a Docker Engine.
No installation hassle. No dependency hell.&lt;/p&gt;

&lt;p&gt;For that we need to extend our Dockerfile and add&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUN git clone https://github.com/technion/lol_dht22
RUN cd lol_dht22 &amp;amp;&amp;amp; ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; mv ./lol_dht22 /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The finished file looks like this:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/Govinda-Fichtner/1d48543a6b9c2e21b7c1.js?file=Dockerfile.final&#34;&gt;&lt;/script&gt;

&lt;p&gt;After rebuilding the image with this updated Dockerfile we can now run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --device /dev/ttyAMA0:/dev/ttyAMA0 --device /dev/mem:/dev/mem --privileged -ti hypriot/wiringpi /loldht 8
Raspberry Pi wiringPi DHT22 reader
www.lolware.net
Data not good, skip
Humidity = 35.00 % Temperature = 22.00 *C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it just works&amp;trade;.&lt;/p&gt;

&lt;p&gt;The finished image can be found at the &lt;a href=&#34;https://hub.docker.com/r/hypriot/wiringpi/&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing the new ClearFog Pro Router Board from SolidRun</title>
      <link>http://blog.hypriot.com/post/introducing-the-clearfog-pro-router-board/</link>
      <pubDate>Mon, 14 Mar 2016 23:38:42 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/introducing-the-clearfog-pro-router-board/</guid>
      <description>

&lt;p&gt;Could you imagine to run a standard Linux OS and your applications of choice securely
within Docker containers on a beefy WiFi router at home?&lt;/p&gt;

&lt;p&gt;We think this will be possible soon with this new ARM-based router board from SolidRun.
Thus we&amp;rsquo;ll spent a whole blog post series to install our Debian-based HypriotOS
and get Docker running on this Marvell ARMADA powered Single Board Computer (SBC).&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s get started and for our first episode in this series we&amp;rsquo;ll dive deep into
the technical specifications of the ClearFog Pro in order to get to know this neat
little device.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-overview.jpg&#34; alt=&#34;ClearFog Pro Overview&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;But be prepared, this one is really a powerful beast&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-overview-01.jpg&#34; alt=&#34;ClearFog Pro Overview&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;technical-specifications:568e70a5f9d2a7d5ec5b5140013e90f2&#34;&gt;Technical specifications&lt;/h3&gt;

&lt;p&gt;The ClearFog is based upon the Marvell ARMADA 380 or 388 processors. The CPU is a
single or dual core ARMv7 processor (Cortex A9) @ up to 1.6 GHz with 1MB L2 cache,
NEON and FPU.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Features&lt;/th&gt;
&lt;th&gt;ClearFog Base*&lt;/th&gt;
&lt;th&gt;ClearFog Pro&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.solid-run.com/marvell-armada-family/armada-som-system-on-module/&#34;&gt;SoC Model&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ARMADA based A380/A388&lt;/td&gt;
&lt;td&gt;ARMADA based A380/A388&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Memory &amp;amp; Storage&lt;/td&gt;
&lt;td&gt;256MB (A380)/1GB (A388)&lt;/td&gt;
&lt;td&gt;256MB (A380)/1GB (A388)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;M.2**&lt;/td&gt;
&lt;td&gt;M.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8GB microSD&lt;/td&gt;
&lt;td&gt;8GB microSD&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4GB eMMC (optional)&lt;/td&gt;
&lt;td&gt;4GB eMMC (optional)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Connectivity&lt;/td&gt;
&lt;td&gt;1x mSATA/mPCIE&lt;/td&gt;
&lt;td&gt;2x mSATA/mPCIE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1x USB 3.0 port&lt;/td&gt;
&lt;td&gt;1x USB 3.0 port&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2x Port dedicated Ethernet&lt;/td&gt;
&lt;td&gt;1x Port dedicated Ethernet&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1x SFP (A388 Only)&lt;/td&gt;
&lt;td&gt;6x Port switched Ethernet&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1x SFP Ethernet&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;I/O and Misc.&lt;/td&gt;
&lt;td&gt;Analog Audio&lt;/td&gt;
&lt;td&gt;Analog Audio/TDM module support&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;GPIO Header (mikroBUS)&lt;/td&gt;
&lt;td&gt;GPIO Header (mikroBUS)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Indication LEDs&lt;/td&gt;
&lt;td&gt;Indication LEDs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;User Push Buttons&lt;/td&gt;
&lt;td&gt;User Push Buttons&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PoE expansion header&lt;/td&gt;
&lt;td&gt;PoE expansion header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;RTC Battery&lt;/td&gt;
&lt;td&gt;RTC Battery&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;FTDI (console only), Debug Header&lt;/td&gt;
&lt;td&gt;FTDI (console only), Debug Header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;JTAG Header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OS Support&lt;/td&gt;
&lt;td&gt;Linux Kernel 3.x, OpenWrt, Yocto&lt;/td&gt;
&lt;td&gt;Linux Kernel 3.x, OpenWrt, Yocto&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Power&lt;/td&gt;
&lt;td&gt;Wide range 9-32V&lt;/td&gt;
&lt;td&gt;Wide range 9-32V&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Advanced Power Control&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Fan Control&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Dimensions&lt;/td&gt;
&lt;td&gt;100mm x 74mm&lt;/td&gt;
&lt;td&gt;225mm x 100mm&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;*available soon&lt;br /&gt;
**M.2 includes USB 3.0 support (in carrier Base only)&lt;/p&gt;

&lt;p&gt;More details can be found at the
&lt;a href=&#34;https://www.solid-run.com/marvell-armada-family/clearfog/&#34;&gt;ClearFog Pro&lt;/a&gt; product page.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ClearFog Pro (top view)&lt;/em&gt;
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-components-top-view-1.jpg&#34; alt=&#34;ClearFog Pro Top View&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ClearFog Pro (buttom view)&lt;/em&gt;
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-components-bottom-view.jpg&#34; alt=&#34;ClearFog Pro Buttom View&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;technical-highlights:568e70a5f9d2a7d5ec5b5140013e90f2&#34;&gt;Technical highlights&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;passive cooling&lt;/li&gt;
&lt;li&gt;all Ethernet ports supporting up to 1GBit/s at least&lt;/li&gt;
&lt;li&gt;the SFP Ethernet port supports up to 2.5GBit/s&lt;/li&gt;
&lt;li&gt;mSATA or miniPCIe mode can be configured&lt;/li&gt;
&lt;li&gt;M.2 slot supports a 2242 form factor M.2 card (22mm x 42mm)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;first-impressions:568e70a5f9d2a7d5ec5b5140013e90f2&#34;&gt;First impressions&lt;/h3&gt;

&lt;p&gt;We think you&amp;rsquo;ll get it now - this device is somewhat special.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not a real end-user product and it&amp;rsquo;s therefore called a development board. But the
ClearFog Pro is already equipped with some best-in-class components and has a superior
build quality - once you see it in person you&amp;rsquo;ll gonna know what we&amp;rsquo;re talking about.&lt;/p&gt;

&lt;h3 id=&#34;lot-s-of-possibilities:568e70a5f9d2a7d5ec5b5140013e90f2&#34;&gt;Lot&amp;rsquo;s of possibilities&lt;/h3&gt;

&lt;p&gt;As you now know some of the technical details of the ClearFog Pro, you can clearly
imagine what could be possible with such a board.&lt;/p&gt;

&lt;p&gt;So, we&amp;rsquo;re listing here only a few possibilities to start the brain storming&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a high-speed WiFi router with a 802.11n or 802.11ac miniPCIe card&lt;/li&gt;
&lt;li&gt;a NAS system with mSATA or M.2 SSD disks&lt;/li&gt;
&lt;li&gt;a personal router and firewall&lt;/li&gt;
&lt;li&gt;an ownCloud server&lt;/li&gt;
&lt;li&gt;a streaming server for audio and video tracks&lt;/li&gt;
&lt;li&gt;or maybe all this above at once&lt;/li&gt;
&lt;li&gt;a powerful Docker host with insane network performance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;hellip;and finally we&amp;rsquo;d like to ask you:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;What would you like to build with a ClearFog Pro?&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; new follow-up posts&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part 2: &lt;a href=&#34;http://blog.hypriot.com/post/clearfog-pro-part-2-lets-run-docker/&#34;&gt;Let&amp;rsquo;s run Docker on the ClearFog Pro router board&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;P.S. this ClearFog Pro (ARMADA A388 w/ 1GByte memory) is already hooked up for testing in our labs
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-cabled.jpg&#34; alt=&#34;ClearFog Pro Cabled&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to build a traffic light</title>
      <link>http://blog.hypriot.com/post/traffic-light/</link>
      <pubDate>Sun, 13 Mar 2016 17:31:10 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/traffic-light/</guid>
      <description>

&lt;p&gt;My seven year old asked me how does a traffic light work. Before explaining too much we put some LEDs and wires together and did a hands-on tutorial. Finally we had a pedestrian crossing with a push button controlled by an app - of course - running dockerized on a Raspberry Pi 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/traffic-light.png&#34; alt=&#34;Traffic light wiring&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;the-hardware:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;The hardware&lt;/h2&gt;

&lt;p&gt;First we have to build the curcuit. To follow this tutorial you need these parts&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3, but any other is also good for this tutorial&lt;/li&gt;
&lt;li&gt;Adafruit T-Cobbler Plus&lt;/li&gt;
&lt;li&gt;Breadboard&lt;/li&gt;
&lt;li&gt;2x Red, 1x yellow and 2x green LEDs&lt;/li&gt;
&lt;li&gt;5x 220Ω resistors&lt;/li&gt;
&lt;li&gt;1x 1kΩ resistor&lt;/li&gt;
&lt;li&gt;1x 10kΩ resistor&lt;/li&gt;
&lt;li&gt;1x push button&lt;/li&gt;
&lt;li&gt;1x USB power for the Raspberry Pi&lt;/li&gt;
&lt;li&gt;cables&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-software:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;The software&lt;/h2&gt;

&lt;p&gt;The application is written in Python and it is based on the blog post &lt;a href=&#34;http://www.bobrathbone.com/pi_traffic_led.htm&#34;&gt;Raspberry PI Traffic Lights&lt;/a&gt; by Bob Rathbone. I have added some more LEDs and changed it to our local traffic light scheme. You can find the full source code &lt;a href=&#34;https://github.com/StefanScherer/docker-rpi-traffic-light&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;defining-the-gpio-pins:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Defining the GPIO pins&lt;/h3&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/pedestrian-crossing.py?slice=16:30&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;initializing-the-gpio-ports:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Initializing the GPIO ports&lt;/h3&gt;

&lt;p&gt;At the beginning of the app we initialize the GPIO ports and turn off all LEDs. They may turned on from aborting a previous run.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/pedestrian-crossing.py?slice=31:48&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;main-loop:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Main loop&lt;/h3&gt;

&lt;p&gt;The main loop begins with green lights for the cars. In this state the button for the pedestrian crossing is checked.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/pedestrian-crossing.py?slice=49:64&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;pedestrian-crossing:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Pedestrian crossing&lt;/h3&gt;

&lt;p&gt;After the button has been pressed the next code block just changes the LEDs for the cars to red, green for pedestrians and back again.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/pedestrian-crossing.py?slice=64:&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;p&gt;That completes the whole app. I could explain how a traffic light works and my daughter could play with it for a while. This could be the whole story, but as I&amp;rsquo;ve deployed my app with Docker there is another story behind the story.&lt;/p&gt;

&lt;h1 id=&#34;dockerize-all-the-things:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Dockerize all the things&lt;/h1&gt;

&lt;p&gt;I want to save my work and make it reproducible for me and others. So beside putting the source code into a GitHub repo I also dockerized the application development and deployment. With the help of Docker and the Docker tools it is very easy to develop from eg. a MacBook.&lt;/p&gt;

&lt;p&gt;Even after months and other projects it is easy to spin up that application again as there is a standardized way. There also is no need to backup the SD image and write down what you had to install on your Raspberry Pi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/mac_rpi_development.png&#34; alt=&#34;Developing for RPi from a Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As shown in the diagram your Notebook should have the following tools installed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;&lt;/strong&gt; to flash the SD card image with HypriotOS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://docs.docker.com/machine/overview/&#34;&gt;Docker Machine&lt;/a&gt;&lt;/strong&gt; to build a secured connection to the Raspberry Pi Docker Engine&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://docs.docker.com/compose/overview/&#34;&gt;Docker Compose&lt;/a&gt;&lt;/strong&gt; to easily start dockerized apps with a single command&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://docs.docker.com&#34;&gt;Docker Client&lt;/a&gt;&lt;/strong&gt; to run other Docker commands&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I don&amp;rsquo;t get into the details on how to connect your Notebook with the Docker Engine on the Raspberry Pi. This is part of a &lt;a href=&#34;http://blog.hypriot.com/post/how-to-setup-rpi-docker-swarm/&#34;&gt;previous blog post&lt;/a&gt; how to use docker-machine for that.&lt;/p&gt;

&lt;h2 id=&#34;dockerfile:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Dockerfile&lt;/h2&gt;

&lt;p&gt;To build the Docker image we need a Dockerfile. We use a Python base image and install the needed tools and dependencies. Then we add the application source code and define the command to execute.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/Dockerfile?footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;docker-compose-yml:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;docker-compose.yml&lt;/h2&gt;

&lt;p&gt;Docker Compose can be used to simplify running the container. With the docker-compose.yml we can document all the parameters needed to start the container. The file is versioned in Git so we do not forget how to run this container.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/docker-compose.yml?footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;developing-the-app:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Developing the app&lt;/h2&gt;

&lt;p&gt;When you develop the app or want to modify the source code the Docker image has to be rebuilt with the new code. To do this just run this command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose build
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-the-app:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Running the app&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;docker-compose up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to stop the app again, just press &lt;code&gt;CTRL+C&lt;/code&gt;. You may have to press it twice to kill the app.&lt;/p&gt;

&lt;h2 id=&#34;running-permanently:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Running permanently&lt;/h2&gt;

&lt;p&gt;You can run the application automatically by adding &lt;code&gt;-d&lt;/code&gt;. The docker-compose.yml also sets the restart policy to always, so the container is starting right after booting the Raspberry Pi. This is very useful for such hardware projects which should start automatically after turning on your Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to stop the app again, just use this command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose kill
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sharing-the-dockerized-app:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Sharing the dockerized app&lt;/h2&gt;

&lt;p&gt;The advantage of using Docker is to easily share the dockerized app with others. As the developer of an app you just push the Docker image with to the Docker Hub. Others can pull this Docker image from there and run it without to know which tools and dependencies to install.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/mac_rpi_docker_push.png&#34; alt=&#34;Developing for RPi from a Mac&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;pushing-the-docker-image:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Pushing the Docker image&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;docker images
docker tag dockerrpitrafficlight_trafficlight stefanscherer/rpi-traffic-light
docker push stefanscherer/rpi-traffic-light
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Docker image is send sent to the Docker Hub. My example is available as image &lt;a href=&#34;https://hub.docker.com/r/stefanscherer/rpi-traffic-light/&#34;&gt;stefanscherer/rpi-traffic-light&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;sharing-with-others:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Sharing with Others&lt;/h2&gt;

&lt;p&gt;If someone else wants to build the traffic light and run your application, she has to use this little modified docker-compose.yml to pull the published Docker image instead of building it herself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;2&#39;
services:
  trafficlight:
    image: stefanscherer/rpi-traffic-light
    devices:
      - &amp;quot;/dev/mem:/dev/mem&amp;quot;
    cap_add:
      - SYS_RAWIO
    restart: always
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then run the application with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or use the docker command with all the parameters&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm --cap-add SYS_RAWIO --device /dev/mem stefanscherer/rpi-traffic-light
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command pulls the Docker image from the Docker hub if it isn&amp;rsquo;t available locally on the Raspberry Pi. After that it runs a Docker container with the application.&lt;/p&gt;

&lt;p&gt;In this way any app can be published in the same way, regardless the programming language used.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;
&lt;div class=&#34;title&#34;&gt;Building a traffic light with Raspberry Pi 3&lt;/div&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/traffic-light/hardwired.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/thumbnails/thumb_hardwired.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;First hardwired setup. Pull the wires to switch lights.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    First hardwired setup. Pull the wires to switch lights.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/traffic-light/cars-green.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/thumbnails/thumb_cars-green.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Cars have green, pedestrians have to wait.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Cars have green, pedestrians have to wait.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/traffic-light/push-button.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/thumbnails/thumb_push-button.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Push the button!&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Push the button!
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/traffic-light/walk.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/thumbnails/thumb_walk.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Cars have to stop, pedestrian may cross the road.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Cars have to stop, pedestrian may cross the road.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/traffic-light/drive.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/thumbnails/thumb_drive.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Safely crossed the street. Cars driving again.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Safely crossed the street. Cars driving again.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/traffic-light/raspberry-pi3-edimax.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/thumbnails/thumb_raspberry-pi3-edimax.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Raspberry Pi 3 running traffic light app. Edimax as workaround, soon onboard WiFi support.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Raspberry Pi 3 running traffic light app. Edimax as workaround, soon onboard WiFi support.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/traffic-light/development.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/traffic-light/thumbnails/thumb_development.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Build, Ship and Run from a Mac&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Build, Ship and Run from a Mac
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exciting Docker Swarm experiments in the Hypriot Cluster Lab</title>
      <link>http://blog.hypriot.com/post/exciting-docker-swarm-experiments-in-the-hypriot-cluster-lab/</link>
      <pubDate>Thu, 10 Mar 2016 23:00:00 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/exciting-docker-swarm-experiments-in-the-hypriot-cluster-lab/</guid>
      <description>&lt;p&gt;This post is - like the &lt;a href=&#34;http://blog.hypriot.com/post/how-to-setup-rpi-docker-swarm/&#34;&gt;last one&lt;/a&gt; - dedicated to the &lt;a href=&#34;https://blog.docker.com/2016/03/swarmweek-join-your-first-swarm/&#34;&gt;Docker #SwarmWeek&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you thought that it was pretty easy to set up a Swarm Cluster after our last post - you are going to be pretty surprised to find out that there is still room for improvement.&lt;/p&gt;

&lt;p&gt;With our &lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;Hypriot Cluster Lab&lt;/a&gt; it is possible to get up a Swarm Cluster with just one command.
Follow along to learn how this is possible.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/swarm-cluster-lab/cluster_lab.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;

&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/snre/10579433974/in/photolist-h7Sn93-4A4CPY-cr7gZ3-ySfs-Q2aKL-Q2GvM-akjGfr-6cX1D7-7Z4GYE-8XKoBo-82k2PZ-5J8yhX-7Sct35-h7SfKJ-h7SmSb-h7S44X-5J8y5a-4Y8HsH-p1Sz3h-4A4wom-4Bw54x-gQ23WX-iKWTQA-8D8m59-6PgZhg-8tKzAS-4kvY6K-9kaX8z-54x1BV-5xh7Sb-bLXPYZ-4zQ8mN-7KjCAt-MSdyd-qAw4Hw-awH1nc-4tKyxG-5wWtGU-4LMU7v-7NkBns-9a3pwX-h7Tuik-iAjqa-rvTgXa-h7S5uT-h7Shc1-qL7ofi-a18dLe-5RVXPz-8gLV&#34;&gt;SNRE Labs&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;The Hypriot Cluster Lab has already been there for while as an easy way to set up a Swarm Cluster on Raspberry Pi&amp;rsquo;s.
The basic idea was to have a SD card image that can be used to boot up a couple of Pi&amp;rsquo;s who then automatically form a Swarm Cluster.
As with any Lab the Cluster Lab provides a place to run all kind of experiments and gain new insights.&lt;/p&gt;

&lt;p&gt;As part of our recent refactoring efforts to make the Cluster Lab more reliable we have been searching for ways to test the Cluster Lab as a whole.
The idea we came up was to use &lt;a href=&#34;https://www.vagrantup.com/&#34;&gt;Vagrant&lt;/a&gt; for our integration testing efforts.&lt;/p&gt;

&lt;p&gt;Vagrant is a tool that makes it really easy to manage Virtual Machines. It allows us to describe a multi-machine setup in an easy to read text-based configuration file:&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/hypriot/cluster-lab/raw/master/vagrant/Vagrantfile?slice=14:40&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;p&gt;One of the big advantages of Vagrant is that it is available for Mac, Linux and Windows users. This means that you can run the Cluster Lab on all those operating systems, too.&lt;/p&gt;

&lt;p&gt;To get started with the Hypriot Cluster Lab you need to ensure that you have a recent version of Vagrant installed.
If not you can download it &lt;a href=&#34;https://www.vagrantup.com/downloads.html&#34;&gt;here&lt;/a&gt;. Under the hood Vagrant uses a so-called provider to run the virtual machines.
For the Cluster Lab the recommended way is to use &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;. Make sure it is already there or download and install it.&lt;/p&gt;

&lt;p&gt;The next step is to clone the Hypriot Cluster Lab repository like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/hypriot/cluster-lab.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Afterwards change into the &lt;code&gt;cluster-lab/vagrant&lt;/code&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd cluster-lab/vagrant
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now comes the single command you need to boot up a whole working Swarm Cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant up --provider virtualbox --no-color
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will create three virtual machines based on Ubuntu Wily, install a recent Docker Engine and install and configure the Cluster Lab.
As this command will download Ubuntu Wily and lots of other software, too, it might take while. Please be patient.&lt;/p&gt;

&lt;p&gt;While the Cluster Lab is booting it will run a number of self-tests to ensure that it is working properly.
You should see output similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Internet Connection
  [PASS]   eth1 exists
  [PASS]   eth1 has an ip address
  [PASS]   Internet is reachable
  [PASS]   DNS works

Networking
  [PASS]   eth1 exists
  [PASS]   vlan os package exists
  [PASS]   Avahi os package exists
  [PASS]   Avahi-utils os package exists
  [PASS]   Avahi process exists
  [PASS]   Avahi cluster-leader.service file is absent

Configure basic networking

Networking
  [PASS]   eth1.200 exists
  [PASS]   eth1.200 has correct IP from vlan network
  [PASS]   Cluster leader is reachable
  [PASS]   eth1.200 has exactly one IP
  [PASS]   eth1.200 has no local link address
  [PASS]   Avahi process exists
  [PASS]   Avahi is using eth1.200
  [PASS]   Avahi cluster-leader.service file exists

This node is Leader

DHCP is enabled

DNSmasq
  [PASS]   dnsmasq os package exists
  [PASS]   dnsmasq process exists
  [PASS]   /etc/dnsmasq.conf backup file is absent

Configure DNSmasq

DNSmasq
  [PASS]   dnsmasq process exists
  [PASS]   /etc/dnsmasq.conf backup file exists

Docker
  [PASS]   docker is installed
  [PASS]   Docker process exists
  [PASS]   /etc/default/docker backup file is absent

Configure Docker

Docker
  [PASS]   Docker is running
  [PASS]   Docker is configured to use Consul as key-value store
  [PASS]   Docker is configured to listen via tcp at port 2375
  [PASS]   Docker listens on 192.168.200.30 via tcp at port 2375 (Docker-Engine)

Consul
  [PASS]   Consul Docker image exists
  [PASS]   Consul Docker container is running
  [PASS]   Consul is listening on port 8300
  [PASS]   Consul is listening on port 8301
  [PASS]   Consul is listening on port 8302
  [PASS]   Consul is listening on port 8400
  [PASS]   Consul is listening on port 8500
  [PASS]   Consul is listening on port 8600
  [PASS]   Consul API works
  [PASS]   Cluster-Node is pingable with IP 192.168.200.30
  [PASS]   Cluster-Node is pingable with IP 192.168.200.45
  [PASS]   Cluster-Node is pingable with IP 192.168.200.1
  [PASS]   No Cluster-Node is in status &#39;failed&#39;
  [PASS]   Consul is able to talk to Docker-Engine on port 7946 (Serf)

Swarm
  [PASS]   Swarm-Join Docker container is running
  [PASS]   Swarm-Manage Docker container is running
  [PASS]   Number of Swarm and Consul nodes is equal which means our cluster is healthy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything worked all tests should be [PASS]ing.
In case that there were [FAIL]ing tests you can fix it with the help of our &lt;a href=&#34;https://github.com/hypriot/cluster-lab#troubleshooting&#34;&gt;troubleshooting&lt;/a&gt; guide.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;vagrant up&lt;/code&gt; command creates three cluster nodes called &lt;strong&gt;leader&lt;/strong&gt;, &lt;strong&gt;follower1&lt;/strong&gt; and &lt;strong&gt;follower2&lt;/strong&gt;.
To work with the Swarm Cluster we need to log into one of the cluster nodes and elevate ourself to root:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant ssh leader
$ sudo su
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use the Swarm Cluster by exporting the TCP address of the Swarm Cluster with the DOCKER_HOST environment variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export DOCKER_HOST=tcp://192.168.200.1:3278
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all our Docker commands will work against the Swarm Cluster instead of the local Docker Engine.&lt;/p&gt;

&lt;p&gt;Lets check if we really have a 3-Node-Swarm Cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker info
Containers: 9
 Running: 9
 Paused: 0
 Stopped: 0
Images: 6
Role: primary
Strategy: spread
Filters: health, port, dependency, affinity, constraint
Nodes: 3
 follower1: 192.168.200.46:2375
  └ Status: Healthy
  └ Containers: 3
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 1.018 GiB
  └ Labels: executiondriver=native-0.2, hypriot.arch=x86_64, hypriot.hierarchy=follower, kernelversion=4.2.0-30-generic, operatingsystem=Ubuntu 15.10, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-10T21:24:07Z
 follower2: 192.168.200.44:2375
  └ Status: Healthy
  └ Containers: 3
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 1.018 GiB
  └ Labels: executiondriver=native-0.2, hypriot.arch=x86_64, hypriot.hierarchy=follower, kernelversion=4.2.0-30-generic, operatingsystem=Ubuntu 15.10, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-10T21:24:35Z
 leader: 192.168.200.1:2375
  └ Status: Healthy
  └ Containers: 3
  └ Reserved CPUs: 0 / 1
  └ Reserved Memory: 0 B / 1.018 GiB
  └ Labels: executiondriver=native-0.2, hypriot.arch=x86_64, hypriot.hierarchy=leader, kernelversion=4.2.0-30-generic, operatingsystem=Ubuntu 15.10, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-10T21:24:04Z
Plugins:
 Volume:
 Network:
Kernel Version: 4.2.0-30-generic
Operating System: linux
Architecture: amd64
CPUs: 3
Total Memory: 3.054 GiB
Name: 9c2606252982
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we really have a working Swarm Cluster running.
That was easy, was it?&lt;/p&gt;

&lt;p&gt;For more information about Docker Swarm you can follow the &lt;a href=&#34;https://blog.docker.com/2016/03/swarmweek-container-orchestration-docker-swarm/&#34;&gt;#SwarmWeek: Introduction to container orchestration with Docker Swarm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback, discuss this post on &lt;a href=&#34;https://news.ycombinator.com/item?id=11263205&#34;&gt;HackerNews&lt;/a&gt; and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to setup a Docker Swarm cluster with Raspberry Pi&#39;s</title>
      <link>http://blog.hypriot.com/post/how-to-setup-rpi-docker-swarm/</link>
      <pubDate>Tue, 08 Mar 2016 17:27:58 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/how-to-setup-rpi-docker-swarm/</guid>
      <description>

&lt;p&gt;This week is dedicated to &lt;a href=&#34;https://blog.docker.com/2016/03/swarmweek-join-your-first-swarm/&#34;&gt;Docker #SwarmWeek&lt;/a&gt;. In this tutorial we show you how easy it is to setup a Docker Swarm with HypriotOS and the standard &lt;code&gt;docker-machine&lt;/code&gt; binary.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/how-to-setup-rpi-docker-swarm/docker-swarm-logo.png&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;We want to setup a cluster with &lt;strong&gt;eight Raspberry Pi 3&lt;/strong&gt;, grouped into two tiny datacenters with four Pi&amp;rsquo;s each.&lt;/p&gt;

&lt;h2 id=&#34;prepare-your-notebook:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Prepare your notebook&lt;/h2&gt;

&lt;p&gt;To control the Docker Swarm from our notebook, we have to install both &lt;code&gt;docker&lt;/code&gt; and &lt;code&gt;docker-machine&lt;/code&gt; binaries. If you are on a Mac, you can use &lt;code&gt;brew&lt;/code&gt; to install them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install docker
brew install docker-machine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flash-all-your-sd-cards:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Flash all your SD cards&lt;/h2&gt;

&lt;p&gt;Now we can easily flash the latest HypriotOS image to the eight SD cards with our &lt;a href=&#34;https://github.com/hypriot/flash#installation&#34;&gt;flash tool&lt;/a&gt; and assign different node names.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --hostname swarm-dc1-pi01 https://downloads.hypriot.com/hypriot-rpi-20160306-192317.img.zip
flash --hostname swarm-dc1-pi02 https://downloads.hypriot.com/hypriot-rpi-20160306-192317.img.zip
...
flash --hostname swarm-dc2-pi04 https://downloads.hypriot.com/hypriot-rpi-20160306-192317.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that, insert the SD cards and boot all the Raspberry Pi&amp;rsquo;s.&lt;/p&gt;

&lt;h2 id=&#34;prepare-your-pi-s-for-docker-machine:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Prepare your Pi&amp;rsquo;s for docker-machine&lt;/h2&gt;

&lt;p&gt;We want to create the Docker Swarm with the standard &lt;code&gt;docker-machine&lt;/code&gt; binary. To make this work we need to prepare the Raspberry Pi&amp;rsquo;s a little bit. The next steps are adding your SSH public key to all of your Pi&amp;rsquo;s as well as fixing the ID in &lt;code&gt;/etc/os-release&lt;/code&gt; to &lt;code&gt;debian&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getip() { (traceroute $1 2&amp;gt;&amp;amp;1 | head -n 1 | cut -d\( -f 2 | cut -d\) -f 1) }

IP_ADDRESS=$(getip swarm-dc1-pi01.local)

ssh-keygen -R $IP_ADDRESS
ssh-copy-id -oStrictHostKeyChecking=no -oCheckHostIP=no root@$IP_ADDRESS

ssh root@$IP_ADDRESS sed -i \&#39;s/ID=raspbian/ID=debian/g\&#39; /etc/os-release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeat this for all the eight Raspberry Pi&amp;rsquo;s. You will prompted for the root password which is &lt;code&gt;hypriot&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;create-swarm-token:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Create Swarm Token&lt;/h2&gt;

&lt;p&gt;A Docker Swarm cluster uses a unique Cluster ID to enable all swarm agents find each other. We need such a Cluster ID to build our Docker Swarm. This can be done in your shell with this command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export TOKEN=$(for i in $(seq 1 32); do echo -n $(echo &amp;quot;obase=16; $(($RANDOM % 16))&amp;quot; | bc); done; echo)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-the-swarm-with-docker-machine:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Create the swarm with docker-machine&lt;/h2&gt;

&lt;p&gt;We now create the Swarm Master on the first Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-machine create -d generic \
  --engine-storage-driver=overlay --swarm --swarm-master \
  --swarm-image hypriot/rpi-swarm:latest \
  --swarm-discovery=&amp;quot;token://$TOKEN&amp;quot; \
  --generic-ip-address=$(getip swarm-dc1-pi01.local) \
  swarm-dc1-pi01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For all the seven remaining Raspberry Pi&amp;rsquo;s we create Swarm Agents that join the Swarm cluster.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-machine create -d generic \
  --engine-storage-driver=overlay --swarm \
  --swarm-image hypriot/rpi-swarm:latest \
  --swarm-discovery=&amp;quot;token://$TOKEN&amp;quot; \
  --generic-ip-address=$(getip swarm-dc1-pi02.local) \
  swarm-dc1-pi02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a while the whole Docker Swarm cluster with the two datacenters is up and running. We now have a cluster with &lt;strong&gt;32 CPU&amp;rsquo;s&lt;/strong&gt; and &lt;strong&gt;8 GByte RAM&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;control-your-swarm:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Control your Swarm&lt;/h2&gt;

&lt;p&gt;To connect to your Docker Swarm use the following command to set the environment variables for the Docker Client.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eval $(docker-machine env --swarm swarm-dc1-pi01)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/how-to-setup-rpi-docker-swarm/dc1-pi3.jpg&#34; alt=&#34;Datacenter 1&#34; /&gt;

&lt;img src=&#34;http://blog.hypriot.com/images/how-to-setup-rpi-docker-swarm/dc2-pi3.jpg&#34; alt=&#34;Datacenter 2&#34; /&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker info
Containers: 10
 Running: 9
 Paused: 0
 Stopped: 1
Images: 8
Server Version: swarm/1.1.3
Role: primary
Strategy: spread
Filters: health, port, dependency, affinity, constraint
Nodes: 8
 swarm-dc1-pi01: 192.168.1.207:2376
  └ Status: Healthy
  └ Containers: 3
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:47:03Z
 swarm-dc1-pi02: 192.168.1.209:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:56Z
 swarm-dc1-pi03: 192.168.1.206:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:22Z
 swarm-dc1-pi04: 192.168.1.208:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:51Z
 swarm-dc2-pi01: 192.168.1.204:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:35Z
 swarm-dc2-pi02: 192.168.1.205:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:49Z
 swarm-dc2-pi03: 192.168.1.210:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:40Z
 swarm-dc2-pi04: 192.168.1.211:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:37Z
Plugins:
 Volume:
 Network:
Kernel Version: 4.1.17-hypriotos-v7+
Operating System: linux
Architecture: arm
CPUs: 32
Total Memory: 7.592 GiB
Name: d90d49c65205
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/how-to-setup-rpi-docker-swarm/five-pi3.jpg&#34; alt=&#34;five pi3&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;For more information about Docker Swarm you can follow the &lt;a href=&#34;https://blog.docker.com/2016/03/swarmweek-container-orchestration-docker-swarm/&#34;&gt;#SwarmWeek: Introduction to container orchestration with Docker Swarm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/quintus23m&#34;&gt;@Quintus23M&lt;/a&gt; &amp;amp; Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HypriotOS 0.7.0 Berry - the Raspberry Pi Birthday release</title>
      <link>http://blog.hypriot.com/post/new-hypriotos-berry-with-rpi3-support/</link>
      <pubDate>Mon, 07 Mar 2016 09:03:23 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/new-hypriotos-berry-with-rpi3-support/</guid>
      <description>&lt;p&gt;We&amp;rsquo;ve just prepared a new beta release of HypriotOS 0.7.0 Berry which is based upon an updated 0.6.1 Hector. Feel free to check it out: &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;http://blog.hypriot.com/downloads/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/hypriotos-berry-rpi3/IMG_0763.jpeg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;basic support for Raspberry Pi 3 B (internal WiFi/BT is currently not supported)&lt;/li&gt;
&lt;li&gt;Linux kernel 4.1.17&lt;/li&gt;
&lt;li&gt;Docker Engine 1.10.2&lt;/li&gt;
&lt;li&gt;Docker Compose 1.6.2&lt;/li&gt;
&lt;li&gt;Swarm 1.1.3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This SD image still works on all available Raspberry Pi models (really!)&lt;/p&gt;

&lt;p&gt;We included all the latest Docker tools for you and especially the new Docker Swarm 1.1.3. Together with the brand-new powerful Raspberry Pi 3 B it makes to much fun to run Docker containers.&lt;/p&gt;

&lt;p&gt;Don’t forget, this week is Docker &lt;a href=&#34;https://twitter.com/hashtag/SwarmWeek?src=hash&#34;&gt;#SwarmWeek&lt;/a&gt;. Head over to &lt;a href=&#34;https://blog.docker.com/2016/02/swarmweek-is-coming/&#34;&gt;https://blog.docker.com/2016/02/swarmweek-is-coming/&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/hypriotos-berry-rpi3/IMG_0766.jpeg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;And with the help of Docker Swarm it’s just awesome to control a fleet of Raspberry Pi’s running your awesome distributed applications.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/quintus23m&#34;&gt;@Quintus23M&lt;/a&gt; &amp;amp; Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Run Docker on a Raspberry Pi 3 with onboard WiFi</title>
      <link>http://blog.hypriot.com/post/run-docker-rpi3-with-wifi/</link>
      <pubDate>Sat, 05 Mar 2016 16:04:12 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/run-docker-rpi3-with-wifi/</guid>
      <description>

&lt;p&gt;Today morning we finally got our Raspberry Pi 3&amp;rsquo;s from ThePiHut. They have been overwhelmed by the number of orders.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/rpi3-onboard-wifi/thepihut-delivery.jpg&#34; alt=&#34;ThePiHut delivery&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;While waiting for the delivery we already heard from our community that the current HypriotOS SD image does not boot.&lt;/p&gt;

&lt;p&gt;But with some little tweaks the first people have started running Docker containers with HypriotOS. We will update our image builder soon and publish a new HypriotOS image for an easy out-of-the-box experience.&lt;/p&gt;

&lt;p&gt;In the meantime for all the impatient out there I&amp;rsquo;ll give you a short intro how to run the latest Docker Engine on the standard Raspbian SD image.&lt;/p&gt;

&lt;h2 id=&#34;download-raspbian-lite:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Download Raspbian LITE&lt;/h2&gt;

&lt;p&gt;Just download and flash the Raspbian LITE image from &lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;https://www.raspberrypi.org/downloads/raspbian/&lt;/a&gt; or use our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;&lt;code&gt;flash&lt;/code&gt; script&lt;/a&gt; with this command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;flash https://downloads.raspberrypi.org/raspbian_lite_latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now boot your Raspberry Pi 3 and log into it with user &lt;code&gt;pi&lt;/code&gt; and the password &lt;code&gt;raspberry&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pi@raspberrypi.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard Raspbian image does not resize the SD filesystem automatically.&lt;/p&gt;

&lt;h2 id=&#34;add-the-overlay-kernel-module:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Add the overlay kernel module&lt;/h2&gt;

&lt;p&gt;Before we resize and reboot the Pi we also customize a little bit. The overlay kernel module must be loaded automatically while booting, so we just add it with the next command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &amp;quot;overlay&amp;quot; | sudo tee -a /etc/modules
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;customize-wifi:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Customize WiFi&lt;/h2&gt;

&lt;p&gt;If you want to run your Docker with the onboard WiFi, just add your SSID and pre-shared key with the next command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;network={
  ssid=&amp;quot;your-ssid&amp;quot;
  psk=&amp;quot;your-psk&amp;quot;
}&#39; | sudo tee -a /etc/wpa_supplicant/wpa_supplicant.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;resize-filesystem:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Resize filesystem&lt;/h2&gt;

&lt;p&gt;Now we have to resize the filesystem to install Docker and have space for Docker images and containers. Start &lt;code&gt;raspi-config&lt;/code&gt; and follow the steps to resize your filesystem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo raspi-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that let raspi-config reboot your Raspberry Pi.&lt;/p&gt;

&lt;h2 id=&#34;cut-the-wires:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Cut the wires&lt;/h2&gt;

&lt;p&gt;If you have added your WiFi settings, remove your network cable while rebooting. From now on you can connect to your Raspberry Pi 3 over the air.&lt;/p&gt;

&lt;h2 id=&#34;install-docker:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Install Docker&lt;/h2&gt;

&lt;p&gt;After rebooting, eventually unplugging the network cable we have to install Docker. The Raspbian Jessie distribution also has a Docker package, but it is only Version 1.3.3. So we install the Hypriot&amp;rsquo;s Docker 1.10.2 instead.&lt;/p&gt;

&lt;p&gt;Just log into your Raspberry Pi 3 again and install Docker with these commands.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh pi@raspberrypi.local
sudo apt-get install -y apt-transport-https
wget -q https://packagecloud.io/gpg.key -O - | sudo apt-key add -
echo &#39;deb https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy main&#39; | sudo tee /etc/apt/sources.list.d/hypriot.list
sudo apt-get update
sudo apt-get install -y docker-hypriot
sudo systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have a good setup until the next HypriotOS release is coming.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/rpi3-onboard-wifi/rpi3-raspbian-lite-docker-version.png&#34; alt=&#34;docker version&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;And with the onboard WiFi it is now very easy to build some mobile Docker IoT projects.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/rpi3-onboard-wifi/rpi3-over-the-air.jpg&#34; alt=&#34;docker over the air&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Docker running on a high-density ARMv8 development board from HiSilicon</title>
      <link>http://blog.hypriot.com/post/getting-docker-running-on-a-high-density-armv8-server-from-hisilicon/</link>
      <pubDate>Tue, 01 Mar 2016 15:59:56 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/getting-docker-running-on-a-high-density-armv8-server-from-hisilicon/</guid>
      <description>

&lt;p&gt;Running Docker containers on the latest high-density ARMv8 cloud servers lets
you operate your data center at lower costs and gives you the ability to scale
your business even faster. In this article we demonstrate the technical ground
work of compiling Docker and bootstrapping all the necessary development tools.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/hisilicon/d02-hisilicon.jpg&#34; alt=&#34;D02 HiSilicon&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;introduction:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;We at Hypriot are working hard to bring the Docker container technology to all major
ARM platforms. This journey started almost 15 months ago, when we tried to use
Docker the first time on a Raspberry Pi which lead to the first HypriotOS release
in February 2015.&lt;/p&gt;

&lt;p&gt;A couple of months ago Shameerali Kolothum Thodi (or Shameer for short) from HiSilicon,
a subsidiary of Huawei, contacted me and asked for help to get Docker running on
their brand-new ARMv8 development board. We agreed on a collaboration and I got remote access to a
&lt;a href=&#34;http://www.cnx-software.com/2015/02/16/hisilicon-d02-armv8-server-board/&#34;&gt;16-core ARMv8 Cortex-A57 machine&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;why-are-armv8-and-docker-a-perfect-fit:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Why are ARMv8 and Docker a perfect fit ?&lt;/h3&gt;

&lt;p&gt;With the hyper-growth that the major cloud service providers face, one of the biggest
challenges is to scale the computing power of their data centers to keep up with demand.
ARMv8 server technology promises to deliver major improvements that would allow to scale out
data center capacity even faster.&lt;/p&gt;

&lt;p&gt;In a recent article &lt;a href=&#34;http://www.nextplatform.com/2016/01/06/arm-servers-throwing-down-the-25-percent-share-gauntlet/&#34;&gt;ARM Servers: Throwing Down The 25 Percent Share Gauntlet&lt;/a&gt;
the author stated &lt;em&gt;&amp;ldquo;PayPal’s math showed that the X86 iron would cost 1.8X as much as the&amp;rdquo;&lt;/em&gt; ARMv8 &lt;em&gt;&amp;ldquo;machines, would consume 7X the power, and offer one-tenth the node density per rack. PayPal did not say how much cost savings – if any – came from the move to the&amp;rdquo;&lt;/em&gt; ARMv8 &lt;em&gt;&amp;ldquo;chips, but did say there was a “game changing” cost per watt per cubic foot benefit over the X86 machinery.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When we&amp;rsquo;re talking about high-density of the server hardware itself, we should
also talk about high-density of the software stack. With the help of Docker container
technology we&amp;rsquo;re able to increase the density of the software stack, too.
By combining both technologies we are able to increase the efficiency and get the
most out of our data center resources.&lt;/p&gt;

&lt;p&gt;One of the first new ARMv8 servers is the D02 development board from HiSilicon.&lt;/p&gt;

&lt;h3 id=&#34;hisilicon-d02-development-board-specs:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;HiSilicon D02 development board specs&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/hisilicon/d02-board.png&#34; alt=&#34;D02 Board&#34; /&gt;
&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Features&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Board&lt;/td&gt;
&lt;td&gt;SSI-EEB/E-ATX Compatible&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Processors&lt;/td&gt;
&lt;td&gt;16-core ARM Cortex-A57@max. 2.1GHz&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1MB L2 cache/cluster, 16MB L3 cache&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;supports ARMv8-A instruction set&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Memory/Flash&lt;/td&gt;
&lt;td&gt;2x Memory channel 4x DDR3 DIMM per CPU&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2x SPI Flash 16Mb BIOS/UEFI&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;128 MBytes Nor Flash&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Peripheral interfaces&lt;/td&gt;
&lt;td&gt;1x USB2.0 host port&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8x SAS3.0 ports&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1x ARM Tracer connector&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1x JTAG interface&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Expansion Capabilities&lt;/td&gt;
&lt;td&gt;2x 8 PCI express interfaces&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LAN&lt;/td&gt;
&lt;td&gt;2x &lt;sup&gt;10&lt;/sup&gt;&amp;frasl;&lt;sub&gt;100&lt;/sub&gt;/1000Mbps Ethernet ports&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2x xGE SFP+ ports (10Gb/s)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/hisilicon/d02-board-rear-panel.png&#34; alt=&#34;D02 Board rear panel&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The HiSilicon D02 board uses the UEFI/Kernel/Ubuntu rootfs, which is available for download at &lt;a href=&#34;http://open-estuary.org/&#34;&gt;http://open-estuary.org/&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;step-by-step-to-a-working-docker-installation:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Step-by-Step to a working Docker installation&lt;/h3&gt;

&lt;p&gt;TLDR; Go 1.6 and Docker 1.10.2 are running on ARMv8&lt;/p&gt;

&lt;h4 id=&#34;getting-to-know-the-installed-linux-os-and-the-armv8-hardware:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Getting to know the installed Linux OS and the ARMv8 hardware&lt;/h4&gt;

&lt;p&gt;As a first step when I&amp;rsquo;m connecting to a new ARM board I&amp;rsquo;d like to get some details
about the operating system and the hardware itself. With this known details it&amp;rsquo;s
easier to get a first impression about the capabilities and the performance of this
specific hardware.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s find out what we have with some standard Linux commands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ubuntu 15.04 ubuntu ttyS0

ubuntu login: root
Password:
Last login: Sun Feb 28 14:57:03 UTC 2016 on ttyS0
Welcome to Ubuntu 15.04 (GNU/Linux 4.1.6+ aarch64)

root@ubuntu:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the login prompt we can see that the board is running an &lt;code&gt;Ubuntu 15.04&lt;/code&gt; Linux OS which
is very common and nothing seems to be special, except the CPU architecture is different.
So let&amp;rsquo;s dig into this a little bit deeper and get some more details.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# uname -a
Linux ubuntu 4.1.6+ #2 SMP Thu Jan 14 22:33:10 IST 2016 aarch64 aarch64 aarch64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can recognize a recent Linux 4.1.6 kernel and the CPU architecture is listed
as &lt;code&gt;aarch64&lt;/code&gt; which turns out to be the architecture name that Linux uses for an &lt;code&gt;ARMv8&lt;/code&gt;
processor. This is in contrast to the ARMv6 and ARMv7 architectures which are
labeled as &lt;code&gt;armv6l&lt;/code&gt; or &lt;code&gt;armv7l&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It will be more interesting to get some details of the hardware itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /proc/meminfo
MemTotal:        8086304 kB
MemFree:         6883540 kB
MemAvailable:    7487700 kB
Buffers:          186196 kB
Cached:           344836 kB
SwapCached:            0 kB
Active:           475296 kB
Inactive:         129716 kB
Active(anon):      75208 kB
Inactive(anon):    24656 kB
Active(file):     400088 kB
Inactive(file):   105060 kB
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:         74092 kB
Mapped:            35568 kB
Shmem:             25876 kB
Slab:             174704 kB
SReclaimable:     141456 kB
SUnreclaim:        33248 kB
KernelStack:        3584 kB
PageTables:          816 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:     4043152 kB
Committed_AS:     328952 kB
VmallocTotal:   258998208 kB
VmallocUsed:       89648 kB
VmallocChunk:   258855996 kB
AnonHugePages:     59392 kB
CmaTotal:          16384 kB
CmaFree:            6120 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, we do have 8 GBytes of main memory for this HiSilicon D02 board, which
should be sufficient for our development work, but from the board specs we know,
this can be increased for a real production work load.&lt;/p&gt;

&lt;p&gt;But what about the ARMv8 CPU&amp;rsquo;s itself, let&amp;rsquo;s see how much of them are installed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /proc/cpuinfo
processor	: 0
Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32
CPU implementer	: 0x41
CPU architecture: 8
CPU variant	: 0x1
CPU part	: 0xd07
CPU revision	: 1

processor	: 1
Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32
CPU implementer	: 0x41
CPU architecture: 8
CPU variant	: 0x1
CPU part	: 0xd07
CPU revision	: 1

...

processor	: 15
Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32
CPU implementer	: 0x41
CPU architecture: 8
CPU variant	: 0x1
CPU part	: 0xd07
CPU revision	: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, an impressing number of 16 CPU cores can be found in this neat little
server machine. But this is only a single CPU as the D02 currently supports only a
single CPU socket. The D02 is designed to be used with two CPU sockets, but with
this hardware revision the board is only populated with a single CPU.&lt;/p&gt;

&lt;p&gt;To sum it up we currently have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a single ARMv8 CPU with 16x ARMv8 Cortex-A57 cores in total&lt;/li&gt;
&lt;li&gt;8 GByte of main memory&lt;/li&gt;
&lt;li&gt;Ubuntu 15.04 (Vivid Vervet) Linux operating system&lt;/li&gt;
&lt;li&gt;a recent Linux 4.1.6 kernel&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;installing-and-compiling-the-latest-go-version:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Installing and compiling the latest Go version&lt;/h4&gt;

&lt;p&gt;To compile Docker we need the very latest version of Go,
which is currently Go 1.6. You can find all available Go versions at
&lt;a href=&#34;https://golang.org/dl/&#34;&gt;The Go Programming Language - Downloads&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since the release 1.5 of the Go language, the Go compiler is written in pure
Go code and can be compiled itself with an earlier Go version -
and this is the recommended way.
As we are running an almost current Ubuntu version, the chances are high that
we can use the Go version that comes with the distribution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# apt-get update
# apt-get install -y golang-go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# go version
go version go1.4.2 gccgo (Ubuntu 5.1~rc1-0ubuntu1.1) 5.0.1 20150414 (prerelease) [gcc-5-branch revision 222102] linux/arm64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Go 1.4.2 we are able to bootstrap Go 1.6, which allows us to compile Docker.
So let&amp;rsquo;s proceed and get the install path of the Go binary which we will need later on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# which go
/usr/bin/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need the path &lt;code&gt;/usr&lt;/code&gt; where the Go compiler &lt;code&gt;/bin/go&lt;/code&gt; is located to start the bootstrap process.&lt;/p&gt;

&lt;p&gt;Next we are downloading the source code of the Go compiler and extracting it to
the default location &lt;code&gt;/usr/local/go&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then start the compile script and wait some time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# export GO_VERSION=1.6
# curl -sSL &amp;quot;https://storage.googleapis.com/golang/go${GO_VERSION}.src.tar.gz&amp;quot; | tar xz -C /usr/local
# cd /usr/local/go/src
# time GOROOT_BOOTSTRAP=/usr ./make.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As this is the first time that we compile something, we can get a first impression
of the performance of this 16-core ARMv8 machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Installed Go for linux/arm64 in /usr/local/go
Installed commands in /usr/local/go/bin

real	3m19.853s
user	5m22.660s
sys	9m15.532s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compiling the complete Go compiler within 9 minutes only!&lt;/p&gt;

&lt;p&gt;Now we do have Go 1.6 installed and it&amp;rsquo;s almost ready to use. The only thing we
have to do is to include the path to the Go compiler binaries into the standard
PATH environment variable. This can be done by including this code snippet into
our root users &lt;code&gt;~/.profile&lt;/code&gt; script.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# set PATH so it includes GO bin if it exists
if [ -d &amp;quot;/usr/local/go/bin&amp;quot; ] ; then
  PATH=&amp;quot;/usr/local/go/bin:$PATH&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the next login Go 1.6 should be enabled by default.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# go version
go version go1.6 linux/arm64

# which go
/usr/local/go/bin/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To avoid any conflicts with the old Go 1.4.2 version, we should remove it and
clean up the system. For this purpose we check which &lt;code&gt;golang&lt;/code&gt; packages were
installed previously.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# dpkg -l | grep golang
ii  golang-go                        2:1.3.3-1ubuntu4                  arm64        Go programming language compiler
ii  golang-src                       2:1.3.3-1ubuntu4                  arm64        Go programming language compiler - source files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now let&amp;rsquo;s remove them completely and double-ckeck if there is nothing left.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# apt-get --purge remove -y golang-go golang-src
# dpkg -l | grep golang
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a couple of commands we were able to install and compile the latest Go v1.6
compiler and it&amp;rsquo;s now ready to use.&lt;/p&gt;

&lt;h4 id=&#34;bootstrapping-the-docker-engine-the-first-time:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Bootstrapping the Docker Engine the first time&lt;/h4&gt;

&lt;p&gt;In order to compile Docker directly on our development board, we have to know the
different methods, how we can and how we should compile the Docker Engine.&lt;/p&gt;

&lt;p&gt;First of all, the official process to compile Docker is to run the complete
build process within a Docker container. But without an already running Docker Engine
on our dev machine, we cannot do this - that&amp;rsquo;s clear, right?&lt;/p&gt;

&lt;p&gt;For this purpose there is an easy, but not really well-known workaround.
We have to check and install the necessary development dependencies first and then
we can run the build script natively to get a first working Docker binary.
So, let&amp;rsquo;s do it right away.&lt;/p&gt;

&lt;p&gt;With the previous step we&amp;rsquo;ve already installed the most important dependency
with the Go 1.6 compiler, but we&amp;rsquo;ll need something more.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# apt-get install -y git-core
# apt-get install -y btrfs-tools libsqlite3-dev libdevmapper-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing these packages it&amp;rsquo;s a good practice to check and document all the
installed versions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# dpkg -l | grep -E &amp;quot;btrfs-tools|libsqlite3-dev|libdevmapper-d
ii  btrfs-tools                      3.17-1.1                          arm64        Checksumming Copy on Write Filesystem utilities
ii  libdevmapper-dev:arm64           2:1.02.90-2ubuntu1                arm64        Linux Kernel Device Mapper header files
ii  libsqlite3-dev:arm64             3.8.7.4-1ubuntu0.1                arm64        SQLite 3 development files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have already installed these packages previously, then it could also be
a good idea to upgrade them to the latest version.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# apt-get upgrade -y btrfs-tools libsqlite3-dev libdevmapper-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With hopefully all the necessary build dependencies installed now on our machine,
we can clone the Docker GitHub repo and compile Docker from it&amp;rsquo;s source code.&lt;/p&gt;

&lt;p&gt;As we know, the latest Docker release is &lt;code&gt;v1.10.2&lt;/code&gt;. That&amp;rsquo;s why we&amp;rsquo;re checking out
this tag.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mkdir -p ~/code
# cd ~/code
# git clone https://github.com/docker/docker
# cd docker
# git checkout v1.10.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here comes the magic trick to compile Docker natively on our host machine
without the need of having a Docker Engine already running.
This build will take a few minutes, and as long as we have all the necessary
dependencies installed it should succeed, too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# time AUTO_GOPATH=1 ./hack/make.sh dynbinary
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# WARNING! I don&#39;t seem to be running in the Docker container.
# The result of this command might be an incorrect build, and will not be
#   officially supported.
#
# Try this instead: make all
#

---&amp;gt; Making bundle: dynbinary (in bundles/1.10.2/dynbinary)
Created binary: bundles/1.10.2/dynbinary/dockerinit-1.10.2
Building: bundles/1.10.2/dynbinary/docker-1.10.2
Created binary: bundles/1.10.2/dynbinary/docker-1.10.2


real	3m58.883s
user	6m44.140s
sys	13m9.056s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SUCCESS, we&amp;rsquo;ve got it!&lt;/p&gt;

&lt;p&gt;Our first Docker binary is successfully compiled and we can use it right away.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# bundles/1.10.2/dynbinary/docker-1.10.2 -v
Docker version 1.10.2, build c3959b1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# bundles/1.10.2/dynbinary/docker-1.10.2 version
Client:
 Version:      1.10.2
 API version:  1.22
 Go version:   go1.6
 Git commit:   c3959b1
 Built:        Sun Feb 28 17:17:48 2016
 OS/Arch:      linux/arm64
Cannot connect to the Docker daemon. Is the docker daemon running on this host?
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;installing-the-docker-engine-on-armv8:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Installing the Docker Engine on ARMv8&lt;/h4&gt;

&lt;p&gt;To run Docker efficiently on a Linux OS, we first need to know if our Linux kernel supports
all the necessary kernel modules and is compiled with all the important kernel settings.
This isn&amp;rsquo;t easy and therefore the Docker developers are providing an easy-to-use
script. This script should be downloaded and run on the target machine and checks
all the important kernel settings for us and provides a complete summary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# wget https://github.com/docker/docker/raw/master/contrib/check-config.sh
# chmod +x check-config.sh
# ls -al check-config.sh
-rwxr-xr-x 1 root root 6984 Feb 28 20:09 check-config.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run a complete kernel check, just to make sure, we can run Docker without any problems.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ./check-config.sh
info: reading kernel config from /proc/config.gz ...

Generally Necessary:
- cgroup hierarchy: properly mounted [/sys/fs/cgroup]
- apparmor: enabled and tools installed
- CONFIG_NAMESPACES: enabled
- CONFIG_NET_NS: enabled
- CONFIG_PID_NS: enabled
- CONFIG_IPC_NS: enabled
- CONFIG_UTS_NS: enabled
- CONFIG_DEVPTS_MULTIPLE_INSTANCES: enabled
- CONFIG_CGROUPS: enabled
- CONFIG_CGROUP_CPUACCT: enabled
- CONFIG_CGROUP_DEVICE: enabled
- CONFIG_CGROUP_FREEZER: enabled
- CONFIG_CGROUP_SCHED: enabled
- CONFIG_CPUSETS: enabled
- CONFIG_MEMCG: enabled
- CONFIG_CONFIG_KEYS: missing
- CONFIG_MACVLAN: enabled
- CONFIG_VETH: enabled
- CONFIG_BRIDGE: enabled (as module)
- CONFIG_BRIDGE_NETFILTER: enabled (as module)
- CONFIG_NF_NAT_IPV4: enabled
- CONFIG_IP_NF_FILTER: enabled (as module)
- CONFIG_IP_NF_TARGET_MASQUERADE: enabled
- CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: enabled
- CONFIG_NETFILTER_XT_MATCH_CONNTRACK: enabled
- CONFIG_NF_NAT: enabled
- CONFIG_NF_NAT_NEEDED: enabled
- CONFIG_POSIX_MQUEUE: enabled

Optional Features:
- CONFIG_USER_NS: enabled
- CONFIG_SECCOMP: enabled
- CONFIG_MEMCG_KMEM: enabled
- CONFIG_MEMCG_SWAP: enabled
- CONFIG_MEMCG_SWAP_ENABLED: enabled
- CONFIG_BLK_CGROUP: enabled
- CONFIG_IOSCHED_CFQ: enabled
- CONFIG_BLK_DEV_THROTTLING: enabled
- CONFIG_CGROUP_PERF: enabled
- CONFIG_CGROUP_HUGETLB: enabled
- CONFIG_NET_CLS_CGROUP: enabled
- CONFIG_CGROUP_NET_PRIO: enabled
- CONFIG_CFS_BANDWIDTH: enabled
- CONFIG_FAIR_GROUP_SCHED: enabled
- CONFIG_RT_GROUP_SCHED: enabled
- CONFIG_EXT3_FS: enabled
- CONFIG_EXT3_FS_XATTR: enabled
- CONFIG_EXT3_FS_POSIX_ACL: enabled
- CONFIG_EXT3_FS_SECURITY: enabled
- CONFIG_EXT4_FS: enabled
- CONFIG_EXT4_FS_POSIX_ACL: enabled
- CONFIG_EXT4_FS_SECURITY: enabled
- Storage Drivers:
  - &amp;quot;aufs&amp;quot;:
    - CONFIG_AUFS_FS: missing
  - &amp;quot;btrfs&amp;quot;:
    - CONFIG_BTRFS_FS: enabled
  - &amp;quot;devicemapper&amp;quot;:
    - CONFIG_BLK_DEV_DM: enabled
    - CONFIG_DM_THIN_PROVISIONING: enabled
  - &amp;quot;overlay&amp;quot;:
    - CONFIG_OVERLAY_FS: enabled
  - &amp;quot;zfs&amp;quot;:
    - /dev/zfs: missing
    - zfs command: missing
    - zpool command: missing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It turns out that this Linux 4.1.6 kernel on the HiSilicon D02 board is highly
optimized for Docker. That&amp;rsquo;s because Shameer tuned almost all of the necessary kernel
settings and kernel modules. He did a great job and included all of the important
settings into the kernel .config.&lt;/p&gt;

&lt;p&gt;To install our new binary on a server that has an existing Docker installation is
easy. As soon as the old version is stopped, we can change the binaries by copying
the new version to the destination folder and restarting the Docker service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# systemctl stop docker
# cd ~/code/docker/
# mkdir -p /usr/lib/docker/
# cp bundles/1.10.2/dynbinary/docker-1.10.2 /usr/bin/docker
# cp bundles/1.10.2/dynbinary/dockerinit-1.10.2 /usr/lib/docker/dockerinit
# systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before using the new Docker Engine we&amp;rsquo;re checking, if the Docker service is really running.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# systemctl -l status docker
● docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
   Active: active (running) since Sun 2016-02-28 19:32:09 UTC; 1min 41s ago
     Docs: https://docs.docker.com
 Main PID: 15424 (docker)
   CGroup: /system.slice/docker.service
           └─15424 /usr/bin/docker daemon -H fd:// --storage-driver=overlay -D

Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.125226000Z&amp;quot; level=debug msg=&amp;quot;Registering GET, /events&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.125579000Z&amp;quot; level=debug msg=&amp;quot;Registering GET, /info&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.125872000Z&amp;quot; level=debug msg=&amp;quot;Registering GET, /version&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.126276000Z&amp;quot; level=debug msg=&amp;quot;Registering POST, /auth&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.126586000Z&amp;quot; level=debug msg=&amp;quot;Registering GET, /volumes&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.126873000Z&amp;quot; level=debug msg=&amp;quot;Registering GET, /volumes/{name:.*}&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.127500000Z&amp;quot; level=debug msg=&amp;quot;Registering POST, /volumes/create&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.127882000Z&amp;quot; level=debug msg=&amp;quot;Registering DELETE, /volumes/{name:.*}&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.128327000Z&amp;quot; level=debug msg=&amp;quot;Registering POST, /build&amp;quot;
Feb 28 19:32:09 ubuntu docker[15424]: time=&amp;quot;2016-02-28T19:32:09.128781000Z&amp;quot; level=info msg=&amp;quot;API listen on /var/run/docker.sock&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now as the Docker Engine should be working, let&amp;rsquo;s check all the details with a
couple of Docker commands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker version
Client:
 Version:      1.10.2
 API version:  1.22
 Go version:   go1.6
 Git commit:   c3959b1
 Built:        Sun Feb 28 17:17:48 2016
 OS/Arch:      linux/arm64

Server:
 Version:      1.10.2
 API version:  1.22
 Go version:   go1.6
 Git commit:   c3959b1
 Built:        Sun Feb 28 17:17:48 2016
 OS/Arch:      linux/arm64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# docker info
Containers: 1
 Running: 0
 Paused: 0
 Stopped: 1
Images: 0
Server Version: 1.10.2
Storage Driver: overlay
 Backing Filesystem: extfs
Execution Driver: native-0.2
Logging Driver: json-file
Plugins:
 Volume: local
 Network: bridge null host
Kernel Version: 4.1.6+
Operating System: Ubuntu 15.04
OSType: linux
Architecture: aarch64
CPUs: 16
Total Memory: 7.712 GiB
Name: ubuntu
ID: FGHC:4WU2:MQVO:7EOI:OUKY:43RZ:AN2I:BGAH:DTLX:HR4J:HJPE:K7LP
Debug mode (server): true
 File Descriptors: 11
 Goroutines: 17
 System Time: 2016-02-28T19:36:41.329998Z
 EventsListeners: 0
 Init SHA1: 0fecd52467342c39b5987e394c6f5dee0b438771
 Init Path: /usr/lib/docker/dockerinit
 Docker Root Dir: /var/lib/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before going ahead in our journey to build Docker the official way, we should
check whether we can start some Docker containers from the Docker Hub.
Ok, this one is not for ARMv8 but maybe an ARMv7 image works as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker pull hypriot/rpi-busybox-httpd
Using default tag: latest
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# docker images
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
hypriot/rpi-busybox-httpd   latest              fbd9685c5ffc        8 months ago        2.156 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now let&amp;rsquo;s start a first container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -d -p 80:80 hypriot/rpi-busybox-httpd
d5cafadbc9395f55480607ddbe461b746d7d21a068735765cf496c9048dbd210

# docker ps -a
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                NAMES
d5cafadbc939        hypriot/rpi-busybox-httpd   &amp;quot;/bin/busybox httpd -&amp;quot;   16 seconds ago      Up 14 seconds       0.0.0.0:80-&amp;gt;80/tcp   small_jang
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checking this web server with &lt;code&gt;curl&lt;/code&gt; we should get an answer like this one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# curl http://127.0.0.1:80/
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Pi armed with Docker by Hypriot&amp;lt;/title&amp;gt;
  &amp;lt;body style=&amp;quot;width: 100%; background-color: black;&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;main&amp;quot; style=&amp;quot;margin: 100px auto 0 auto; width: 800px;&amp;quot;&amp;gt;
      &amp;lt;img src=&amp;quot;pi_armed_with_docker.jpg&amp;quot; alt=&amp;quot;pi armed with docker&amp;quot; style=&amp;quot;width: 800px&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end, we&amp;rsquo;re making a backup of our Docker installation - just in case.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd ~/
# tar cvfz docker-1.10.2.tar.gz /usr/bin/docker /usr/lib/docker/dockerinit /etc/default/docker /lib/systemd/system/docker*
/usr/bin/docker
/usr/lib/docker/dockerinit
/etc/default/docker
/lib/systemd/system/docker.service
/lib/systemd/system/docker.socket

# ls -al docker-1.10.2.tar.gz
-rw-r--r-- 1 root root 11665112 Feb 28 19:53 docker-1.10.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# cat /etc/default/docker

# Docker Upstart and SysVinit configuration file

# Customize location of Docker binary (especially for development testing).
#DOCKER=&amp;quot;/usr/local/bin/docker&amp;quot;

# Use DOCKER_OPTS to modify the daemon startup options.
#DOCKER_OPTS=&amp;quot;--dns 8.8.8.8 --dns 8.8.4.4&amp;quot;
DOCKER_OPTS=&amp;quot;--storage-driver=overlay -D&amp;quot;

# If you need Docker to use an HTTP proxy, it can also be specified here.
#export http_proxy=&amp;quot;http://127.0.0.1:3128/&amp;quot;

# This is also a handy place to tweak where Docker&#39;s temporary files go.
#export TMPDIR=&amp;quot;/mnt/bigdrive/docker-tmp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# cat /lib/systemd/system/docker.service

[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network.target docker.socket
Requires=docker.socket

[Service]
Type=notify
ExecStart=/usr/bin/docker daemon -H fd:// $DOCKER_OPTS
EnvironmentFile=-/etc/default/docker
MountFlags=slave
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have a running Docker Engine with the latest stable release v1.10.2 on our
ARMv8 board.&lt;/p&gt;

&lt;h4 id=&#34;compiling-the-docker-engine-the-official-way:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Compiling the Docker Engine the official way&lt;/h4&gt;

&lt;p&gt;With a running Docker Engine in place we can now start creating Docker the
official way. The recommended way is to compile Docker within a Docker container.&lt;/p&gt;

&lt;p&gt;First checkout the Docker repo and use the current development version from the
&lt;code&gt;master&lt;/code&gt; branch. This is necessary because the build tools for ARMv8 are only
available in &lt;code&gt;master&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd ~/code/docker
# git pull
# git checkout master
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# apt-get install -y make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To build the builder Docker image, we only have to run &lt;code&gt;make build&lt;/code&gt;. But please
be patient as this can take a really long time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The build is starting with the following line which indicates that there will be a
Docker image built with the ARMv8 specific &lt;code&gt;Dockerfile.aarch64&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build  -t &amp;quot;docker-dev:master&amp;quot; -f &amp;quot;Dockerfile.aarch64&amp;quot; .
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a result the Docker image &lt;code&gt;docker-dev&lt;/code&gt; is built, which will be used for all
subsequent Docker builds.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker images
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
docker-dev                  master              5163299014a4        54 seconds ago      1.399 GB
aarch64/debian              jessie              2e841aedd266        2 days ago          116.7 MB
hypriot/rpi-busybox-httpd   latest              fbd9685c5ffc        8 months ago        2.156 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As soon as the &lt;code&gt;docker-dev&lt;/code&gt; image is successfully created, we can start the first
real build job within a Docker container. So let&amp;rsquo;s compile a static Docker binary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# time make binary
...
---&amp;gt; Making bundle: binary (in bundles/1.11.0-dev/binary)
Building: bundles/1.11.0-dev/binary/docker-1.11.0-dev
Created binary: bundles/1.11.0-dev/binary/docker-1.11.0-dev


real	2m51.415s
user	0m5.108s
sys	0m17.092s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quickly testing this statically linked Docker binary shows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# bundles/1.11.0-dev/binary/docker-1.11.0-dev -v
Docker version 1.11.0-dev, build 0866d63

# bundles/1.11.0-dev/binary/docker-1.11.0-dev version
Client:
 Version:      1.11.0-dev
 API version:  1.23
 Go version:   go1.5.3
 Git commit:   0866d63
 Built:        Sun Feb 28 22:59:18 2016
 OS/Arch:      linux/arm64
Error response from daemon: client is newer than server (client API version: 1.23, server API version: 1.22)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have a Docker Engine built the official way. The resulting binary is statically
linked and can be used immediately on our HiSilicon D02 development board.&lt;/p&gt;

&lt;h4 id=&#34;updating-the-docker-engine-on-armv8-server:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Updating the Docker Engine on ARMv8 server&lt;/h4&gt;

&lt;p&gt;To use the new binary we just need to exchange it and restart the Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# systemctl stop docker
# mv /usr/bin/docker /usr/bin/docker.1.10.2
# cp bundles/1.11.0-dev/binary/docker-1.11.0-dev /usr/bin/docker
# systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And let&amp;rsquo;s check the new Docker version.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker -v
Docker version 1.11.0-dev, build 0866d63
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# docker version
Client:
 Version:      1.11.0-dev
 API version:  1.23
 Go version:   go1.5.3
 Git commit:   0866d63
 Built:        Sun Feb 28 22:59:18 2016
 OS/Arch:      linux/arm64

Server:
 Version:      1.11.0-dev
 API version:  1.23
 Go version:   go1.5.3
 Git commit:   0866d63
 Built:        Sun Feb 28 22:59:18 2016
 OS/Arch:      linux/arm64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# docker info
Containers: 2
 Running: 0
 Paused: 0
 Stopped: 2
Images: 37
Server Version: 1.11.0-dev
Storage Driver: overlay
 Backing Filesystem: extfs
Execution Driver: native-0.2
Logging Driver: json-file
Plugins:
 Volume: local
 Network: host bridge null
Kernel Version: 4.1.6+
Operating System: Ubuntu 15.04
OSType: linux
Architecture: aarch64
CPUs: 16
Total Memory: 7.712 GiB
Name: ubuntu
ID: FGHC:4WU2:MQVO:7EOI:OUKY:43RZ:AN2I:BGAH:DTLX:HR4J:HJPE:K7LP
Docker Root Dir: /var/lib/docker
Debug mode (client): false
Debug mode (server): true
 File Descriptors: 12
 Goroutines: 38
 System Time: 2016-02-28T23:16:28.447878Z
 EventsListeners: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, we do have Docker Engine v1.11.0-dev running and for the first real test
we just run the &lt;code&gt;make binary&lt;/code&gt; again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# time make binary
...
bundles/1.11.0-dev already exists. Removing.

---&amp;gt; Making bundle: binary (in bundles/1.11.0-dev/binary)
Building: bundles/1.11.0-dev/binary/docker-1.11.0-dev
Created binary: bundles/1.11.0-dev/binary/docker-1.11.0-dev


real	2m50.375s
user	0m7.268s
sys	0m17.280s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With all this hard work we are now able to build the Docker Engine the
official and recommended way. This gives us an absolutely clean workflow and
results in reproducible builds. The complete build environment is fully
isolated within a Docker image and the builds are pretty fast, too.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;As you can see, the latest release of the Docker Engine v1.10.2 is running on this
ARMv8 development board pretty well. But right now the ARMv8 architecture is not officially
supported by Docker, although the builds are working and at least a basic support
is already merged into the &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;

&lt;p&gt;In order to get a fully supported Docker release for ARMv8 a lot more work has to
be done in the coming weeks and months. The Docker CI pipeline has to be expanded
with ARMv8 build servers, so that all new changes and pull request will be checked
and verified automatically.&lt;/p&gt;

&lt;p&gt;After this walkthrough I hope you can clearly see that the Docker container technology
is almost ready for the new generation of high-density ARMv8 cloud servers.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please:02ffd27077a29b8225e4d8825fa873eb&#34;&gt;Feedback please!&lt;/h3&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt;
or tweet your thoughts and ideas on this tutorial at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Test, build and package Docker for ARM the official way</title>
      <link>http://blog.hypriot.com/post/test-build-and-package-docker-for-arm-the-official-way/</link>
      <pubDate>Fri, 05 Feb 2016 16:00:00 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/test-build-and-package-docker-for-arm-the-official-way/</guid>
      <description>

&lt;p&gt;With the recent release of Docker 1.10.0 it is a good time to talk about &lt;strong&gt;Docker on ARM&lt;/strong&gt;.
As many of you know our mission is to make Docker (and container technology) a first class citizen on ARM devices.&lt;/p&gt;

&lt;p&gt;With &lt;a href=&#34;http://blog.docker.com/2016/02/docker-1-10/&#34;&gt;Docker 1.10.0&lt;/a&gt; it is finally possible to build &lt;strong&gt;Docker for ARM&lt;/strong&gt; from the offical Docker repository.&lt;/p&gt;

&lt;p&gt;Mind you - not everything that works for x86 is possible for ARM yet, but quite a lot is already working today.
And it is a first important step towards offical support for Docker on ARM.&lt;/p&gt;

&lt;p&gt;In this blog post I am going to walk you through all the steps that are needed to test, build and package Docker on ARM.
And as an extra bonus I am showing you how to do this on the most advanced ARM on-demand cloud-platform ever.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/arm-support/scaleway_armserver.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;preparation-first-we-need-suiteable-arm-hardware:7190f76dff60ef5d0c44976a259ce00e&#34;&gt;Preparation: First we need suiteable ARM hardware&lt;/h2&gt;

&lt;p&gt;Our friends at Scaleway make it really easy and cheap to get your hands on powerful ARM hardware with their ARM on-demand cloud platform.
Using an ARM server costs only 0,006 € per hour and you only pay when a server is actually running.&lt;/p&gt;

&lt;p&gt;So what are you waiting for? &lt;a href=&#34;https://cloud.scaleway.com/#/signup&#34;&gt;Sign up&lt;/a&gt; for an account now! :)&lt;/p&gt;

&lt;p&gt;After the registration the next step is to create a new server.
When creating a new server we need to choose an image. An image is the combination of an operating system and some preinstalled software.
There are dozens of different images at the &lt;a href=&#34;https://www.scaleway.com/de/imagehub/&#34;&gt;Scaleway ImageHub&lt;/a&gt; to choose from.
And one is of special interest to us - the &lt;a href=&#34;https://www.scaleway.com/imagehub/docker/&#34;&gt;Docker image&lt;/a&gt;.
It combines an Ubuntu 15.10 operating system with a Docker 1.9.1 installation.&lt;/p&gt;

&lt;p&gt;Why do we need a Docker installation anyways? Well, because most of the stuff you can do with the Docker repository needs an already running Docker.
Using the Scaleway Docker image is just a reliable and fast way to get us started.&lt;/p&gt;

&lt;p&gt;OK. Let&amp;rsquo;s actually create the server. This can either be done via &lt;strong&gt;Web-GUI&lt;/strong&gt; or via &lt;strong&gt;commandline&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In the &lt;strong&gt;Web-GUI&lt;/strong&gt; just select the &amp;ldquo;Server&amp;rdquo; menu entry on the left and click the &amp;ldquo;Create&amp;rdquo;-button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/arm-support/create_server.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;In the following dialogue choose the &amp;ldquo;Image Hub&amp;rdquo; tab and search for &amp;ldquo;docker&amp;rdquo;.&lt;br /&gt;
Select the &amp;ldquo;Docker 1.9.1&amp;rdquo; image and you are good.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/arm-support/sw_webgui_choose_an_image.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The same can be done with the &lt;a href=&#34;https://github.com/scaleway/scaleway-cli&#34;&gt;Scaleway Command Line Interface&lt;/a&gt;, too.
Download the latest version for your operating system from the &lt;a href=&#34;https://github.com/scaleway/scaleway-cli/releases/tag/v1.7.1&#34;&gt;release page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For Mac user the easiest way to install it, is via &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install scw
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/scw-1.7.1.mavericks.bottle.tar.gz
Already downloaded: /Library/Caches/Homebrew/scw-1.7.1.mavericks.bottle.tar.gz
==&amp;gt; Pouring scw-1.7.1.mavericks.bottle.tar.gz
==&amp;gt; Caveats
Bash completion has been installed to:
  /usr/local/etc/bash_completion.d

zsh completion has been installed to:
  /usr/local/share/zsh/site-functions
==&amp;gt; Summary
🍺  /usr/local/Cellar/scw/1.7.1: 4 files, 10.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check if the Scaleway CLI works with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw --version
scw version v1.7.1, build homebrew
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks good.&lt;/p&gt;

&lt;p&gt;To be able to do anything meaningful with the CLI we need first to log into our account.
Use the email and password you got when you registered as credentials for your Scaleway account.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw login
Login (cloud.scaleway.com): govinda@hypriot.com
Password:
Do you want to upload an SSH key ?
[0] I don&#39;t want to upload a key !
[3] id_rsa.pub
Which [id]:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you are asked to upload the public part of your SSH key you should do so.
This allows us later to securely connect to our Scaleway ARM servers via SSH.&lt;/p&gt;

&lt;p&gt;After a successful login we are now able to interact with our Scaleway account remotely.&lt;/p&gt;

&lt;p&gt;For instance we can now list all our existing servers.&lt;br /&gt;
If you did not create any servers yet you should get an empty list.&lt;/p&gt;

&lt;p&gt;As you can see, I already have a running server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scw ps
SERVER ID           IMAGE               COMMAND             CREATED             STATUS              PORTS               NAME
1b72r8c7            Docker_1_9_0                            9 days              running             163.152.159.113     scw-07
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the next command we will create and log into the created server in one step.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scw exec $(scw start --wait $(scw create docker_1_9_1)) /bin/bash
root@tender-leavitt:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please be patient here as the allocation of a new server can take some time.&lt;/p&gt;

&lt;p&gt;Basically we combined a couple of scw commands into one: First we &lt;code&gt;scw create&lt;/code&gt; a new server, then we &lt;code&gt;scw start&lt;/code&gt; it and afterwards we log into it via &lt;code&gt;scw exec&lt;/code&gt;.
You can further explore what you can do with the CLI via &lt;code&gt;scw help&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once logged into the server we are dropped to the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@tender-leavitt:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see this is just a standard Ubuntu 15.10 operating system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@tender-leavitt:~# uname -a
Linux tender-leavitt 4.3.3-docker-1 #1 SMP Wed Jan 20 13:31:30 UTC 2016 armv7l armv7l armv7l GNU/Linux
root@tender-leavitt:~# lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:  Ubuntu 15.10
Release:  15.10
Codename: wily
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Did you notice the last part of the &lt;code&gt;uname&lt;/code&gt; output? It shows that we have a &lt;code&gt;armv7l&lt;/code&gt; hardware platform.
This is the hard evidence that we are truely working on ARM hardware and Scaleway is not cheating us. :)&lt;/p&gt;

&lt;p&gt;The last thing we need to check is if we really have a working Docker installation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# dpkg -l | grep docker
ii  docker-hypriot                   1.9.1-1                         armhf        Docker for ARM devices, compiled and packaged by http://blog.hypriot.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, this aleady looks promising. Seems we also do have a Hypriot Docker running here, too. Nice. :)&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check out some more details:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker version
Client:
 Version:      1.9.1
 API version:  1.21
 Go version:   go1.4.3
 Git commit:   a34a1d5
 Built:        Fri Nov 20 23:03:02 UTC 2015
 OS/Arch:      linux/arm

Server:
 Version:      1.9.1
 API version:  1.21
 Go version:   go1.4.3
 Git commit:   a34a1d5
 Built:        Fri Nov 20 23:03:02 UTC 2015
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seems, we now have everthing ready for the second part of this blog post.&lt;/p&gt;

&lt;h2 id=&#34;test-build-and-package-docker-for-arm:7190f76dff60ef5d0c44976a259ce00e&#34;&gt;Test, build and package Docker for ARM&lt;/h2&gt;

&lt;p&gt;Congrats, you already finished the difficult part!&lt;/p&gt;

&lt;p&gt;Which means we can now get on to the easy part of testing, building and packing Docker.&lt;br /&gt;
Sounds to good to be true?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see.&lt;/p&gt;

&lt;p&gt;First we need to clone the Docker repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# git clone https://github.com/docker/docker.git
Cloning into &#39;docker&#39;...
remote: Counting objects: 135534, done.
remote: Compressing objects: 100% (11/11), done.
remote: Total 135534 (delta 7), reused 3 (delta 3), pack-reused 135520
Receiving objects: 100% (135534/135534), 79.57 MiB | 1.61 MiB/s, done.
Resolving deltas: 100% (90280/90280), done.
Checking connectivity... done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Afterwards for all the following steps we need to change into the cloned repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cd docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Docker team uses a dedicated Docker image (how could it be otherwise) as a base for all development work.
It is based on the &lt;code&gt;Dockerfile&lt;/code&gt; that you will find in the root directory of the Docker repository.&lt;/p&gt;

&lt;p&gt;With Docker 1.10.0 you will find that there is another Dockerfile present&amp;hellip; one with an &lt;code&gt;.armhf&lt;/code&gt; extension.
This one is used to build an ARM compatible Docker development image.&lt;/p&gt;

&lt;h3 id=&#34;building-the-docker-development-image:7190f76dff60ef5d0c44976a259ce00e&#34;&gt;Building the Docker development image&lt;/h3&gt;

&lt;p&gt;Creating the Docker development image can take a long time as lots of software gets downloaded, compiled and installed.
The good news is that this is usually only needed once.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Afterwards we can check if the image was successfully created:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
docker-dev          master              2ac07dec8c9a        14 minutes ago      931.9 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all went well we should now see an image that is named &lt;code&gt;docker-dev&lt;/code&gt;.
With this out of the way we can now proceed to the next step.&lt;/p&gt;

&lt;h3 id=&#34;testing-docker:7190f76dff60ef5d0c44976a259ce00e&#34;&gt;Testing Docker&lt;/h3&gt;

&lt;p&gt;There are two types of tests that we can run: &lt;strong&gt;unit-tests&lt;/strong&gt; and &lt;strong&gt;integration-tests&lt;/strong&gt;.
To ensure that a certain Docker version really works we need to ensure that all the tests are passing.&lt;/p&gt;

&lt;p&gt;To run the unit-test suite execute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make test-unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run the integration-test suite execute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make test-integration-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be aware that running the integration tests can take a really long time. We are speaking of hours here.
But that time is worth waiting as there are more than 1,100 tests that already work on ARM as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OK: 1168 passed, 41 skipped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if you feel particularly daring you can run all tests together with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When all tests are green we might as well go to the next step.&lt;/p&gt;

&lt;h3 id=&#34;building-a-new-docker-binary:7190f76dff60ef5d0c44976a259ce00e&#34;&gt;Building a new Docker binary&lt;/h3&gt;

&lt;p&gt;Building a new Docker binary is really fast compared to running the tests.&lt;/p&gt;

&lt;p&gt;Just execute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make binary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will compile a brand new Docker binary.
At the end of the compilation &lt;code&gt;make binary&lt;/code&gt; will give you an output similar to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Created binary: bundles/1.11.0-dev/binary/docker-1.11.0-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this information we can try it out at once:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# bundles/1.11.0-dev/binary/docker-1.11.0-dev version
Client:
 Version:      1.11.0-dev
 API version:  1.23
 Go version:   go1.4.3
 Git commit:   18204ea
 Built:        Fri Feb  5 00:48:09 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This worked out pretty well, too.&lt;/p&gt;

&lt;p&gt;But shipping a plain binary is not very cool, is it?
So shall we make a Debian package as well?&lt;/p&gt;

&lt;h3 id=&#34;building-a-docker-debian-package:7190f76dff60ef5d0c44976a259ce00e&#34;&gt;Building a Docker Debian package&lt;/h3&gt;

&lt;p&gt;The command for creating a Debian package is just another make command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This first creates a binary and then puts it into a Debian package.&lt;/p&gt;

&lt;p&gt;At the end you gonna find the binary beneath the bundles directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -la bundles/latest/build-deb/debian-jessie
total 98708
drwxr-xr-x 2 root root     4096 Feb  5 01:49 .
drwxr-xr-x 3 root root     4096 Feb  5 01:50 ..
-rw-r--r-- 1 root root     1704 Feb  5 01:45 docker-engine_1.11.0~dev~git20160204.213112.0.18204ea-0~jessie_armhf.changes
-rw-r--r-- 1 root root  5405608 Feb  5 01:45 docker-engine_1.11.0~dev~git20160204.213112.0.18204ea-0~jessie_armhf.deb
-rw-r--r-- 1 root root      812 Feb  5 01:39 docker-engine_1.11.0~dev~git20160204.213112.0.18204ea-0~jessie.dsc
-rw-r--r-- 1 root root 95641747 Feb  5 01:39 docker-engine_1.11.0~dev~git20160204.213112.0.18204ea-0~jessie.tar.gz
-rw-r--r-- 1 root root      527 Feb  5 01:25 Dockerfile.build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting package can then be installed with the standard Debian package-management tools.&lt;/p&gt;

&lt;p&gt;By the way - all this is a first example for the upcoming Docker multi-architecture support.
While Docker ARM support is still only partially there, more is to come soon.&lt;/p&gt;

&lt;p&gt;It is just awesome to see what is already possible today! Stay tuned for more!&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback, discuss this post on &lt;a href=&#34;https://news.ycombinator.com/item?id=11042427&#34;&gt;HackerNews&lt;/a&gt; and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Pine A64 is about to become the cheapest ARM 64-bit platform to run Docker</title>
      <link>http://blog.hypriot.com/post/the-pine-a64-is-about-to-become=the-cheapest-ARM-64-bit-platform-to-run-Docker/</link>
      <pubDate>Mon, 25 Jan 2016 23:55:00 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/the-pine-a64-is-about-to-become=the-cheapest-ARM-64-bit-platform-to-run-Docker/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/pine-a64/close_up_front_pine_06.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Last Saturday one of the more promising &lt;a href=&#34;https://www.kickstarter.com/projects/pine64/pine-a64-first-15-64-bit-single-board-super-comput&#34;&gt;Kickstarter campaigns&lt;/a&gt;
that piqued our curiosity ended after 44 days and was able to raise &lt;strong&gt;1.7 million dollars&lt;/strong&gt;.
It was a campaign to fund the cheapest 64-bit ARM board that can currently be bought for money.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Pine A64 sells for 15 bucks&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So why is that noteworthy when there are boards like the Pi Zero around that sell for $5?&lt;/p&gt;

&lt;p&gt;It very much is, when you put that price into perspective. The cheapest 64-bit ARM board we knew before the Pine was
the &lt;a href=&#34;http://blog.hypriot.com/post/getting-docker-running-on-a-highend-arm-gaming-console-for-fun-and-profit/&#34;&gt;NVIDIA ShieldTV&lt;/a&gt;, which sells for about $200.
Next comes the much more expensive &lt;a href=&#34;http://www.slashgear.com/amd-starts-shipping-seattle-arm-server-chips-14423259/&#34;&gt;AMD Opteron A1100 series&lt;/a&gt; where an individual chip alone starts with a price tag of $150.&lt;/p&gt;

&lt;p&gt;All in all that means that the Pine A64 is the most affordable way to lay your hands on real 64-bit ARM hardware - and that by a long shot!
So what can you actually do with such a device?&lt;/p&gt;

&lt;p&gt;Lots of things of course, but &lt;strong&gt;for us at Hypriot, the first thing we think about anything is: Can we run Docker on it?&lt;/strong&gt;
And the short answer is: probably yes. But more about that later.&lt;/p&gt;

&lt;h2 id=&#34;the-hardware:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;The Hardware&lt;/h2&gt;

&lt;p&gt;Before we deep dive into the nitty gritty details, let&amp;rsquo;s first take a step back and see what the Pine A64 has to offer hardware-wise.&lt;/p&gt;

&lt;p&gt;The Pine A64 does have&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a &lt;strong&gt;quad-core Cortex A53 CPU&lt;/strong&gt; with 1,2 Ghz&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;64-bit&lt;/strong&gt; processor architecture&lt;/li&gt;
&lt;li&gt;up to &lt;strong&gt;2 GB of DDR3 memory&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;a version with &lt;strong&gt;Gigabit Ethernet&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;the ability to play 4K video&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What excites us the most here, is the 64-bit architecture combined with 2 GB of memory and Gigabit Ethernet.&lt;/p&gt;

&lt;p&gt;Those specs set the Pine A64 distinctly apart from the Raspberry Pi 2, which much to our regret only provides 100 Megabit Ethernet.
Just be aware that you&amp;rsquo;ll get these specs only with the high-end version of the Pine. It is called the A64+ and costs a bit more with $19 (1 GB version) or $29 (2 GB version).
&lt;strong&gt;Even at $19 for the 1 GB version that&amp;rsquo;s nearly half of the price of a Raspberry Pi 2.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If it turns out that the build quality and support of the board is on par with that of the Raspberry Pi that could indeed considered an impressive accomplishment.&lt;/p&gt;

&lt;p&gt;We were lucky enough to secure an early developer version of the device, which arrived a couple of days ago.
Seeing is believing and as such we prepared a couple of photos that we made from our own Pine A64+ board with 1 GB.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;





&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/pine-a64-gallery/close_up_front_pine_06.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/pine-a64-gallery/thumbnails/thumb_close_up_front_pine_06.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up Pine 64 FRONT&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up Pine 64 FRONT
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/pine-a64-gallery/close_up_back_pine_05.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/pine-a64-gallery/thumbnails/thumb_close_up_back_pine_05.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up Pine 64 BACK&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up Pine 64 BACK
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/pine-a64-gallery/close_up_pine_01.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/pine-a64-gallery/thumbnails/thumb_close_up_pine_01.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up 01&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up 01
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Docker Inc.&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/pine-a64-gallery/close_up_pine_02.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/pine-a64-gallery/thumbnails/thumb_close_up_pine_02.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up 02&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up 02
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/pine-a64-gallery/close_up_pine_03.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/pine-a64-gallery/thumbnails/thumb_close_up_pine_03.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up 03&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up 03
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/pine-a64-gallery/close_up_pine_04.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/pine-a64-gallery/thumbnails/thumb_close_up_pine_04.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up 04&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up 04
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/pine-a64-gallery/comparison_to_other_boards.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/pine-a64-gallery/thumbnails/thumb_comparison_to_other_boards.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;The Pine A64 compared to a Raspberry Pi 2 and an ODroid C1&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    The Pine A64 compared to a Raspberry Pi 2 and an ODroid C1
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;h2 id=&#34;the-software:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;The Software&lt;/h2&gt;

&lt;p&gt;One of the current limitations of the Pine A64 is that it only runs with Android.
The Pine makers assured us that Linux support will come, too. Still for us it is a tad annoying that Android is first instead of Linux.&lt;/p&gt;

&lt;p&gt;Impatient as we are, once we got the device, we immediately started out to rectify this by getting HypriotOS to run on it.
Relatively soon it became obvious that this would not be an easy task.&lt;/p&gt;

&lt;p&gt;Why? Well, it seems that the relationship between &lt;a href=&#34;http://www.allwinnertech.com/index.html&#34;&gt;Allwinner Technology&lt;/a&gt; and the Open-Source community has not always been the best in the past.
That basically meant that the existing &lt;a href=&#34;http://linux-sunxi.org/&#34;&gt;friendly and supportive Open-Source community&lt;/a&gt; for the Allwinner related SoC&amp;rsquo;s often had to work
with limited information and support when they tried to come up with proper Linux support for Allwinner based devices.
Still despite that some members of the Linux Sunxi Community are already busy working with the Pine A64.&lt;/p&gt;

&lt;h2 id=&#34;a-long-journey-down-the-rabbit-hole-begins-with-the-first-step:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;A long journey (down the rabbit hole) begins with the first step&lt;/h2&gt;

&lt;p&gt;The rest of this blog post describes our preliminary journey to create Linux &amp;amp; Docker bliss for the Pine A64.
And consider yourself sufficiently warned - this journey is not for the faint of heart&amp;hellip; :)&lt;/p&gt;

&lt;h3 id=&#34;down-the-rabbit-hole-output-foo-with-the-uart0-console:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;Down the rabbit hole: Output foo with the UART0 console&lt;/h3&gt;

&lt;p&gt;So let&amp;rsquo;s get our hands on this new beauty. First thing you should know is how you can power the Pine A64 board.
It has a standard microUSB port, which you can use with a power adapter of 5V/2A. That&amp;rsquo;s the same you might use for a Raspberry Pi.&lt;/p&gt;

&lt;p&gt;For our first low-level steps with the board we prefer to connect to the UART0 console via an UART-to-USB connector cable.
We recommend to use one such as the &lt;a href=&#34;https://www.adafruit.com/product/954&#34;&gt;USB to TTL Serial Cable&lt;/a&gt; from Adafruit.
Adafruit also has a &lt;a href=&#34;https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable&#34;&gt;great tutorial&lt;/a&gt; on how to install the drivers for such a cable on different operating systems.&lt;/p&gt;

&lt;p&gt;For connecting via UART0 to the Pine there are basically two ways. Either via the pins of the &lt;code&gt;Euler bus&lt;/code&gt; or via the &lt;code&gt;EXT&lt;/code&gt; connectors.
The location of each can be seen on the following images. Consult the &lt;a href=&#34;http://linux-sunxi.org/Pine64#Serial_port_.2F_UART&#34;&gt;Linux-sunxi Wiki: Serial port / UART&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;Serial Console with Euler Bus:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/pine-a64/serial_euler.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Serial Console with Ext connector:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/pine-a64/serial_ext.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;To actually work with the UART0 console you have to connect the UART-to-USB cable to your Linux or Mac computer and start your preferred terminal program.&lt;/p&gt;

&lt;p&gt;Here is the command for Mac OS X:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo screen /dev/cu.usbserial 115200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t be surprised that there is absolutely no sign of booting on your console screen when you connect the UART-to-USB cable to the Pine.
The only thing you will see is that the power LED on the board has turned green.&lt;/p&gt;

&lt;p&gt;This is due to the fact that the A64 SOC is reading its initial bootloader from the microSD card into memory and starts it.
Among other things this initializes the UART0 port and prints out the first boot messages.&lt;/p&gt;

&lt;p&gt;There might be two reasons if your Pine stays silent: either there is no SD card present or there is no working bootloader program found on the SD card.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s make sure that we have both.&lt;/p&gt;

&lt;p&gt;Grab a working SD card and flash an appropriate image on it.
Thanks to Andre Przywara there already is &lt;a href=&#34;https://github.com/apritzel/pine64&#34;&gt;a first experimental Linux image&lt;/a&gt; that we can use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# replace sdx with the name of your SD card device file

$ xzcat pine64_linux-20160121.img.xz | dd of=/dev/sdx bs=1M
$ sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This SD card image is a hybrid that combines components from the original Pine 64 Android image with a recent Linux 4.4.0-rc8 kernel and initrd.
All this is more or less just cobbled together to get a first prototypical SD card image with Linux running.&lt;/p&gt;

&lt;p&gt;As this image does not include a full root file system one of the first ideas that came to our mind was to include our HypriotOS root filesystem for ARM64.
Alright, lets see if this really works.&lt;/p&gt;

&lt;p&gt;Inserting the SD card into the Pine A64 and booting produced the expected boot messages.
After some seconds the following boot Linux prompt was visible:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BusyBox v1.22.1 (Debian 1:1.22.0-9+deb8u1) built-in shell (ash)
Enter &#39;help&#39; for a list of built-in commands.

/ #
/ #
/ #
/ # uname -a
Linux (none) 4.4.0-rc8 #20 SMP PREEMPT Mon Jan 18 01:05:25 GMT 2016 aarch64 GNU/Linux
/ # df -h
Filesystem                Size      Used Available Use% Mounted on
none                     78.5M     72.0K     78.4M   0% /run
devtmpfs                381.8M         0    381.8M   0% /dev
/ #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, that was the first step, but now we would like to see, if it&amp;rsquo;s really possible to boot into a HypriotOS root filesystem.
So let&amp;rsquo;s reboot the Pine. As soon as the U-Boot messages appear, hit a random key to stop the automatic boot process.
This drops us into an interactive U-Boot prompt.&lt;/p&gt;

&lt;p&gt;Next we just have to follow Andre&amp;rsquo;s documentation and tell U-Boot to boot into the root filesystem on &lt;code&gt;/dev/sda10&lt;/code&gt;, which contains our &lt;a href=&#34;https://github.com/hypriot/os-rootfs/releases/tag/v0.6.0&#34;&gt;generic HypriotOS for ARM64&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sunxi# run load_env
sunxi# run load_dtb
sunxi# run set_cmdline
sunxi# setenv kernel_part mainline
sunxi# run load_kernel
sunxi# run boot_kernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bingo! It works.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/pine-a64/hypriotos_pine64.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Here are a few snippets of the boot log from the UART0 console.
We have stored the complete boot log for you as a &lt;a href=&#34;https://gist.github.com/DieterReuter/93a5d10dae6a62911b71&#34;&gt;GitHub gist&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HELLO! BOOT0 is starting!
boot0 commit : 045061a8bb2580cb3fa02e301f52a015040c158f

boot0 version : 4.0.0
set pll start
set pll end
...
NOTICE:  BL3-1: v1.0(debug):045061a
NOTICE:  BL3-1: Built : 14:30:28, Dec  3 2015
NOTICE:  BL3-1 commit: 045061a8bb2580cb3fa02e301f52a015040c158f

INFO:    BL3-1: Initializing runtime services
INFO:    BL3-1: Preparing for EL3 exit to normal world
INFO:    BL3-1: Next image address = 0x4a000000
INFO:    BL3-1: Next image spsr = 0x1d3


U-Boot 2014.07 (Dec 03 2015 - 14:30:33) Allwinner Technology
...
Starting kernel ...

INFO:    BL3-1: Next image address = 0x41080000
INFO:    BL3-1: Next image spsr = 0x3c5
Booting Linux on physical CPU 0x0
Initializing cgroup subsys cpu
Linux version 4.4.0-rc8 (aprzywara@slackpad) (gcc version 4.9.3 (GCC) ) #21 SMP PREEMPT Wed Jan 20 22:43:20 GMT 2016
Boot CPU: AArch64 Processor [410fd034]
...
Welcome to Debian GNU/Linux 8 (jessie)!
...
[  OK  ] Reached target Multi-User System.
[  OK  ] Reached target Graphical Interface.

Debian GNU/Linux 8 black-pearl ttyS0

black-pearl login: pirate
Password:
Linux black-pearl 4.4.0-rc8 #21 SMP PREEMPT Wed Jan 20 22:43:20 GMT 2016 aarch64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
HypriotOS/arm64: pirate@black-pearl in ~
$ uname -a
Linux black-pearl 4.4.0-rc8 #21 SMP PREEMPT Wed Jan 20 22:43:20 GMT 2016 aarch64 GNU/Linux
$ cat /etc/os-release
PRETTY_NAME=&amp;quot;Debian GNU/Linux 8 (jessie)&amp;quot;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;
VERSION_ID=&amp;quot;8&amp;quot;
VERSION=&amp;quot;8 (jessie)&amp;quot;
ID=debian
HOME_URL=&amp;quot;http://www.debian.org/&amp;quot;
SUPPORT_URL=&amp;quot;http://www.debian.org/support/&amp;quot;
BUG_REPORT_URL=&amp;quot;https://bugs.debian.org/&amp;quot;
HYPRIOT_OS=&amp;quot;HypriotOS/arm64&amp;quot;
HYPRIOT_TAG=&amp;quot;dirty&amp;quot;
HypriotOS/arm64: root@black-pearl in ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Success!&lt;/strong&gt; The first boot of HypriotOS/arm64 on a Pine A64 board.&lt;/p&gt;

&lt;h3 id=&#34;even-deeper-into-the-rabbit-hole-using-the-fel-mode-to-communicate-with-the-the-pine-a64:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;Even deeper into the rabbit hole: Using the FEL mode to communicate with the the Pine A64&lt;/h3&gt;

&lt;p&gt;OK. That was fun, wasn&amp;rsquo;t it? Our small experiment with the UART-to-USB connector cable and the SD card image from Andre did give us a first taste of Linux on the Pine.
But that of course is not the real deal. There is still a rocky path to walk before we will have proper Linux support.&lt;/p&gt;

&lt;p&gt;Our path towards more knowledge leads us even deeper into the rabbit hole.&lt;/p&gt;

&lt;p&gt;In order to gain that deeper knowledge we will introduce you to another powerful tool called &lt;a href=&#34;http://linux-sunxi.org/FEL&#34;&gt;FEL&lt;/a&gt; mode.
The FEL mode is a low-level subroutine in the Boot ROM of all Allwinner devices that can be used to gather valuable insights about the Pine.
We will show you shortly how this works.&lt;/p&gt;

&lt;p&gt;Besides gathering intel FEL has another useful application. It allows you to directly boot images via an USB cable from your development computer.
As such it makes the annoying process of flashing and inserting SD cards over and over again obsolete.&lt;/p&gt;

&lt;p&gt;Booting the Pine A64 into FEL mode is really easy. Just leave the SD card slot empty and connect the Pine A64 with an appropriate USB cable  to your computer.
Then power on the Pine. It&amp;rsquo;s important to know that you have to connect to the Pine with a special USB cable to the upper USB port.
That is because only this USB port is wired for using the FEL signals.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/pine-a64/upper_usb_port.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;You can buy such a special USB A-male/A-male cable at &lt;a href=&#34;http://www.amazon.com/Monoprice-1-5-Feet-24AWG-Plated-105441/dp/B009GUXG92&#34;&gt;Amazon&lt;/a&gt; or &lt;a href=&#34;http://www.instructables.com/id/Male-to-Male-A-to-A-USB-Cable/&#34;&gt;build it on your own&lt;/a&gt;.
Once the Pine A64 is booted, it can be discovered on your host computer as a new USB device with the &lt;code&gt;USB ID 1f3a:efe8&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;lsusb&lt;/code&gt; should show the device:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lsusb
Bus 001 Device 004: ID 1f3a:efe8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For further access via FEL mode, we need to install and compile the very latest version of the sunxi-tools.
As our development computer we are using a Raspberry Pi running &lt;a href=&#34;http://blog.hypriot.com/post/just-in-time-for-DockerCon-EU-a-shipload-of-new-Docker-ARM-goodies/&#34;&gt;HypriotOS&lt;/a&gt;.
So let&amp;rsquo;s install all the development dependencies we need and then clone the sunxi-tools repo and compile them from source.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install -y make gcc pkg-config libusb-1.0-0-dev
$ makedir -p ~/code
$ cd ~/code
$ git clone https://github.com/linux-sunxi/sunxi-tools
$ cd sunxi-tools
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s see if we can use the sunxi-tools to extract some version information about the Pine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel version
AWUSBFEX soc=00001689(unknown) 00000001 ver=0001 44 08 scratchpad=00017e00 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bingo! The Pine A64 board is connected and we are already getting some basic version info.
The the SOC ID #1689 tells us it is an Allwinner A64 SOC.
The device itself is classified as &amp;ldquo;unknown&amp;rdquo; because it is too new to be recognized by the &lt;code&gt;sunxi-fel&lt;/code&gt; tool.&lt;/p&gt;

&lt;p&gt;What can we do now with this low-level access via FEL mode?&lt;/p&gt;

&lt;p&gt;Well, for instance we could read 128 bytes of the device memory and display it as hex dump on the screen.
Let&amp;rsquo;s start from address 0x0000:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel hexdump 0x0000 128
00000000: 08 00 00 ea 06 00 00 ea 05 00 00 ea 04 00 00 ea  ................
00000010: 03 00 00 ea 02 00 00 ea 11 00 00 ea 00 00 00 ea  ................
00000020: 13 00 00 ea fe ff ff ea 01 00 a0 e3 00 10 a0 e3  ................
00000030: 00 20 a0 e3 00 30 a0 e3 00 40 a0 e3 00 50 a0 e3  . ...0...@...P..
00000040: 00 60 a0 e3 00 70 a0 e3 00 80 a0 e3 00 90 a0 e3  .`...p..........
00000050: 00 a0 a0 e3 00 b0 a0 e3 00 c0 a0 e3 00 d0 a0 e3  ................
00000060: e8 f0 9f e5 04 e0 4e e2 ff 5f 2d e9 1f 07 00 eb  ......N.._-.....
00000070: ff 9f fd e8 d2 20 a0 e3 02 f0 21 e1 d0 d0 9f e5  ..... ....!.....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or we could just copy the device memory into a file to our development computer and display the content with the &lt;code&gt;hexdump&lt;/code&gt; command locally.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel dump 0x0000 128 &amp;gt; memory-dump.bin
$ hexdump -C memory-dump.bin
00000000  08 00 00 ea 06 00 00 ea  05 00 00 ea 04 00 00 ea  |................|
00000010  03 00 00 ea 02 00 00 ea  11 00 00 ea 00 00 00 ea  |................|
00000020  13 00 00 ea fe ff ff ea  01 00 a0 e3 00 10 a0 e3  |................|
00000030  00 20 a0 e3 00 30 a0 e3  00 40 a0 e3 00 50 a0 e3  |. ...0...@...P..|
00000040  00 60 a0 e3 00 70 a0 e3  00 80 a0 e3 00 90 a0 e3  |.`...p..........|
00000050  00 a0 a0 e3 00 b0 a0 e3  00 c0 a0 e3 00 d0 a0 e3  |................|
00000060  e8 f0 9f e5 04 e0 4e e2  ff 5f 2d e9 1f 07 00 eb  |......N.._-.....|
00000070  ff 9f fd e8 d2 20 a0 e3  02 f0 21 e1 d0 d0 9f e5  |..... ....!.....|
00000080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we already explained, the Allwinner SOC is starting it&amp;rsquo;s boot process by loading the Boot ROM (&lt;a href=&#34;http://linux-sunxi.org/BROM&#34;&gt;BROM&lt;/a&gt;)
and detects wether it should run a normal boot or start the FEL subroutine.
With the help of FEL mode and the &lt;code&gt;sunxi-fel&lt;/code&gt; tool we can also copy and analyze the BROM boot code itself.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s download the BROM directly from the Pine and save it into a local file on our development computer for later inspection.
In order to do so, we need to know the memory address where the BROM starts.&lt;/p&gt;

&lt;p&gt;Unfortunately the memory address that works for existing Allwinner SoC&amp;rsquo;s like the A10 or A20 does not work here.
But there is an important clue in the &lt;a href=&#34;http://linux-sunxi.org/EGON&#34;&gt;Linux-Sunxi wiki&lt;/a&gt; that tells us
that we need to search for a unique string &lt;code&gt;eGON.BRM&lt;/code&gt; near the starting address of the BROM.&lt;/p&gt;

&lt;p&gt;Armed with this knowledge and the &lt;code&gt;sunxi-fel hexdump&lt;/code&gt; command we can now scan the memory until we will find this string.
And luckily we were able to locate the BROM starting at address &lt;strong&gt;0x2c00&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel hexdump 0x2c00 128
00002c00: 07 00 00 ea 07 00 00 ea 65 47 4f 4e 2e 42 52 4d  ........eGON.BRM
00002c10: 24 00 00 00 31 31 30 30 31 31 30 30 31 36 33 33  $...110011001633
00002c20: 00 00 00 00 00 00 00 ea 01 00 00 ea 00 60 a0 e3  .............`..
00002c30: 03 00 00 ea 5c 60 a0 e3 0e 00 00 ea e8 01 9f e5  ....\`..........
00002c40: 00 f0 90 e5 b0 0f 10 ee 03 10 00 e2 00 00 51 e3  ..............Q.
00002c50: f9 ff ff 1a ff 1c 00 e2 00 00 51 e3 f6 ff ff 1a  ..........Q.....
00002c60: c8 11 9f e5 c8 21 9f e5 00 30 91 e5 03 00 52 e1  .....!...0....R.
00002c70: 00 00 00 1a f0 ff ff ea 50 00 a0 e3 01 00 50 e2  ........P.....P.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s download the complete 32 KByte of the BROM binary blob and have a look at it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel dump 0x2c00 32768 &amp;gt; pine64-a64-brom.bin
$ head -c 128 pine64-a64-brom.bin | hexdump -C
00000000  07 00 00 ea 07 00 00 ea  65 47 4f 4e 2e 42 52 4d  |........eGON.BRM|
00000010  24 00 00 00 31 31 30 30  31 31 30 30 31 36 33 33  |$...110011001633|
00000020  00 00 00 00 00 00 00 ea  01 00 00 ea 00 60 a0 e3  |.............`..|
00000030  03 00 00 ea 5c 60 a0 e3  0e 00 00 ea e8 01 9f e5  |....\`..........|
00000040  00 f0 90 e5 b0 0f 10 ee  03 10 00 e2 00 00 51 e3  |..............Q.|
00000050  f9 ff ff 1a ff 1c 00 e2  00 00 51 e3 f6 ff ff 1a  |..........Q.....|
00000060  c8 11 9f e5 c8 21 9f e5  00 30 91 e5 03 00 52 e1  |.....!...0....R.|
00000070  00 00 00 1a f0 ff ff ea  50 00 a0 e3 01 00 50 e2  |........P.....P.|
00000080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All these examples were based on the FEL mode and the &lt;code&gt;sunxi-fel&lt;/code&gt; tool.
They illustrated how to gather information about a device.&lt;/p&gt;

&lt;p&gt;In the introduction about the FEL mode we did mention another application of the FEL mode: You can have a faster development cycle where one does not have to flash and boot SD cards.&lt;/p&gt;

&lt;p&gt;To make this mode work for the Pine we first have to patch the &lt;code&gt;sunix-fel&lt;/code&gt; tool.
Thanks to the work of &lt;a href=&#34;https://github.com/ssvb&#34;&gt;Siarhei Siamashka&lt;/a&gt; from Linux-Sunxi community this is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/code/sunxi-tools
$ mv fel.c fel.c.org
$ wget https://github.com/ssvb/sunxi-tools/raw/dc77476014669a6f9010a3160357391450a5196e/fel.c
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, it works. The &lt;code&gt;sunxi-fel&lt;/code&gt; tool now correctly detects the Pine A64 and the Allwinner A64 SOC.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel version
AWUSBFEX soc=00001689(A64) 00000001 ver=0001 44 08 scratchpad=00017e00 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this preparation in place our work on things like the Secondary Program Loader (SPL or boot0), U-Boot, the Linux kernel and its modules get much more convenient.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/pine-a64/dev-host-pine-cabeling.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;inside-wonderland-combining-uart0-console-and-fel-mode:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;Inside wonderland: Combining UART0 console and FEL mode&lt;/h3&gt;

&lt;p&gt;Now it is time to put the various things together we have learned thus far.
Using both an USB A-male/A-male cable and an UART-to-USB connector cable at the same time we are able to send software to the Pine and see how it gets executed.
This allows for fast feedback cycles.&lt;/p&gt;

&lt;p&gt;We will attempt this by uploading and starting a boot0 bootloader.&lt;/p&gt;

&lt;p&gt;Instead of creating our own boot0 bootloader for the sake of simplicity we are going to extract the existing one from Andre&amp;rsquo;s Linux SD card image.
It is located at sector 16 (or 8 KByte) and has a total size of 64 sectors or 32 KByte.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ xzcat pine64_linux-20160121.img.xz | dd of=pine64-boot0.bin bs=512 count=64 skip=16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s double-check if this file is really the correct boot0 binary blob we&amp;rsquo;re looking for.
The file should start with the string &amp;ldquo;eGON.BT0&amp;rdquo; at byte #5. Here we are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hexdump -C pine64-boot0.bin
00000000  cc 00 00 ea 65 47 4f 4e  2e 42 54 30 31 7a f6 a8  |....eGON.BT01z..|
00000010  00 80 00 00 30 00 00 00  00 00 00 00 00 00 01 00  |....0...........|
00000020  00 00 01 00 00 00 00 00  00 00 34 2e 30 2e 30 00  |..........4.0.0.|
00000030  00 00 00 00 01 00 00 00  a0 02 00 00 03 00 00 00  |................|
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of &lt;code&gt;sunxi-fel&lt;/code&gt; this boot0 program can now be sent directly to the Pine A64.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel spl pine64-boot0.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at our UART0 console output we can see that the upload and start of the program works as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HELLO! BOOT0 is starting!
boot0 commit : 045061a8bb2580cb3fa02e301f52a015040c158f

boot0 version : 4.0.0
set pll start
set pll end
rtc[0] value = 0x00000000
rtc[1] value = 0x00000000
rtc[2] value = 0x00000000
rtc[3] value = 0x00000000
rtc[4] value = 0x00000000
rtc[5] value = 0x00000000
DRAM driver version: V1.1
rsb_send_initseq: rsb clk 400Khz -&amp;gt; 3Mhz
PMU: AXP81X
ddr voltage = 1500 mv
DRAM Type = 3 (2:DDR2,3:DDR3,6:LPDDR2,7:LPDDR3)
DRAM clk = 672 MHz
DRAM zq value: 003b3bbb
DRAM single rank full DQ OK
DRAM size = 1024 MB
DRAM init ok
dram size =1024
card boot number = 0, boot0 copy = 0
card no is 0
sdcard 0 line count 4
[mmc]: mmc driver ver 2015-05-08 20:06
[mmc]: sdc0 spd mode error, 2
[mmc]: Wrong media type 0x00000000
[mmc]: ***Try SD card 0***
[mmc]: mmc 0 cmd 8 timeout, err 00000100
[mmc]: mmc 0 cmd 8 err 00000100
[mmc]: mmc 0 send if cond failed
[mmc]: mmc 0 cmd 55 timeout, err 00000100
[mmc]: mmc 0 cmd 55 err 00000100
[mmc]: mmc 0 send app cmd failed
[mmc]: ***Try MMC card 0***
[mmc]: mmc 0 cmd 1 timeout, err 00000100
[mmc]: mmc 0 cmd 1 err 00000100
[mmc]: mmc 0 send op cond failed
[mmc]: mmc 0 Card did not respond to voltage select!
[mmc]: ***SD/MMC 0 init error!!!***
[mmc]: mmc 0 register failed
Fail in Init sdmmc.
Ready to disable icache.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By verifying that we can send code to the Pine and execute it, we opened up the door for further steps.
For instance working on a new U-Boot bootloader.&lt;/p&gt;

&lt;p&gt;A few days ago Siarhei was able to create a first working U-Boot for the A64 SOC and could upload and start it on his Pine A64 board.
He published the full boot log of this &lt;a href=&#34;https://gist.github.com/ssvb/67ebb38e8f8f2b9b5ee6&#34;&gt;work-in-progress U-Boot bootloader&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here you can see a snippet from the boot log that shows what is already working:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;U-Boot SPL 2016.01-00352-ge77e0e4-dirty (Jan 24 2016 - 10:26:33)
DRAM:DRAM driver version: V1.0
DRAM Type = 3 (2:DDR2,3:DDR3,6:LPDDR2,7:LPDDR3)
DRAM clk = 672 MHz
DRAM zq value: 3b3bbb
DRAM single rank full DQ OK
DRAM size = 1024 MB
DRAM init ok
 1024 MiB
Trying to boot from MMC


U-Boot 2016.01-00352-ge77e0e4-dirty (Jan 24 2016 - 10:26:33 +0200) Allwinner Technology

CPU:   Allwinner A64 (SUN50I)
DRAM:  1 GiB
MMC:   SUNXI SD/MMC: 0
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-preliminary-end:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;The preliminary end&lt;/h2&gt;

&lt;p&gt;This brings us (somewhat sadly) to the end of our blog post.&lt;/p&gt;

&lt;p&gt;Our goal was to give a first impression of the current state of Linux support for the Pine A64.
And we also wanted to give you an introduction to the tools and knowledge that are necessary to make it happen.&lt;/p&gt;

&lt;p&gt;This blogpost would not be possible without the great guys from the Linux-Sunxi community.
Especially the help of &lt;a href=&#34;https://github.com/apritzel&#34;&gt;Andre Przywara&lt;/a&gt; (apritzel) and &lt;a href=&#34;https://github.com/ssvb&#34;&gt;Siarhei Siamashka&lt;/a&gt; (ssvb) was invaluable.
It demands lots of respect seeing how they have to reverse engineer this stuff with only little support from Allwinner Technology.
We really hope that the &lt;a href=&#34;http://forum.pine64.org/forumdisplay.php?fid=17&#34;&gt;announced support&lt;/a&gt; from the Pine team will help to move things forward.&lt;/p&gt;

&lt;p&gt;We will follow this development closely and hope to publish an initial support for HypriotOS rather sooner than later.
By this Docker will gain access to a really powerful developer board - and we will support it early on.&lt;/p&gt;

&lt;p&gt;We hope you enjoyed this whirlwind tour through the Pine Linux Wonderland!&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback, discuss this post on &lt;a href=&#34;https://news.ycombinator.com/item?id=10973751&#34;&gt;HackerNews&lt;/a&gt; and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; and Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to get Docker working on your favourite ARM board with HypriotOS</title>
      <link>http://blog.hypriot.com/post/how-to-get-docker-working-on-your-favourite-arm-board-with-hypriotos/</link>
      <pubDate>Mon, 18 Jan 2016 16:00:00 +0200</pubDate>
      
      <guid>http://blog.hypriot.com/post/how-to-get-docker-working-on-your-favourite-arm-board-with-hypriotos/</guid>
      <description>&lt;p&gt;It all began when Dieter aka &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; started to experiment with the NVIDIA ShieldTV.
The ShieldTV is a curious little thing. Sold as a media hub for your living room it does deliver one teraflop of processing power.
On top of that it is one of the first 64-bit ARM boards that can be bought for a reasonable price.&lt;/p&gt;

&lt;p&gt;Regular readers of our blog know that it is not in Dieter&amp;rsquo;s nature to resist the Sirens voices of such an appealing beauty for long.
Read on to learn what happened next&amp;hellip;&lt;/p&gt;

&lt;p&gt;Last December he started the work to get Docker running on the ShieldTV and &lt;a href=&#34;http://blog.hypriot.com/post/getting-docker-running-on-a-highend-arm-gaming-console-for-fun-and-profit/&#34;&gt;described his journey&lt;/a&gt; on our blog.
The gist of it is that it was quite an involved process of creating his own custom Debian based operating system that supported building Go and Docker for ARM64.&lt;/p&gt;

&lt;p&gt;The work of Dieter on the ShieldTV inspired our team to revisit the way we were building our beloved HypriotOS for the Raspberry Pi.
Longing to publish the way we build it for quite some time we had been ashamed to actually do it because it was such a complicated mess.
Don&amp;rsquo;t get me wrong - it worked well enough and was completely automated with our CI system and even tested, but ultimately it was difficult to understand and change.&lt;/p&gt;

&lt;p&gt;So Dieter&amp;rsquo;s work got us thinking:
What if we could restructure the build process of HypriotOS in such a way that it would be built in distinct layers that would create distinct build artifacts on their own.
What if those artifacts could be tested and published on their own, too? Only to be assembled in a final step at the end to create a fully working SD card image.
What if those distinct steps were self-contained and easy to understand?&lt;/p&gt;

&lt;p&gt;Last week we had some time at our hands and we started working on a build process that would be the answer to all those questions.
It is certainly still a little rough around the edges and needs further tweaking but it produces a working SD card image for the Raspberry Pi.
We consider it beta quality and it is not yet completely on par with our stable HypriotOS Hector image, but it already runs very well.&lt;/p&gt;

&lt;p&gt;The main repository for building HypriotOS SD card image for the Raspberry Pi can be found at GitHub in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;Image-Builder-Rpi Repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So what happens in this repository?&lt;/p&gt;

&lt;p&gt;Basically it just assembles prepared artifacts into a working SD card image which then can be &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;easily flashed&lt;/a&gt; onto a SD card.&lt;/p&gt;

&lt;p&gt;The artifacts that are combined here are produced elsewhere each in their own GitHub repository:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/os-rootfs&#34;&gt;a basic filesystem that is based on Debian Jessie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/rpi-kernel&#34;&gt;a Raspberry Pi compatible Linux kernel and firmware&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-raw&#34;&gt;a Raspberry Pi image file that contains the necessary partitions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecloud.io/Hypriot/Schatzkiste&#34;&gt;a couple of Debian packages with software like Docker, Docker-Machine and Docker-Compose&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The basic idea is that all these artifacts can be build and tested with the help of Docker.
For instance if you look into the &lt;a href=&#34;https://github.com/hypriot/os-rootfs&#34;&gt;os-rootfs&lt;/a&gt; repository you will find a &lt;code&gt;Dockerfile&lt;/code&gt; in the root of the project that will allow you to create a build and test environment for the root filesystem.&lt;/p&gt;

&lt;p&gt;This makes two important things possible: Firstly it allows others to build the rootfs locally on their own computer and fix or extend the rootfs with ease.
And secondly the rootfs is build and tested on &lt;a href=&#34;https://travis-ci.org/hypriot/os-rootfs&#34;&gt;Travis CI&lt;/a&gt; everytime somebody creates - for instance - a pull request.
Combined these two points create a transparent development process with instant feedback.&lt;/p&gt;

&lt;p&gt;It turned out that this approach is generic and powerful enough to be applied - you probably already guessed it - to the NVIDIA ShieldTV, too.
By publishing the &lt;a href=&#34;https://github.com/hypriot/image-builder-nvidia-shieldtv&#34;&gt;Image-Builder-NVIDIA-ShieldTV&lt;/a&gt; repository we are making good on Dieter&amp;rsquo;s promise to publish the sources for Dieter&amp;rsquo;s journey with the ShieldTV.&lt;/p&gt;

&lt;p&gt;But hold on - that&amp;rsquo;s not all. To proof to ourselves that this process allows to easily port HypriotOS to different development boards we created &lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-c1&#34;&gt;another Github repository&lt;/a&gt;.
It builds a SD card image for the very capable &lt;a href=&#34;http://www.hardkernel.com/main/products/prdt_info.php?g_code=G143703355573&#34;&gt;ODROID C1+&lt;/a&gt; development board.
Similar to the Raspberry Pi 2 the ODROID C1+ features a quad core ARMv7 CPU with 1 GB of memory. Distinct from the Raspberry Pi 2 it features a gigabit ethernet port.
A highlevel comparision of both devices can be found at &lt;a href=&#34;http://www.cnx-software.com/2015/02/02/raspberry-pi-2-odroid-c1-development-boards-comparison/&#34;&gt;CNX-Software&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this third supported board for HypriotOS we proofed to ourselves that this new build process makes it not only feasible but actually quite easy to extend the support of HypriotOS to new development boards.&lt;/p&gt;

&lt;p&gt;Overall the relation of the different repositories now looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/hypriotos-xxx/hypriotos_buildpipeline.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;All these changes also redefined for us what HypriotOS is all about.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Our old mission statement for HypriotOS was:&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&amp;ldquo;HypriotOS is a minimal operating system for the Raspberry Pi 1 &amp;amp; 2 that provides an optimized environment for running Docker. It is very easy to install and use. HypriotOS prides itself for coming with very recent versions of the Linux kernel and all included software.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Our new mission statement is:&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&amp;ldquo;HypriotOS is a minimal Debian-based operating system for &lt;strong&gt;many popular IoT devices&lt;/strong&gt; that provides an optimized environment for running Docker. It is very easy to install and use. HypriotOS prides itself for coming with very recent versions of the Linux kernel and all included software.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It is just a small change but it will have big implications.&lt;/p&gt;

&lt;p&gt;One of the biggest downsides of having an ever increasing amount of IoT devices to choose from is fragmentation. Each device comes with varying support for existing operating systems.
Take Linux for instance. Even if a vendor provides Linux support for a device from the start - it is often based on an outdated Linux kernel.
This in turn often enough means that you can only use old software on top of it. Docker with OverlayFS is such an example. It can only be used with a Linux kernel greater than 3.18.
And that&amp;rsquo;s not only a problem of the small vendors, it even happens with big vendors like NVIDIA. The NVIDIA ShieldTV is provided only with a 3.10 Linux kernel while the latest stable Linux kernel is 4.4.
Not to mention that the 3.10 kernel is &lt;a href=&#34;https://www.kernel.org/category/releases.html&#34;&gt;not supported any more by the kernel maintainers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this background in mind a major goal of HypriotOS is to provide an operating system that behaves as similar as possible on &lt;strong&gt;different&lt;/strong&gt; IoT devices.
While I know that this might prove to be a difficult task - especially in regards to support for recent Linux kernels - I think it might prove to be a worthwhile effort that provides much value.&lt;/p&gt;

&lt;p&gt;Providing a beta version of HypriotOS that supports three different development boards is a first step into that direction.&lt;/p&gt;

&lt;p&gt;Being just able to flash HypriotOS on a SD card and get going in minutes is one of the basic promises of HypriotOS, so without further ado you can download it here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases&#34;&gt;HypriotOS for the Raspberry Pi&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/image-builder-nvidia-shieldtv/releases&#34;&gt;HypriotOS for the NVIDIA ShieldTV&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-c1/releases&#34;&gt;HypriotOS for the ODROID C1+&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hopefully you have a lot of fun trying out what HypriotOS has to offer!&lt;br /&gt;
&lt;strong&gt;Note:&lt;/strong&gt; We changed the default username to &lt;code&gt;pirate&lt;/code&gt; (password &lt;code&gt;hypriot&lt;/code&gt;) and disabled the &lt;code&gt;root&lt;/code&gt; user for security reasons.&lt;/p&gt;

&lt;p&gt;By adding support for many more boards we think HypriotOS gets a lot more attractive! What do you think?&lt;br /&gt;
And for which board would you want to see support next?
Help us to get your favourite ARM board supported by HypriotOS!&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.
You also might wanna discuss this article on &lt;a href=&#34;https://news.ycombinator.com/item?id=10926502&#34;&gt;HackerNews&lt;/a&gt; or vote it up if you find it interesting.&lt;/p&gt;

&lt;p&gt;Govinda aka &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@&lt;em&gt;beagile&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>