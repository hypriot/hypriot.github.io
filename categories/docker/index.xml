<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Docker Pirates ARMed with explosive stuff</title>
    <link>https://blog.hypriot.com/categories/docker/</link>
    <description>Recent content in Docker on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Nov 2016 13:42:20 +0100</lastBuildDate>
    <atom:link href="https://blog.hypriot.com/categories/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Fix Dirty COW on Raspberry Pi the Docker way</title>
      <link>https://blog.hypriot.com/post/fix-dirty-cow-on-raspberry-pi/</link>
      <pubDate>Tue, 01 Nov 2016 13:42:20 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/fix-dirty-cow-on-raspberry-pi/</guid>
      <description>

&lt;p&gt;Have you seen the latest reports about the Linux kernel security vulnerability called &amp;ldquo;Dirty COW&amp;rdquo;?
Dirty COW is a &lt;a href=&#34;http://www.theregister.co.uk/2016/10/21/linux_privilege_escalation_hole/&#34;&gt;race condition in Linux&lt;/a&gt; arising from how Copy-On-Write (the COW in the name) is handled by the kernel&amp;rsquo;s memory subsystem&amp;rsquo;s use of private mappings.&lt;/p&gt;

&lt;p&gt;The really dangerous point here is, it can be used to &lt;a href=&#34;http://www.theregister.co.uk/2016/11/01/docker_user_havent_patched_dirty_cow_yet_bad_news/&#34;&gt;escape Docker containers&lt;/a&gt;.
&lt;img src=&#34;https://blog.hypriot.com/images/fix-dirty-cow-on-raspberry-pi/dirty-cow-001.jpg&#34; alt=&#34;dirty-cow-001&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So, we&amp;rsquo;re encourage you to immediately fix it with upgrading your Linux kernel on the Raspberry Pi !!!&lt;/p&gt;

&lt;p&gt;No matter if you&amp;rsquo;re running an official Raspbian or HypriotOS, please upgrade your Linux kernel to be safe again&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;tl-dr-fast-fixing:3be4aa7cb9bc4e1cf6956202774eb827&#34;&gt;TL;DR - Fast Fixing&lt;/h3&gt;

&lt;p&gt;For all the impatient users, here are the essential steps to upgrade your Linux kernel in an easy way on your Raspberry Pi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS&lt;/strong&gt; and &lt;strong&gt;Raspbian Jessie&lt;/strong&gt; (more details can be found &lt;a href=&#34;https://www.raspberrypi.org/blog/#fix-dirty-cow-raspberry-pi&#34;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For both operating systems it requires a system reboot to exchange the running Linux kernel in memory. But once you&amp;rsquo;ve done these easy steps you have successfully fixed the Dirty COW vulnerability.&lt;/p&gt;

&lt;h3 id=&#34;testing-for-dirty-cow-with-the-help-of-docker:3be4aa7cb9bc4e1cf6956202774eb827&#34;&gt;Testing for Dirty COW with the help of Docker&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to know whether your system is vulnerable against Dirty COW you can easily run a test with the help of a Docker Image. The complete source code can be found in my Github repo &lt;a href=&#34;https://github.com/DieterReuter/rpi-dirtycow&#34;&gt;DieterReuter/rpi-dirtycow&lt;/a&gt;, so you can build everything on your own, too.&lt;/p&gt;

&lt;p&gt;Running this single command is just absolutely easy and this is one of the benefits of Docker, you don&amp;rsquo;t have to install anything on your host machine. Just run a Docker container in a secure way and get instant results within seconds.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s do some testing on two different operating systems for the Raspberry Pi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Raspbian Jessie LITE (2016-09-23)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve used a freshly installed Raspbian Lite for these tests and you can see, we do have a Linux kernel 4.4.21.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux raspberrypi 4.4.21-v7+ #911 SMP Thu Sep 15 14:22:38 BST 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t have the Docker Engine already installed on Raspbian, you can perform it with this few commands - YEAH, it&amp;rsquo;s just so easy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sSL https://get.docker.com | bash
$ sudo usermod -aG docker pi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, logout and login again to get access to the Docker CLI from your default &amp;ldquo;pi&amp;rdquo; user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker --version
Docker version 1.12.3, build 6b644ec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have Docker installed, we can test against Dirty COW.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run hypriot/rpi-dirtycow
Unable to find image &#39;hypriot/rpi-dirtycow:latest&#39; locally
latest: Pulling from hypriot/rpi-dirtycow
38070c4d0c33: Pull complete
a3ed95caeb02: Pull complete
2d2e2d46b9b5: Pull complete
Digest: sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Status: Downloaded newer image for hypriot/rpi-dirtycow:latest

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are VULNERABLE!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s upgrade the Linux kernel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;ll test it again. Hopefully we&amp;rsquo;ve fixed it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux raspberrypi 4.4.26-v7+ #915 SMP Thu Oct 20 17:08:44 BST 2016 armv7l GNU/Linux

$ docker run hypriot/rpi-dirtycow

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are SAFE!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New Linux kernel 4.4.26 is installed for Raspbian and Dirty COW is fixed!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Did you mentioned the different output from the &lt;code&gt;docker run&lt;/code&gt; commands? The first time, Docker has detected that the Docker Image &amp;ldquo;hypriot/rpi-dirtycow&amp;rdquo; is not on the machine and downloads/pulls the required image layers. The second time it can just start the Docker container.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS 1.1.0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;m using the latest HypriotOS 1.1.0 release, but the Linux kernel upgrade works even for an older 0.8 release.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux black-pearl 4.4.24-hypriotos-v7+ #1 SMP PREEMPT Tue Oct 11 17:15:58 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test for Dirty COW.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time docker run hypriot/rpi-dirtycow
Unable to find image &#39;hypriot/rpi-dirtycow:latest&#39; locally
latest: Pulling from hypriot/rpi-dirtycow
38070c4d0c33: Pull complete
a3ed95caeb02: Pull complete
2d2e2d46b9b5: Pull complete
Digest: sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Status: Downloaded newer image for hypriot/rpi-dirtycow:latest

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are VULNERABLE!!!

real	0m14.514s
user	0m0.200s
sys	0m0.180s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You can see, it takes just under 15 seconds to pull the Docker Image and to perform the test against the Dirty COW vulnerability. We didn&amp;rsquo;t installed anything on the host machine for these tests and we can get rid of the Docker image later on and clean our host system easily.&lt;/p&gt;

&lt;p&gt;Upgrade the Linux kernel for HypriotOS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we have the latest Linux kernel 4.4.27 for HypriotOS installed and we&amp;rsquo;re safe again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux black-pearl 4.4.27-hypriotos-v7+ #1 SMP PREEMPT Fri Oct 28 09:06:49 UTC 2016 armv7l GNU/Linux

$ time docker run hypriot/rpi-dirtycow

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are SAFE!

real	0m4.504s
user	0m0.100s
sys	0m0.050s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we&amp;rsquo;ll remove the Docker Image we&amp;rsquo;ve used for the tests and free some disk space.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
hypriot/rpi-dirtycow   latest              31229be9ea1d        3 days ago          5.512 MB

$ docker rmi -f 31229be9ea1d
Untagged: hypriot/rpi-dirtycow:latest
Untagged: hypriot/rpi-dirtycow@sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Deleted: sha256:31229be9ea1d01ed2df47cc23ab50efdc84be3b49572bb4b6047a449dea4e596

$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This is another great advantage by Docker - get rid of all the tools we don&amp;rsquo;t need anymore.&lt;/p&gt;

&lt;h3 id=&#34;conclusion-upgrade-your-system-regularly:3be4aa7cb9bc4e1cf6956202774eb827&#34;&gt;Conclusion: upgrade your system regularly&lt;/h3&gt;

&lt;p&gt;Your Raspberry Pi system is now SAFE again. In the future don&amp;rsquo;t forget to upgrade it from time to time. On both operating systems, Raspbian and HypriotOS, you can do the upgrade procedure with these few commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with this way you&amp;rsquo;ll get some other tools updated as well, like the Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker version
Client:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 19:06:36 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 19:06:36 2016
 OS/Arch:      linux/arm
HypriotOS/armv7: pirate@black-pearl in ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all and STAY SAFE !!!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please:3be4aa7cb9bc4e1cf6956202774eb827&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visualize your Raspberry Pi containers with Portainer or UI for Docker</title>
      <link>https://blog.hypriot.com/post/new-docker-ui-portainer/</link>
      <pubDate>Mon, 31 Oct 2016 15:18:33 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/new-docker-ui-portainer/</guid>
      <description>

&lt;p&gt;At home I use some Raspberry Pi&amp;rsquo;s for some home network services, and I run
these services inside Docker containers. From time to time I want to see or
manage one of these containers. But I&amp;rsquo;m too lazy to get to my laptop and use
the Docker CLI for that. There are two nice Docker UI&amp;rsquo;s to access your Docker engine with a web browser. Let&amp;rsquo;s have a look at both.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-docker.png&#34; alt=&#34;Portainer&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;ui-for-docker-formerly-known-as-dockerui:9b02a9b5d0cf4c4b78c5b66f0c71e56f&#34;&gt;UI for Docker, formerly known as DockerUI&lt;/h2&gt;

&lt;p&gt;I have started using the DockerUI, an open source project from Michael Crosby and Kevan Ahlquist. You can find the source code on GitHub at &lt;a href=&#34;https://github.com/kevana/ui-for-docker&#34;&gt;https://github.com/kevana/ui-for-docker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://github.com/StefanScherer/docker-at-home/blob/eb451b954809393e8536259aff6daf27bfb7b7b8/docker-compose.yml#L27-L35&#34;&gt;my home setup&lt;/a&gt; I use Docker Compose to configure how to run my services.&lt;/p&gt;

&lt;p&gt;This is my configuration to start the UI so I can reach it on port 80 of the Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ui:
  image: hypriot/rpi-dockerui
  restart: always
  volumes:
    - &#39;/var/run/docker.sock:/var/run/docker.sock&#39;
  expose:
    - 9000
  ports:
    - 80:9000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we provide a Docker image &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-dockerui/&#34;&gt;hypriot/rpi-dockerui&lt;/a&gt; on the Docker hub so it is very easy to use it in your environment.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look at the dashboard which shows you an overview of your running or stopped containers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-dashboard.png&#34; alt=&#34;DockerUI Dashboard&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;You can click on each container and see more details and so some actions with them like stopping and starting them again.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-container.png&#34; alt=&#34;DockerUI Container&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The UI provides some more views to list for example all local Docker images and information about your Docker engine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-images.png&#34; alt=&#34;DockerUI Images&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;portainer:9b02a9b5d0cf4c4b78c5b66f0c71e56f&#34;&gt;Portainer&lt;/h2&gt;

&lt;p&gt;Last week I found &lt;a href=&#34;http://portainer.io&#34;&gt;portainer.io&lt;/a&gt; which also looks very good. They provide Docker images for Linux and Windows, &lt;del&gt;but not for ARM right now&lt;/del&gt; and as well an image for ARM.&lt;/p&gt;

&lt;p&gt;The source code is also available on GitHub &lt;a href=&#34;https://github.com/portainer/portainer&#34;&gt;https://github.com/portainer/portainer&lt;/a&gt; and it&amp;rsquo;s based on the work of DockerUI.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/portainer/portainer/pull/299&#34;&gt;pull request&lt;/a&gt; to add Linux ARM support was merged and now you can get the Docker image for the Rapsberry Pi using the image &lt;a href=&#34;https://hub.docker.com/r/portainer/portainer/&#34;&gt;portainer/portainer:arm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Just use the same Docker Compose sample from above and replace the image name. Killing the old container and running a new one with &lt;code&gt;docker-compose up -d ui&lt;/code&gt; you have Portainer up and running.&lt;/p&gt;

&lt;p&gt;The dashboard also gives you an overview of all running containers, all images etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-dashboard.png&#34; alt=&#34;Portainer Dashboard&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;In the container list you can see all running and stopped containers as well as some actions you can do with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-container.png&#34; alt=&#34;Portainer Dashboard&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Clicking on one of the running containers you have access to the details, environment variables, port mappings, volumes.
You can also access some CPU/memory and network statistics as well as the logs of your container, as well as the processes running inside the container.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-stats.png&#34; alt=&#34;Portainer Stats&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;conclusion:9b02a9b5d0cf4c4b78c5b66f0c71e56f&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you want to remote control your Raspberry Pi Docker containers from a nice Web UI, then try
one of these prebuilt Docker images. Of course be aware that everyone in your home network
is able to manipulate your Docker containers with it as there is no login dialog.
But for some private projects it is still an advantage to simplify starting and stopping containers from your mobile phone.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing High Availability of Docker Swarm on a Raspberry Pi Cluster (Updated)</title>
      <link>https://blog.hypriot.com/post/high-availability-with-docker/</link>
      <pubDate>Wed, 26 Oct 2016 18:03:34 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/high-availability-with-docker/</guid>
      <description>

&lt;p&gt;In its release in June this year, Docker announced two exciting news about the Docker Engine: First, the Engine 1.12 comes with built-in high availability features, called &amp;ldquo;Docker Swarm Mode&amp;rdquo;. And second, Docker started providing official support for the ARM architecture.&lt;/p&gt;

&lt;p&gt;These two news combined beg for testing the new capabilities in reality.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/high-availability-docker-swarm.png&#34; alt=&#34;SwarmClusterHA&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;old&amp;rdquo; Docker Swarm already offered some high availability features, but the new called &amp;ldquo;Swarm Mode&amp;rdquo; goes far beyond: To me, the most important capabilities to mention are: built-in security, rolling updates and - maybe one of the most important benefits - super user-friendliness. Production ready clustering based on powerful container technology has probably never been easier before.&lt;/p&gt;

&lt;p&gt;Also, the release of Docker 1.12 comes with official support for the ARM architecture. Running Docker on ARM has been possible for long time, but now, users can install it the same way on their Raspberry Pis as they do it on any other architecture: Using Docker&amp;rsquo;s official repositories. If you are one of our regular readers, you know that our Team at Hypriot intensively collaborated with Docker to make this official support possible. So we are also very happy that this huge milestone that many people asked for is eventually checked!&lt;/p&gt;

&lt;p&gt;Now, with these two news, let&amp;rsquo;s get our hands dirty and test if the announced promises hold.&lt;/p&gt;

&lt;h2 id=&#34;setup-the-cluster:a00c34eb72f8a894fd7d46707edd473e&#34;&gt;Setup the cluster&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;As hardware&lt;/strong&gt;, I have 5x Raspberry Pi 3, connected in a network with Internet access.&lt;/p&gt;

&lt;p&gt;The Raspberry Pis with their SD cards, the network switch, power input and all cables live in a &lt;a href=&#34;https://www.picocluster.com/collections/starter-picocluster-kits/products/pico-5-raspberry-pi-starter-kit?variant=29344698892&#34;&gt;hardware kit from PicoCluster&lt;/a&gt;. Thanks to PicoCluster for providing the kit to us for testing!&lt;/p&gt;

&lt;p&gt;See how the cluster looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/PicoCluster.jpg&#34; alt=&#34;PicoClusterBuilt&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;As software&lt;/strong&gt;, I chose HypriotOS. I also tried Raspbian, but it requires a large system upgrade after the first boot in order to provide all features required by Docker (e.g. VXLAN kernel module). Before and after the system upgrade, I also had to run &lt;a href=&#34;https://github.com/docker/docker/blob/master/contrib/check-config.sh&#34;&gt;Docker&amp;rsquo;s test script&lt;/a&gt; to make sure everything is ok. All of this is not a big deal, but if there is an OS available that comes out of the box with all that Docker needs (and even adds lots of useful optimizations), it simply saves time and provides a hassle-free experience. So I flashed all SD cards with HypriotOS using our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;To connect to the cluster&lt;/strong&gt;, I SSHed into all the nodes via &lt;a href=&#34;http://gnometerminator.blogspot.de/p/introduction.html&#34;&gt;Terminator&lt;/a&gt;. Terminator is my preferred tool to organize multiple terminals in a single window. It allows to send commands to several terminals at once. Soon, I&amp;rsquo;ll have a look at tmux and might switch, but for now I recommend Terminator :)&lt;/p&gt;

&lt;p&gt;Finally, we have 5 terminals opened, all waiting for commands as you see in the following image. Please don&amp;rsquo;t care about the commands running in each terminal for now.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/high-availability-testing/terminal.png&#34; alt=&#34;Terminator&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all to do before getting our hands on Docker itself!&lt;/p&gt;

&lt;h2 id=&#34;setup-docker-swarm-on-the-cluster:a00c34eb72f8a894fd7d46707edd473e&#34;&gt;Setup Docker Swarm on the cluster&lt;/h2&gt;

&lt;p&gt;On latest HypriotOS, you&amp;rsquo;ll have the latest Docker installed, so we can instantly start playing.&lt;/p&gt;

&lt;p&gt;On an arbitrary node of the cluster, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker swarm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output should look similar to that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Swarm initialized: current node (node-master) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-1acm9qa7b0hmzz5v8t40d75v5fsgckeu2z5ds6ls0x7cny7l8p-307wqrc8756akpxjxls9abbbs \
    [2a02:810d:8600:2a78:f6c6:d67d:6912:17ca]:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As explained in this output, now you need to run the presented &lt;code&gt;docker swarm join ...&lt;/code&gt; command on all other nodes, which you want to join the cluster.&lt;/p&gt;

&lt;p&gt;Finally, on the node at which you executed &lt;code&gt;docker swarm init&lt;/code&gt;, check if all nodes of your cluster successfully formed a swarm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker node ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the terminal prints a list of all nodes of your cluster, the setup is all done! Forming a cluster cannot be easier, can it?&lt;/p&gt;

&lt;h2 id=&#34;execution-of-tests:a00c34eb72f8a894fd7d46707edd473e&#34;&gt;Execution of tests&lt;/h2&gt;

&lt;p&gt;My tests of Docker&amp;rsquo;s ability to recover from failures comprise the following use cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The ethernet interface of a random node (master or slave) got unavailable&lt;/li&gt;
&lt;li&gt;A random node completely rebooted&lt;/li&gt;
&lt;li&gt;A random node instantly crashed (unplug power source)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I documented one of the test runs in the following screencast.&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;iframe src=&#34;https://player.vimeo.com/video/185361173&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&#34;https://vimeo.com/185361173&#34;&gt;Testing High Availability Docker Swarm Mode&lt;/a&gt; from &lt;a href=&#34;https://vimeo.com/user54109827&#34;&gt;Mathias Renner&lt;/a&gt; on &lt;a href=&#34;https://vimeo.com&#34;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;results:a00c34eb72f8a894fd7d46707edd473e&#34;&gt;Results&lt;/h2&gt;

&lt;p&gt;As shown in the screencast, Docker is able to recover from failure of the ethernet interface. After testing the other use cases later on, Docker recovered flawlessly from a reboot and crash as well. This holds for the slave and the master node, which is remarkable!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Edit on 6.11.2016&lt;/strong&gt;: Jérémy Derussé and Nikolay Kushin reported in the discussion below that for them a reboot or crash of a node did not result in a healthy cluster state after bringing up the node again. As of today, unfortunately I can confirm this, with Docker version 1.12.1, 1.12.2 as well as 1.12.3. I cannot explain why during my tests for this post a crashed node recovered smoothly.&lt;/p&gt;

&lt;p&gt;Based on Jeremy&amp;rsquo;s report, I was able to create a quick fix for this issue. On a node, simply run:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;sudo crontab -e&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There, insert the following line (without quotation marks) and save the file.&lt;/p&gt;

&lt;p&gt;&amp;rdquo;@reboot docker ps&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Having this configured, after a crash or reboot the node recovered correctly in my tests. I look forward for feedback about this issue! Please use the discussion below.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;more-to-come-soon:a00c34eb72f8a894fd7d46707edd473e&#34;&gt;More to come soon&lt;/h2&gt;

&lt;p&gt;This post is only a small chunk of the data I gathered during the tests. The next option to get the details is during my talk at the &lt;a href=&#34;http://highload.co/&#34;&gt;HighLoad++ Conference&lt;/a&gt; in Moskow, Russia. I&amp;rsquo;d be happy if you can make it there!&lt;/p&gt;

&lt;p&gt;Also, this is not the end of the story of course. Thorough testing requires also measuring incoming requests from an external load tester to the cluster while a failure occurs. After some research, I have not found any evidence that someone has ever performed that tests (please correct me if I&amp;rsquo;m wrong!).&lt;/p&gt;

&lt;p&gt;Moreover, Kubernetes received much attention lately since its support for ARM became better and better. So wouldn&amp;rsquo;t it be interesting to see if Docker or Kubernetes is better in keeping a service available and performing well, even if there are outages in the cluster?&lt;/p&gt;

&lt;p&gt;So there&amp;rsquo;s more coming soon, just stay tuned for the upcoming posts :)&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploying an IoT Swarm with Docker Machine</title>
      <link>https://blog.hypriot.com/post/deploy-swarm-on-chip-with-docker-machine/</link>
      <pubDate>Sun, 04 Sep 2016 19:45:58 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/deploy-swarm-on-chip-with-docker-machine/</guid>
      <description>

&lt;p&gt;With the new SwarmMode in Docker 1.12 it is really damn easy to build a Docker Swarm and connect different ARM devices to an IoT cluster.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-flashing1.jpg&#34; alt=&#34;swarm-chip-flashing1.jpg&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s connect a few of the $9 C.H.I.P. computers and a Raspberry Pi Zero all through a WiFi network&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;step-1-install-docker-machine:2916a0476909fe024f00614543881ecf&#34;&gt;Step 1: Install Docker Machine&lt;/h4&gt;

&lt;p&gt;First of all, we need to make sure we do have Docker Machine installed on our local computer. I&amp;rsquo;m using a Mac for this tutorial, but you can use Docker Machine on Linux or Windows too. If not already done, you should install the latest Docker Machine binary following the &lt;a href=&#34;https://docs.docker.com/machine/install-machine/&#34;&gt;Install Docker Machine&lt;/a&gt; instructions.&lt;/p&gt;

&lt;p&gt;You can easily check the version of Docker Machine with the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine --version
docker-machine version 0.8.0, build b85aac1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-2-prepare-all-c-h-i-p-s-with-docker-machine:2916a0476909fe024f00614543881ecf&#34;&gt;Step 2: Prepare all C.H.I.P.&amp;rsquo;s with Docker Machine&lt;/h4&gt;

&lt;p&gt;In order to connect a couple of C.H.I.P. computers to a Docker Swarm cluster, we have to install Docker 1.12.1 first. This can be done easily by following the steps of my last tutorial &lt;a href=&#34;https://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt;. Then we&amp;rsquo;re using the standard Docker Machine from a Mac to attach each C.H.I.P. device via a secured Docker API port and give each device an individual hostname on the network. With the help of Docker Machine it&amp;rsquo;s easier to access all the C.H.I.P. devices we&amp;rsquo;d like to connect to the Swarm cluster from a Mac, Linux or Windows machine.&lt;/p&gt;

&lt;p&gt;Here are the basic steps we have to follow for each single C.H.I.P. computer:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;flash C.H.I.P. and install Docker 1.12.1&lt;/li&gt;
&lt;li&gt;detect the IP address and use Docker Machine&lt;/li&gt;
&lt;li&gt;restart Avahi daemon or reboot C.H.I.P.&lt;/li&gt;
&lt;li&gt;check the device connectivity via network and Docker API&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Flashing the C.H.I.P. computer in FEL mode with UART console cable attached: &lt;br&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-flashing2.jpg&#34; alt=&#34;swarm-chip-flashing2.jpg&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As soon as we&amp;rsquo;ve installed our first C.H.I.P. with Docker we&amp;rsquo;ll use its IP address and run &lt;code&gt;docker-machine create&lt;/code&gt; and let&amp;rsquo;s do some Docker magic and we have secured the network access to its Docker Engine easily. In this command I&amp;rsquo;m using the flag &lt;code&gt;--debug&lt;/code&gt; to get a more verbose output, so you can see all the details whats going on in the background, but you can omit this flag for the remaining C.H.I.P.&amp;rsquo;s.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CHIP_IP_ADDRESS=192.168.2.112
CHIP_NODENAME=swarm-chip01

docker-machine --debug create \
  --driver=generic \
  --engine-storage-driver=overlay \
  --generic-ip-address=$CHIP_IP_ADDRESS \
  $CHIP_NODENAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After successfully running this command, the C.H.I.P. device is attached to Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME           ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01   -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the C.H.I.P. itself you can see that the hostname has changed. So let&amp;rsquo;s check this in detail to get a better understanding what&amp;rsquo;s happening behind the scene. Now we&amp;rsquo;re using some Docker Machine fu to connect to the device.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01
root@swarm-chip01:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hostname has changed to &lt;code&gt;swarm-chip01&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/hostname
swarm-chip01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so there is a new local loopback address included as &lt;code&gt;127.0.1.1 swarm-chip01&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/hosts
127.0.0.1      	chip
127.0.0.1      	localhost
::1    		localhost ip6-localhost ip6-loopback
ff02::1		ip6-allnodes
ff02::2		ip6-allrouters

127.0.1.1 swarm-chip01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check if we can reach the C.H.I.P. from the network with its new hostname.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-chip01.local
ping: cannot resolve swarm-chip01.local: Unknown host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately the Avahi service discovery daemon didn&amp;rsquo;t changed the hostname, so we have to restart it manually to get the changes in order to reach the C.H.I.P. with it&amp;rsquo;s new hostname from the WiFi network. Alternatively we can just reboot the C.H.I.P. to activate these changes. So let&amp;rsquo;s do it through Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 systemctl restart avahi-daemon.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And check with ping again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-chip01.local
PING swarm-chip01.local (192.168.2.112): 56 data bytes
64 bytes from 192.168.2.112: icmp_seq=0 ttl=64 time=105.129 ms
64 bytes from 192.168.2.112: icmp_seq=1 ttl=64 time=3.529 ms
64 bytes from 192.168.2.112: icmp_seq=2 ttl=64 time=48.178 ms

--- swarm-chip01.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 3.529/52.279/105.129/41.579 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s up to you to repeat these steps for all the remaining C.H.I.P. devices. After some time you should be ready and having a list of devices connected to Docker Machine. I&amp;rsquo;ve done this with six C.H.I.P.&amp;rsquo;s, and one of them is an Alpha unit which works exactly the same way without any differences.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME            ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01    -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
swarm-chip02    -        generic   Running   tcp://192.168.2.116:2376           v1.12.1
swarm-chip03    -        generic   Running   tcp://192.168.2.117:2376           v1.12.1
swarm-chip04    -        generic   Running   tcp://192.168.2.118:2376           v1.12.1
swarm-chip05    -        generic   Running   tcp://192.168.2.120:2376           v1.12.1
swarm-chip06    -        generic   Running   tcp://192.168.2.104:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-3-initialize-the-swarm-create-a-swarm-manager:2916a0476909fe024f00614543881ecf&#34;&gt;Step 3: Initialize the Swarm, create a Swarm manager&lt;/h4&gt;

&lt;p&gt;As soon as all the C.H.I.P.&amp;rsquo;s are prepared we are able to initiate a Swarm cluster. We are creating a Swarm manager first and then we can attach the other C.H.I.P.&amp;rsquo;s as additional Swarm managers or Swarm workers pretty easily. All the steps to form a Swarm cluster are literally a single command per device only!&lt;/p&gt;

&lt;p&gt;With this command the Swarm will be initialized.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker swarm init
Swarm initialized: current node (8174iszkmn4u4wwjogam8bsrw) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
    192.168.2.112:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we do have our first Swarm manager running.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
8174iszkmn4u4wwjogam8bsrw *  swarm-chip01  Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-4-set-up-swarm-for-high-availability-attach-more-swarm-managers:2916a0476909fe024f00614543881ecf&#34;&gt;Step 4: Set up Swarm for high-availability, attach more Swarm managers&lt;/h4&gt;

&lt;p&gt;In order to build a high-availability Swarm cluster, we like to join two additional Swarm managers. So, first we have to ask the Swarm Leader for an access token to join new Swarm managers. You have to know that the complete control traffic between Swarm nodes is secured by default.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
    192.168.2.112:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this given command we can now join the nodes &lt;code&gt;swarm-chip02&lt;/code&gt; and &lt;code&gt;swarm-chip02&lt;/code&gt; as Swarm managers with a single command for each of the nodes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip02 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
  192.168.2.112:2377
This node joined a swarm as a manager.

docker-machine ssh swarm-chip03 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-beiuuzahvn9f7c1q42irqzncb \
  192.168.2.112:2377
This node joined a swarm as a manager.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Swarm status and the list of all Swarm nodes can be determined by asking any of the three Swarm managers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip01 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1    swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw *  swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02  Ready   Active        Reachable
OSX: dieter@DietersMacBookPro in ~/code/github/hypriot/blog on deploy-swarm-on-chip-with-docker-machine

docker-machine ssh swarm-chip02 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1    swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw    swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c *  swarm-chip02  Ready   Active        Reachable
OSX: dieter@DietersMacBookPro in ~/code/github/hypriot/blog on deploy-swarm-on-chip-with-docker-machine

docker-machine ssh swarm-chip03 docker node ls
ID                           HOSTNAME      STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1 *  swarm-chip03  Ready   Active        Reachable
8174iszkmn4u4wwjogam8bsrw    swarm-chip01  Ready   Active        Leader
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02  Ready   Active        Reachable
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-5-let-s-grow-the-swarm-attach-all-swarm-workers:2916a0476909fe024f00614543881ecf&#34;&gt;Step 5: Let&amp;rsquo;s grow the Swarm, attach all Swarm workers&lt;/h4&gt;

&lt;p&gt;Now it&amp;rsquo;s time to join our remaining C.H.I.P. devices as Swarm workers to our Swarm cluster. For this purpose we just pick the token from the initial Swarm creation command. But if we can&amp;rsquo;t remember we can just ask one of the Swarm managers for the access token with the command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip02 docker swarm join-token worker
To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
    192.168.2.116:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s join our workers one by one now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip04 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.

docker-machine ssh swarm-chip05 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.

docker-machine ssh swarm-chip06 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a result we have joined all of the six C.H.I.P. devices to the Swarm cluster, three as Swarm managers and three as Swarm workers.&lt;/p&gt;

&lt;h4 id=&#34;step-6-attach-an-additional-pi-zero-as-swarm-worker:2916a0476909fe024f00614543881ecf&#34;&gt;Step 6: Attach an additional Pi Zero as Swarm worker&lt;/h4&gt;

&lt;p&gt;But we&amp;rsquo;re not limited in using only one kind of ARM devices for our Swarm cluster. So I&amp;rsquo;d like to add a different device, a Raspberry Pi Zero which is equipped with a &lt;a href=&#34;https://twitter.com/redbearlab&#34;&gt;RedBear IoT pHAT&lt;/a&gt; for WiFi/Bluetooth connectivity.
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-pi-zero.jpg&#34; alt=&#34;swarm-chip-pi-zero.jpg&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Here you can see that using &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;HypriotOS for RPi&lt;/a&gt; and the Hypriot &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; it&amp;rsquo;s damn easy to create another ARM device with Docker 1.12.1 and attach it via WiFi to our network.&lt;/p&gt;

&lt;p&gt;Flash the SD card, and power up the Raspberry Pi Zero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n swarm-raspi01 -s &amp;quot;WLAN-R46VFR&amp;quot; -p &amp;quot;************&amp;quot; https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Determine the IP address of the Pi Zero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping -c 3 swarm-raspi01.local
PING swarm-raspi01.local (192.168.2.119): 56 data bytes
64 bytes from 192.168.2.119: icmp_seq=0 ttl=64 time=617.658 ms
64 bytes from 192.168.2.119: icmp_seq=1 ttl=64 time=26.326 ms
64 bytes from 192.168.2.119: icmp_seq=2 ttl=64 time=1187.048 ms

--- swarm-raspi01.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 26.326/610.344/1187.048/473.891 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare SSH access to the Pi Zero, use username=&lt;code&gt;pirate&lt;/code&gt; and password=&lt;code&gt;hypriot&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -R 192.168.2.119
ssh-copy-id pirate@192.168.2.119
ssh pirate@192.168.2.119
uname -a
Linux swarm-raspi01 4.4.15-hypriotos+ #2 PREEMPT Mon Jul 25 09:18:11 UTC 2016 armv6l GNU/Linux
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Login and install a fix on the Pi so we can use the standard Docker Machine binary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@192.168.2.119
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/001-fix-docker-machine-1.8.0-create-for-arm/apply-fix-001.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back on our Mac we are able to run Docker Machine and attach the Raspi. As you can see, we do use another flag &lt;code&gt;--generic-ssh-user=pirate&lt;/code&gt; because we&amp;rsquo;re using a different username instead of the default &lt;code&gt;root&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RASPI_IP_ADDRESS=192.168.2.119
RASPI_NODENAME=swarm-raspi01

docker-machine --debug create \
  --driver=generic \
  --engine-storage-driver=overlay \
  --generic-ip-address=$RASPI_IP_ADDRESS \
  --generic-ssh-user=pirate \
  $RASPI_NODENAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a few minutes only, the Raspberry Pi Zero can be accessed through Docker Machine with the exactly same methods and commands like the C.H.I.P. devices.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ls --filter name=swarm*
NAME            ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER    ERRORS
swarm-chip01    -        generic   Running   tcp://192.168.2.112:2376           v1.12.1
swarm-chip02    -        generic   Running   tcp://192.168.2.116:2376           v1.12.1
swarm-chip03    -        generic   Running   tcp://192.168.2.117:2376           v1.12.1
swarm-chip04    -        generic   Running   tcp://192.168.2.118:2376           v1.12.1
swarm-chip05    -        generic   Running   tcp://192.168.2.120:2376           v1.12.1
swarm-chip06    -        generic   Running   tcp://192.168.2.104:2376           v1.12.1
swarm-raspi01   -        generic   Running   tcp://192.168.2.119:2376           v1.12.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we join our last Swarm worker, a lonely Raspberry Pi Zero running HypriotOS 1.0.1 and Docker 1.12.1, to the Swarm cluster.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-raspi01 \
  docker swarm join \
  --token SWMTKN-1-2olhigqvrmxkbby00qarokzdd6cmy0ovak6fst77y4qnec4ufv-4utgsw8ed9a0cyxx86yygqvzt \
  192.168.2.112:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-7-check-the-complete-swarm:2916a0476909fe024f00614543881ecf&#34;&gt;Step 7: Check the complete Swarm&lt;/h4&gt;

&lt;p&gt;With the &lt;code&gt;docker node ls&lt;/code&gt; command issued on any of the Swarm managers we can list all the Swarm nodes, get their roles and status shown in the printed output on our terminal window.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-machine ssh swarm-chip03 docker node ls
ID                           HOSTNAME       STATUS  AVAILABILITY  MANAGER STATUS
1qelz3ttd54mh8fb57hf67ff1 *  swarm-chip03   Ready   Active        Reachable
3inlk62a6l3afqp570nnus12f    swarm-raspi01  Ready   Active
7jvz6c8a852rve1r21fordkfa    swarm-chip04   Ready   Active
8174iszkmn4u4wwjogam8bsrw    swarm-chip01   Ready   Active        Leader
91ee08vkwuh3f6yelc4ci46se    swarm-chip05   Ready   Active
agglzv8ju0diwpd665nbhdtti    swarm-chip06   Ready   Active
ctggddtwrg0ybrwpa52heaz9c    swarm-chip02   Ready   Active        Reachable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-node-ls.jpg&#34; alt=&#34;swarm-chip-node-ls.jpg&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;the-result-a-mixed-iot-swarm-running-docker-1-12:2916a0476909fe024f00614543881ecf&#34;&gt;THE RESULT: a mixed IoT Swarm running Docker 1.12&lt;/h3&gt;

&lt;p&gt;This is our newly created Swarm cluster, built with an USB power supply from Anker, 6x C.H.I.P. computers and a lonely Raspberry Pi Zero - all devices attached through a WiFi network and running Docker 1.12.1 with SwarmMode: &lt;br&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/deploy-swarm-on-chip-with-docker-machine/swarm-chip-complete-cluster.jpg&#34; alt=&#34;swarm-chip-complete-cluster.jpg&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;next-steps:2916a0476909fe024f00614543881ecf&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;With this hardware setup we&amp;rsquo;ve now built a network of seven ARM devices for IoT which are all connected through WiFi. All the control traffic between the nodes are secured be default and can be centrally controlled through the Swarm managers and we can connect them securely from a local computer via Docker Machine. The ARM boards can be spread out in your house and can run different tasks as Docker containers&amp;hellip; but these details I&amp;rsquo;d like to cover in a future blog post.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please:2916a0476909fe024f00614543881ecf&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Install Docker 1.12 on the $9 C.H.I.P. computer</title>
      <link>https://blog.hypriot.com/post/install-docker-on-chip-computer/</link>
      <pubDate>Sat, 03 Sep 2016 22:53:12 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/install-docker-on-chip-computer/</guid>
      <description>

&lt;p&gt;Did you see the successfully launch of a really cheap ARM board for $9 only - the C.H.I.P. computer? It has an ARMv7 CPU with 512 MByte of main memory, 4 GByte flash memory as disk storage and is equipped with onboard WiFi and bluetooth as well.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-and-banana.jpg&#34; alt=&#34;chip-and-banana&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;With these awesome features built-in it would be really a great device to run Docker containers if only the recent Linux kernel 4.4  has the correct modules included, but it doesn&amp;rsquo;t - what a bummer!&lt;/p&gt;

&lt;p&gt;But with spending a lot of time in building a custom Linux kernel and tweaking &amp;amp; testing I was finally able to install the latest Docker Engine for ARM on the C.H.I.P. &amp;mdash; and as a result you can easily follow this tutorial and within a few minutes only you can run your first Docker container on this cute ARM board&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-photo.jpg&#34; alt=&#34;chip-photo&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;background:f104f10590263b135a4ba1767b05f846&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Preparing your operating system and your Linux kernel to be able to run the Docker Engine efficiently can be a hard thing and can consume a lot of labor time.&lt;/p&gt;

&lt;p&gt;Fortunately in this tutorial I&amp;rsquo;ll show you the basic steps to get Docker running on the $9 C.H.I.P. computer, so every normal user should be able to do it on her own within a short time only - even without the need being an expert in this area. And if you&amp;rsquo;re in a hurry you can skip most of the tutorial and go straight ahead to the &lt;code&gt;Lessons learned - TL;DR&lt;/code&gt; section and install Docker with just two single commands.&lt;/p&gt;

&lt;h3 id=&#34;necessary-steps-to-install-docker:f104f10590263b135a4ba1767b05f846&#34;&gt;Necessary steps to install Docker&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Flash the latest available firmware&lt;/li&gt;
&lt;li&gt;Connect to the C.H.I.P. via USB or UART console cable&lt;/li&gt;
&lt;li&gt;Configure WiFi connection&lt;/li&gt;
&lt;li&gt;Configure SSH to access the C.H.I.P.&lt;/li&gt;
&lt;li&gt;Checking the OS and Linux kernel version&lt;/li&gt;
&lt;li&gt;Install the Docker Engine 1.12.1 the easy way&lt;/li&gt;
&lt;li&gt;Upgrade the Linux kernel to a custom built version&lt;/li&gt;
&lt;li&gt;Run your first Docker Container on the C.H.I.P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;step-1-flash-the-latest-available-firmware:f104f10590263b135a4ba1767b05f846&#34;&gt;Step 1: Flash the latest available firmware&lt;/h4&gt;

&lt;p&gt;Use a Chrome browser and flash the latest firmware and OS on your C.H.I.P. computer. For detailed instructions go to the appropriate web site at &lt;a href=&#34;http://flash.getchip.com/&#34;&gt;http://flash.getchip.com/&lt;/a&gt;.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/flash-getchip-com.jpg&#34; alt=&#34;flash-getchip-com&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;To run Docker on the C.H.I.P. we&amp;rsquo;re using the OS image for &lt;code&gt;Debian Headless 4.4&lt;/code&gt;, which is a server installation without any GUI and thus it&amp;rsquo;s quite smaller is size, so we do have more space left for running apps and Docker containers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; You can even see all the detailed log messages while flashing via an UART console cable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Starting download of 6291508 bytes
................................................
downloading of 6291508 bytes finished
Flashing sparse image on partition UBI at offset 0x26800000 (ID: 10)
start 0x9a00 blkcnt 0x180 partition 0x400 size 0x7fc00
Writing at offset 0x26800000
New offset 0x27400000
........ wrote 384 blocks to &#39;UBI&#39;

*****************[ FLASHING DONE ]*****************
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-successfully-flashed.jpg&#34; alt=&#34;chip-successfully-flashed&#34; /&gt;
&lt;/p&gt;

&lt;h4 id=&#34;step-2-connect-to-the-c-h-i-p-via-usb-or-uart-console-cable:f104f10590263b135a4ba1767b05f846&#34;&gt;Step 2: Connect to the C.H.I.P. via USB or UART console cable&lt;/h4&gt;

&lt;p&gt;Once the C.H.I.P. is successfully flashed you can connect it directly with an USB cable to a Mac or Linux machine. The C.H.I.P. is getting power over the USB cable and connects via an USB serial console driver, so you can easily connect to.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find the booted C.H.I.P. on the USB wire:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -al /dev/cu.usb*
crw-rw-rw-  1 root  wheel   20, 159 Sep  3 16:52 /dev/cu.usbmodem141113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note 1:&lt;/em&gt; you have to wait a few minutes until the device can be detected as the C.H.I.P. has to be fully booted. &lt;br&gt;
&lt;em&gt;Note 2:&lt;/em&gt; it&amp;rsquo;s strongly recommended to use a powered USB hub, otherwise you&amp;rsquo;ll hit some power problems and the C.H.I.P. can&amp;rsquo;t access or can immediately shuts off&lt;/p&gt;

&lt;p&gt;Now we can connect to the ARM device via the &lt;code&gt;screen&lt;/code&gt; utility:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo screen /dev/cu.usbmodem141113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, and this is my preferred way, you can attach an UART console cable (e.g. from &lt;a href=&#34;https://www.adafruit.com/product/954&#34;&gt;AdaFruit&lt;/a&gt;) which is typically shown as a device on the Mac like &lt;code&gt;/dev/cu.usbserial&lt;/code&gt;. With this setup you can even watch the complete boot logs of the C.H.I.P. computer and you are able to see all early boot messages from U-Boot and from loading and starting the Linux kernel. This gives you all details in case there are any problems and issues with a homegrown kernel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo screen /dev/cu.usbserial 115200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you get to the login message, you can use username &lt;code&gt;root&lt;/code&gt; and password &lt;code&gt;chip&lt;/code&gt; to login:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Debian GNU/Linux 8 chip ttyS0

chip login: root
Password:
Linux chip 4.4.11-ntc #1 SMP Sat May 28 00:27:07 UTC 2016 armv7l

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@chip:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-3-configure-wifi-connection:f104f10590263b135a4ba1767b05f846&#34;&gt;Step 3: Configure WiFi connection&lt;/h4&gt;

&lt;p&gt;Following the instruction here &lt;a href=&#34;http://docs.getchip.com/chip.html#wifi-connection&#34;&gt;http://docs.getchip.com/chip.html#wifi-connection&lt;/a&gt; you can list all the available WiFi networks and then connect the C.H.I.P. to your preferred network.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi list
*  SSID         MODE   CHAN  RATE       SIGNAL  BARS  SECURITY
   HITRON-FEE0  Infra  11    54 Mbit/s  67      ▂▄▆_  WPA2
   WLAN-R46VFR  Infra  1     54 Mbit/s  65      ▂▄▆_  WPA2
   My ASUS      Infra  6     54 Mbit/s  64      ▂▄▆_  WPA2
   WLAN-718297  Infra  1     54 Mbit/s  59      ▂▄▆_  WPA2
   WLAN-MCQYPS  Infra  1     54 Mbit/s  30      ▂___  WPA2
   Telekom_FON  Infra  1     54 Mbit/s  27      ▂___  --

*  SSID  MODE  CHAN  RATE  SIGNAL  BARS  SECURITY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connect to the WiFi station with the SSID &lt;code&gt;mySSID&lt;/code&gt; and password &lt;code&gt;myPASSWORD&lt;/code&gt;, please insert you own SSID and PASSWORD. In this example I&amp;rsquo;m using the SSID &lt;code&gt;WLAN-R46VFR&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi connect &#39;WLAN-R46VFR&#39; password &#39;**********&#39; ifname wlan0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you are connected you can see the &amp;lsquo;*&amp;rsquo; in front of your connected WiFi network:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmcli device wifi list
*  SSID         MODE   CHAN  RATE       SIGNAL  BARS  SECURITY
   HITRON-FEE0  Infra  11    54 Mbit/s  67      ▂▄▆_  WPA2
   My ASUS      Infra  6     54 Mbit/s  64      ▂▄▆_  WPA2
   WLAN-718297  Infra  1     54 Mbit/s  59      ▂▄▆_  WPA2
   WLAN-MCQYPS  Infra  1     54 Mbit/s  30      ▂___  WPA2
   Telekom_FON  Infra  1     54 Mbit/s  27      ▂___  --
*  WLAN-R46VFR  Infra  1     54 Mbit/s  100     ▂▄▆█  WPA2

*  SSID  MODE  CHAN  RATE  SIGNAL  BARS  SECURITY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the C.H.I.P. should have got an IP address from the DHCP server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifconfig wlan0
wlan0     Link encap:Ethernet  HWaddr cc:79:cf:20:6d:d8
          inet addr:192.168.2.112  Bcast:192.168.2.255  Mask:255.255.255.0
          inet6 addr: fe80::ce79:cfff:fe20:6dd8/64 Scope:Link
          inet6 addr: 2003:86:8c18:1a37:ce79:cfff:fe20:6dd8/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:119 errors:0 dropped:1 overruns:0 frame:0
          TX packets:102 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:24656 (24.0 KiB)  TX bytes:16973 (16.5 KiB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re connected to the network and can access the internet and the C.H.I.P. can be reached from our Mac or Linux machine.&lt;/p&gt;

&lt;h4 id=&#34;step-4-configure-ssh-to-access-the-c-h-i-p:f104f10590263b135a4ba1767b05f846&#34;&gt;Step 4: Configure SSH to access the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;Here we have to use the same username &lt;code&gt;root&lt;/code&gt; and password &lt;code&gt;chip&lt;/code&gt; to login via SSH:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-add
ssh-keygen -R 192.168.2.112
ssh-copy-id root@192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we can login to the C.H.I.P. computer via SSH:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh root@192.168.2.112

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Thu Jan  1 00:32:25 1970
-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
root@chip:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-5-checking-the-os-and-linux-kernel-version:f104f10590263b135a4ba1767b05f846&#34;&gt;Step 5: Checking the OS and Linux kernel version&lt;/h4&gt;

&lt;p&gt;As a first step we&amp;rsquo;d like to check the current Linux kernel version and operating system.&lt;/p&gt;

&lt;p&gt;Kernel version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.11-ntc #1 SMP Sat May 28 00:27:07 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operating system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /etc/os-release
PRETTY_NAME=&amp;quot;Debian GNU/Linux 8 (jessie)&amp;quot;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;
VERSION_ID=&amp;quot;8&amp;quot;
VERSION=&amp;quot;8 (jessie)&amp;quot;
ID=debian
HOME_URL=&amp;quot;http://www.debian.org/&amp;quot;
SUPPORT_URL=&amp;quot;http://www.debian.org/support&amp;quot;
BUG_REPORT_URL=&amp;quot;https://bugs.debian.org/&amp;quot;
BUILD_ID=Wed Jun  1 05:34:36 UTC 2016
VARIANT=&amp;quot;Debian on C.H.I.P&amp;quot;
VARIANT_ID=SERVER
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-6-install-the-docker-engine-1-12-1-the-easy-way:f104f10590263b135a4ba1767b05f846&#34;&gt;Step 6: Install the Docker Engine 1.12.1 the easy way&lt;/h4&gt;

&lt;p&gt;In order to install Docker I&amp;rsquo;ve prepared a complete installation script which can be downloaded and executed in a single command line. I&amp;rsquo;ve you&amp;rsquo;re interested into the details you should check the script at &lt;a href=&#34;https://github.com/DieterReuter/arm-docker-fixes/blob/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install Docker
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of running the install script we&amp;rsquo;ll see some errors occurred and the start of the Docker Engine has failed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Errors were encountered while processing:
 docker-engine
E: Sub-process /usr/bin/dpkg returned an error code (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is OK for now as it just indicates the default Linux kernel isn&amp;rsquo;t able to run Docker on the C.H.I.P. and we have to build and install a custom Linux kernel which has all the necessary kernel settings for Docker enabled.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re interested in analyzing these errors in more detail you can run the command &lt;code&gt;systemctl status docker.service&lt;/code&gt; and you&amp;rsquo;ll get more detailed log messages from &lt;code&gt;systemd&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# systemctl status docker.service -l
● docker.service - Docker Application Container Engine
   Loaded: loaded (/etc/systemd/system/docker.service; enabled)
   Active: failed (Result: exit-code) since Sat 2016-09-03 13:20:49 UTC; 2min 23s ago
     Docs: https://docs.docker.com
 Main PID: 10840 (code=exited, status=1/FAILURE)

Sep 03 13:20:48 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:48.580271961Z&amp;quot; level=info msg=&amp;quot;libcontainerd: new containerd process, pid: 10848&amp;quot;
Sep 03 13:20:49 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:49.652832502Z&amp;quot; level=error msg=&amp;quot;&#39;overlay&#39; not found as a supported filesystem on this host. Please ensure kernel is new enough and has overlay support loaded.&amp;quot;
Sep 03 13:20:49 chip dockerd[10840]: time=&amp;quot;2016-09-03T13:20:49.656854332Z&amp;quot; level=fatal msg=&amp;quot;Error starting daemon: error initializing graphdriver: driver not supported&amp;quot;
Sep 03 13:20:49 chip systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE
Sep 03 13:20:49 chip systemd[1]: Failed to start Docker Application Container Engine.
Sep 03 13:20:49 chip systemd[1]: Unit docker.service entered failed state.
Sep 03 13:20:50 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:52 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:53 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
Sep 03 13:20:54 chip systemd[1]: [/etc/systemd/system/docker.service:24] Unknown lvalue &#39;Delegate&#39; in section &#39;Service&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-7-upgrade-the-linux-kernel-to-a-custom-built-version:f104f10590263b135a4ba1767b05f846&#34;&gt;Step 7: Upgrade the Linux kernel to a custom built version&lt;/h4&gt;

&lt;p&gt;In order to keep this tutorial short and easy to follow, I&amp;rsquo;d like to use an already prepared custom kernel which has nearly all the possible kernel modules and settings enabled to run the Docker Engine in an optimized way on the C.H.I.P. computer.&lt;/p&gt;

&lt;p&gt;Therefore we only have to install our new Linux kernel and have to reboot the system to activate it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install custom Linux Kernel and reboot
curl -sSL https://github.com/hypriot/binary-downloads/releases/download/chip-kernel-4.4.11/4.4.11-hypriotos.tar.bz2 | tar xvfj - -C /
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After rebooting we&amp;rsquo;re going to check the kernel version again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.11-hypriotos #1 SMP Mon Aug 29 19:18:49 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the Docker client version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker -v
Docker version 1.12.1, build 23cf638
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the Docker server version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker version
Client:
 Version:      1.12.1
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   23cf638
 Built:        Thu Aug 18 05:31:15 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.1
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   23cf638
 Built:        Thu Aug 18 05:31:15 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting the detailed informations about the Docker Engine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.12.1
Storage Driver: overlay
 Backing Filesystem: &amp;lt;unknown&amp;gt;
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: null host bridge overlay
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Security Options:
Kernel Version: 4.4.11-hypriotos
Operating System: Debian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 1
Total Memory: 491 MiB
Name: chip
ID: SSJ5:7OTQ:BCAZ:4MDL:VEW6:VKND:3J6W:UI3O:UTBB:7H5V:LQ4W:ABRP
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we could see, the latest Docker Engine v1.12.1 is now installed and is successfully running.&lt;/p&gt;

&lt;h4 id=&#34;step-8-run-your-first-docker-container-on-the-c-h-i-p:f104f10590263b135a4ba1767b05f846&#34;&gt;Step 8: Run your first Docker Container on the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;As a last step we&amp;rsquo;d like to start a first Docker container, a small web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
fec2773baaec570ba8b6e00296dfd11b4b4768d1b51e574d851968b9225b9d22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start your web browser and point it to the website from our Docker container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open http://192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/first-container-on-chip.jpg&#34; alt=&#34;first-container-on-chip&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Additional tip:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After installing some packages via &lt;code&gt;apt-get&lt;/code&gt; it&amp;rsquo;s a good idea to clean the APT cache from time to time and save disk space.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# apt-get clean
root@chip:~# df -h
Filesystem      Size  Used Avail Use% Mounted on
ubi0:rootfs     3.7G  373M  3.3G  11% /
devtmpfs        213M     0  213M   0% /dev
tmpfs           246M     0  246M   0% /dev/shm
tmpfs           246M  6.7M  239M   3% /run
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           246M     0  246M   0% /sys/fs/cgroup
tmpfs            50M     0   50M   0% /run/user/0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lessons-learned-tl-dr:f104f10590263b135a4ba1767b05f846&#34;&gt;Lessons learned - TL;DR&lt;/h3&gt;

&lt;p&gt;Currently the C.H.I.P. isn&amp;rsquo;t able to run Docker out-of-the-box, but it just needs to install a custom built Linux kernel to prepare this awesome ARM board to run Docker easily. And now we&amp;rsquo;re able to install the officially built Docker Engine from the Docker project&amp;rsquo;s APT repository.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/em&gt; &lt;BR&gt;
these are the only commands you need to install Docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install Docker
curl -sSL https://github.com/DieterReuter/arm-docker-fixes/raw/master/002-fix-install-docker-on-chip-computer/apply-fix-002.sh | bash

# install custom Linux Kernel and reboot
curl -sSL https://github.com/hypriot/binary-downloads/releases/download/chip-kernel-4.4.11/4.4.11-hypriotos.tar.bz2 | tar xvfj - -C /
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the best thing is, according to this &lt;a href=&#34;https://twitter.com/zerotri/status/771218366845497344&#34;&gt;tweet&lt;/a&gt;, the developers at &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt; have already started to include all the required kernel settings into the standard OS images. So we can expect that the Docker Engine can be installed in the future even without tweaking the Linux kernel.&lt;/p&gt;

&lt;h3 id=&#34;outlook:f104f10590263b135a4ba1767b05f846&#34;&gt;Outlook&lt;/h3&gt;

&lt;p&gt;As I told you at the beginning of this tutorial, these are just the basic steps for a normal user to install and use Docker on the C.H.I.P. computer. But if you&amp;rsquo;re interested in all the technical details behind the scene, how to check and analyze your Linux kernel and how to optimize it for running Docker efficiently, then please drop me a comment or tweet me and I&amp;rsquo;ll write even more about all the technical details so you can follow the path along on to an expert level too. With these skills you then should be able to install Docker on any Linux-based ARM device.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please:f104f10590263b135a4ba1767b05f846&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Releasing HypriotOS 1.0.0 &#34;Blackbeard&#34;</title>
      <link>https://blog.hypriot.com/post/releasing-HypriotOS-1-0/</link>
      <pubDate>Sun, 21 Aug 2016 12:30:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/releasing-HypriotOS-1-0/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Today we proudly present our 1.0.0 release of HypriotOS – a container OS that takes you from Zero to Docker within 5 Minutes only, on any device of the complete Raspberry Pi family.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For this major release we&amp;rsquo;ve taken an especially great deal of trouble. Out of the box, you not only get the breaking features of the Docker Engine 1.12.1 and the latest versions of Docker Compose and Docker Machine, but also many improvements that enhance the performance, reliability and usability.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/release-1-0/docker_pirate_650px_full-width.jpg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Therefore, this release illustrates very much how we work as Hypriot Team: We don&amp;rsquo;t stop after a &lt;code&gt;docker run&lt;/code&gt; just works on a Raspberry Pi. Meanwhile this has been possible for a long time. We only stop, when we went all the way down the rabbit whole and identified all adjusting screws of the operating system that can be used to improve the &lt;strong&gt;performance, reliability and usability&lt;/strong&gt; to run containers efficiently on ARM. Just to name a few examples: we include a Linux Kernel that is optimized for running Docker, we set all recommended configuration settings stated by Docker (and more), and provide tools that make the process of downloading HypriotOS and flashing it on a SD card super easy (see our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; and &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;As a result, you can be sure that we fine-tuned all adjusting screws to ensure we provide not some container OS, but an awesome one.&lt;/p&gt;

&lt;h2 id=&#34;feature-highlights-of-hypriotos:6302a5b7b7c942e4a845691a2c858ddf&#34;&gt;Feature Highlights of HypriotOS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Latest Docker Engine 1.12.1 with Swarm Mode&lt;/strong&gt; &lt;/br&gt;
You can get your hands on the new features of the freshly-baked Engine Docker 1.12.1 that is still warm. It includes the new Swarm Mode, which allows high availability of services in a multi-node cluster within just a few commands.
&lt;a href=&#34;https://blog.docker.com/2016/07/swarm-mode-on-a-raspberry-pi-cluster/&#34;&gt;See this short video how it works.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Support for the complete Raspberry Pi family&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS on each and every model of the Raspberry Pi family - we&amp;rsquo;re supporting Pi 1, 2, 3, Zero and even the Compute Module. Thus, all Raspberry Pi devices ever built are fully supported. This is possible through the dual kernels for ARMv6 and ARMv7 architecure we included on the SD card. Guess what: you can even switch your SD card from one Pi model to the other and it just works.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Easy flashing and configuration&lt;/strong&gt; &lt;/br&gt;
We improved our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;, which puts HypriotOS onto a SD card that is ready to boot from with a single command. After you flashed the SD card, you can store the settings of your environment, e.g. Wi-Fi connection parameters into a configuration file on the SD card &lt;code&gt;/boot/device-init.yaml&lt;/code&gt;. HypriotOS includes &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;, which makes your Raspberry Pi directly connecting to your Wi-Fi network after booting.
After booting, you can find the Raspberry Pi at your network with a simple &lt;code&gt;ping black-pearl.local&lt;/code&gt; – no more searching for IP addresses required thanks to the integrated Avahi service discovery.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enhanced security out of the box&lt;/strong&gt; &lt;/br&gt;
We think that security should be shipped out-of-the-box. We make HypriotOS more secure without you even noticing it. For instance, there is no built-in &amp;ldquo;root&amp;rdquo; user any more. Also, the default user &amp;ldquo;pirate&amp;rdquo; (password &amp;ldquo;hypriot&amp;rdquo;) is able to run Docker commands directly, which usually requires sudo rights. For an even better security, we strongly recommend to change the default user password and to restrict SSH access to pre-shared keys only with disabling SSH password authentication.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maximum performance out of the box&lt;/strong&gt; &lt;/br&gt;
As with security, running Docker with high performance comes out-of-the-box with HypriotOS. This includes faster booting times (15-17 sec.), an optimized file system to support more Inodes, minimal memory footprint and disk usage, and the reliable overlay storage driver for Docker by default.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Now 50% smaller in size, even smaller than Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
Even though HypriotOS 1.0.0 is fully packed with the complete and latest Docker tool set, it now comes at a size smaller than the tiniest version of Raspbian (&amp;ldquo;Raspbian Lite&amp;rdquo;). We achieved this mainly by reducing the cache&amp;rsquo;s footprint and leaving out some unused packages, so you won&amp;rsquo;t miss any features you are used to. You just need to download only 232 MB instead of 504 MB as before. With this improvements the minimum disk usage is reduced down to 600 MB.&lt;/p&gt;

&lt;p&gt;Please see all details in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases/tag/v1.0.0&#34;&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;quick-start:6302a5b7b7c942e4a845691a2c858ddf&#34;&gt;Quick start&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Download our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; and run&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Afterwards, put the SD card into the Raspberry Pi and power it. That&amp;rsquo;s all to get HypriotOS up and running!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps:6302a5b7b7c942e4a845691a2c858ddf&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;If you wanna connect to the Raspberry Pi, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with password &amp;ldquo;hypriot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you want the Raspberry Pi to connect directly to your Wi-Fi after boot, change the hostname of the Raspberry Pi and more, edit &lt;code&gt;/boot/device-init.yaml&lt;/code&gt; of the SD card and have a look at the &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;documentation of device-init&lt;/a&gt;. Alternatively, checkout the parameters of the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt; that also allows you to define configurations. Really, it&amp;rsquo;s just so damn easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n myHOSTNAME -s mySSID -p myWIFIPASSWORD https://github.com/hypriot/image-builder-rpi/releases/download/v1.0.0/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;feedback-please:6302a5b7b7c942e4a845691a2c858ddf&#34;&gt;Feedback, please&lt;/h2&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Your Hypriot Team:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Andreas &lt;a href=&#34;https://twitter.com/firecyberice&#34;&gt;@firecyberice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mathias &lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Building Docker 1.12 on a Raspberry Pi</title>
      <link>https://blog.hypriot.com/post/building-docker-directly-on-a-raspberry-pi/</link>
      <pubDate>Sun, 31 Jul 2016 15:24:03 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/building-docker-directly-on-a-raspberry-pi/</guid>
      <description>

&lt;p&gt;Over time many of our users have asked us exactly how we build the Docker Engine
and the associated Debian packages. For instance: they&amp;rsquo;d like to hack on some
 new features and need the latest software releases as soon as possible.&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;ll share all the details on building the latest Docker version - even on
a Raspberry Pi itself. Beware: while it&amp;rsquo;s not too complicated it will require
a large amount of time!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/build-docker-on-raspberrypi/docker-on-raspberrypi.jpg&#34; alt=&#34;Docker on Raspberry&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s get started. Follow me down the &lt;em&gt;Rabbit Hole&lt;/em&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;background:c68665982a08b259934801e30d513d89&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;The goal of this tutorial is to give you all the details you need to build the
Docker Engine yourself on your cool and fast $35 super-computer (the Raspberry Pi).&lt;/p&gt;

&lt;h3 id=&#34;prepare-the-build-environment:c68665982a08b259934801e30d513d89&#34;&gt;Prepare the Build Environment&lt;/h3&gt;

&lt;p&gt;Before we begin this arduous task have to prepare our build environment for what
will be a large, long-running workload.&lt;/p&gt;

&lt;h4 id=&#34;hardware-and-software-requirements:c68665982a08b259934801e30d513d89&#34;&gt;Hardware and Software Requirements&lt;/h4&gt;

&lt;p&gt;For building the Docker Engine in the recommended way we need a Linux computer which
already has a recent version of Docker running. Yeah, the Docker Engine will be build
inside of a Docker container to get a consistent and reproducible build environment.
As this requires some CPU power and disk space, I&amp;rsquo;m giving you here the minimal
specs for the hardware.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3 (a Pi 2 will work, but the build process will take even longer!)&lt;/li&gt;
&lt;li&gt;16 GByte SD card (8 GByte is not enough!)&lt;/li&gt;
&lt;li&gt;enabled swap space (1 GByte of memory is not sufficient!)&lt;/li&gt;
&lt;li&gt;Docker Engine 1.11&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;installing-the-build-environment:c68665982a08b259934801e30d513d89&#34;&gt;Installing the Build Environment&lt;/h4&gt;

&lt;p&gt;As you will see, setting up the build environment is damn easy, because we&amp;rsquo;ll just
use the latest release of HypriotOS which has the required Docker Engine 1.11.1
already pre-installed. These steps here are done on OS X, on a Linux or Windows
box it&amp;rsquo;s a little bit different.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step 1:&lt;/em&gt; install HypriotOS 0.8.2 on a SD card&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ flash https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.2/hypriotos-rpi-v0.8.2.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now boot the Raspberry Pi 3 with the newly flashed SD card.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step 2:&lt;/em&gt; deploy SSH keys&lt;/p&gt;

&lt;p&gt;(Note: login credentials are username=pirate, password=hypriot)&lt;/p&gt;

&lt;p&gt;First, wait until the Raspberry Pi is booted up and is visible on the network
to gather it&amp;rsquo;s IP address.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping -c 1 black-pearl.local
PING black-pearl.local (192.168.2.113): 56 data bytes
64 bytes from 192.168.2.113: icmp_seq=0 ttl=64 time=5.697 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, deploy your standard SSH keys to the Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-add
$ ssh-keygen -R 192.168.2.113
$ ssh-copy-id pirate@192.168.2.113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re able to login into the Raspberry Pi without using a password.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pirate@192.168.2.113

$ uname -a
Linux black-pearl 4.4.15-hypriotos-v7+ #1 SMP PREEMPT Mon Jul 25 08:46:52 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Step 3:&lt;/em&gt; install some build dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install -y make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Step 4:&lt;/em&gt; using a swap file&lt;/p&gt;

&lt;p&gt;This will create and use a default 2x 1GByte swap file at /var/swap.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install -y dphys-swapfile
$ ls -alh /var/swap
-rw------- 1 root root 1.8G Jul 30 17:58 /var/swap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we need a larger swap file, we could edit the config file &lt;code&gt;/etc/dphys-swapfile&lt;/code&gt;,
but for our use case the default 1.8 GByte swap file is sufficient.&lt;/p&gt;

&lt;h3 id=&#34;clone-the-docker-repo:c68665982a08b259934801e30d513d89&#34;&gt;Clone the Docker repo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/docker/docker.git
$ cd docker
$ git checkout v1.12.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we&amp;rsquo;re using a tagged release for Docker to build this exact version.&lt;/p&gt;

&lt;h3 id=&#34;how-to-apply-some-extra-pull-requests:c68665982a08b259934801e30d513d89&#34;&gt;How to apply some extra Pull Requests&lt;/h3&gt;

&lt;p&gt;Just to be honest, right now the build process for Docker v1.12.0 will fail on ARM.
This is a known issue and will be fixed hopefully soon. But luckily there is already
a &lt;a href=&#34;https://github.com/docker/docker/pull/25192&#34;&gt;pull request&lt;/a&gt;
which enables us to build the Docker .deb packages. This gives me
the change to explain how you can easily apply a PR on top of a release version.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s cherry pick this specific pull request.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin pull/25192/head:fix-manpages-on-arm
$ git cherry-pick fix-manpages-on-arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally let&amp;rsquo;s check if everything is OK with the git history.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;commit e15322b4fcb173674fd62a329a51b0756f02d503
Author: Daniel Nephin &amp;lt;dnephin@docker.com&amp;gt;
Date:   Thu Jul 28 14:53:08 2016 -0400

    Fix the man/Dockerfile for arm

    Signed-off-by: Daniel Nephin &amp;lt;dnephin@docker.com&amp;gt;

commit 8eab29edd820017901796eb60d4bea28d760f16f
Author: Tibor Vass &amp;lt;tibor@docker.com&amp;gt;
Date:   Wed Jul 27 16:35:10 2016 -0700

    Bump VERSION to v1.12.0

    Signed-off-by: Tibor Vass &amp;lt;tibor@docker.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the second last commit is the release commit for the official v1.12.0
version of the Docker Engine. The last commit is from the applied PR.&lt;/p&gt;

&lt;h3 id=&#34;run-the-build:c68665982a08b259934801e30d513d89&#34;&gt;Run the build&lt;/h3&gt;

&lt;p&gt;And here comes the magic: we&amp;rsquo;ll start the build process and then have to wait
for a really long time for it to finish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time make deb

...
real	350m48.228s
user	0m22.140s
sys	0m4.870s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete build process takes almost 6 hours on a fast Raspberry Pi 3, but finally
we&amp;rsquo;ll get the Docker Engine v1.12.0 build for a few different ARM operating systems.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -al ~/docker/bundles/1.12.0/build-deb/*/*.deb
-rw-r--r-- 1 root root 15933554 Jul 31 10:46 /home/pirate/docker/bundles/1.12.0/build-deb/debian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb
-rw-r--r-- 1 root root 15945462 Jul 31 12:28 /home/pirate/docker/bundles/1.12.0/build-deb/raspbian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb
-rw-r--r-- 1 root root 15915910 Jul 31 13:40 /home/pirate/docker/bundles/1.12.0/build-deb/ubuntu-trusty/docker-engine_1.12.0-0~trusty_armhf.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install the Docker Engine on our Raspberry Pi&amp;rsquo;s, we just pick&lt;/p&gt;

&lt;p&gt;&lt;code&gt;raspbian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the install process on HypriotOS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get purge -y docker-hypriot
$ sudo dpkg -i docker-engine_1.12.0-0~jessie_armhf.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we do have the latest release version v1.12.0 of the Docker Engine running
on our Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker version
Client:
 Version:      1.12.0
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   e15322b4f
 Built:        Sun Jul 31 11:41:45 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.0
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   e15322b4f
 Built:        Sun Jul 31 11:41:45 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;what-other-build-options-can-be-used:c68665982a08b259934801e30d513d89&#34;&gt;What other build options can be used?&lt;/h3&gt;

&lt;p&gt;Some Raspberry Pi owners such as &lt;a href=&#34;http://blog.alexellis.io/&#34;&gt;Alex Ellis&lt;/a&gt; run Docker on &lt;a href=&#34;http://archlinuxarm.org&#34;&gt;Arch Linux for ARM (ALARM)&lt;/a&gt; or other compatible Linux distributions. For most non-Debian
distributions it makes sense to build a static binary with the below command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/docker
$ time make binary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will find the binary files in the &lt;code&gt;bundles&lt;/code&gt; folder and can then move then to &lt;code&gt;/usr/bin&lt;/code&gt; or &lt;code&gt;/usr/local/bin&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;lessons-learned:c68665982a08b259934801e30d513d89&#34;&gt;Lessons learned&lt;/h3&gt;

&lt;p&gt;With the right Raspberry Pi OS and the Docker Engine already pre-installed, it&amp;rsquo;s
pretty easy and straight forward to build the next version of the Docker Engine
directly and natively on a standard Raspberry Pi.&lt;/p&gt;

&lt;p&gt;I strongly recommend to use the faster Raspberry Pi 3 and a SD card of at least
16 GByte, with a smaller SD card the build will crash after some hours and you
have to start all over again!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please:c68665982a08b259934801e30d513d89&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Edits by &lt;a href=&#34;http://twitter.com/alexellisuk&#34;&gt;Alex Ellis&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swarm Machines or Having fun with Docker Machine and the new Docker Swarm orchestration</title>
      <link>https://blog.hypriot.com/post/swarm-machines-or-having-fun-with-docker-machine-and-the-new-docker-swarm-orchestration/</link>
      <pubDate>Tue, 21 Jun 2016 13:49:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/swarm-machines-or-having-fun-with-docker-machine-and-the-new-docker-swarm-orchestration/</guid>
      <description>

&lt;p&gt;In the last couple of days there were some users on our Gitter channel having problems accessing their Raspberry Pi&amp;rsquo;s with HypriotOS via Docker Machine.
As we have not yet written how that works I thought I would do a short blog post on how to use Docker Machine with HypriotOS.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not all. Yesterday when I watched the DockerCon Keynote Livestream of the new Docker orchestration I wondered how Docker Machine and the new orchestration would work together.&lt;/p&gt;

&lt;p&gt;So just for the fun of it I decided I will explore that a bit, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/docker-machine/swarm_machines.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;

&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/thewakingdragon/&#34;&gt;Brent M&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;I am using the latest Docker4Mac with Docker on my notebook and three Raspberry Pi&amp;rsquo;s with HypriotOS 0.8 as hosts for my remote Docker Engines.&lt;/p&gt;

&lt;p&gt;The Docker version on the notebook and on the Pi&amp;rsquo;s is 1.12 RC1. Having the lastest Docker 1.12 is not necessary for the part about Docker Machine, but it is for the part about the new Docker orchestration.&lt;/p&gt;

&lt;h2 id=&#34;docker-machine:85b1180b5e32a76ced09e55169dd699d&#34;&gt;Docker Machine&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt; is used to control remote Docker-Engines as if they were locally installed.&lt;/p&gt;

&lt;p&gt;That is very convenient in many cases, for instance if you have set up a Docker host with the help of Amazon AWS or Microsoft Azure and you can access it only remotely.
In that case you do not have to establish a SSH connection first in order to work with a specific Docker Engine.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not all - Docker Machine also helps if there is no Docker-Engine present on a remote host.&lt;/p&gt;

&lt;p&gt;With the help of Docker Machine it is very easy to install and configure a new Docker Engine.&lt;/p&gt;

&lt;p&gt;Both in case of an existing or a new Docker Engine Docker Machine reconfigures the Engine to make it availabe via a HTTP network socket.
To ensure that only authorized clients can connect to the remote Docker Engine Docker Machine also sets up everything that is needed for &lt;a href=&#34;https://docs.docker.com/engine/security/https/&#34;&gt;securing the communication with TLS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To remotely manage my Pi&amp;rsquo;s with Docker Machine I first need to copy my SSH public key to the remote host.
If you do not have a SSH key pair you need to &lt;a href=&#34;https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#generating-a-new-ssh-key&#34;&gt;generate one first&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Transfering your public key to a remote host is easily done with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-copy-id pirate@pi3.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command configures the remote host &amp;lsquo;pi3.local&amp;rsquo; in a way that I can access this host via SSH with my default SSH key (~/.ssh/id_rsa).&lt;/p&gt;

&lt;p&gt;We can test this now by executing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pirate@pi3.local ls -lah
total 32K
drwxr-xr-x 3 pirate pirate 4.0K Jun 21 12:01 .
drwxr-xr-x 3 root   root   4.0K May 17 22:43 ..
-rw------- 1 pirate pirate  116 Jun 21 12:01 .bash_history
-rw-r--r-- 1 pirate pirate  220 Oct 18  2014 .bash_logout
-rw-r--r-- 1 pirate pirate 2.5K May 17 22:42 .bash_prompt
-rw-r--r-- 1 pirate pirate  570 May 17 22:42 .bashrc
-rw-r--r-- 1 pirate pirate  314 May 17 22:42 .profile
drwx------ 2 pirate pirate 4.0K Jun 21 12:09 .ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command establishes a SSH connection to the host &amp;lsquo;pi3.local&amp;rsquo; and executes &amp;lsquo;ls -lah&amp;rsquo;. If you can see a similar output everything is OK.&lt;/p&gt;

&lt;p&gt;Next we need to add our &amp;lsquo;pi3.local&amp;rsquo; host to the list of hosts that are managed by Docker Machine.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we already have some existing hosts that are managed by Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine ls
NAME   ACTIVE   DRIVER    STATE     URL                          SWARM   DOCKER        ERRORS
pi1    -        generic   Running   tcp://192.168.178.171:2376           v1.12.0-rc1
pi2    -        generic   Running   tcp://192.168.178.24:2376            v1.12.0-rc1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And indeed we have two hosts that are already managed by Docker Machine.&lt;/p&gt;

&lt;p&gt;Adding another one is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine create --driver generic --generic-ip-address=192.168.178.59 --generic-ssh-key=/Users/govindaf/.ssh/id_rsa --generic-ssh-user=pirate --engine-storage-driver=overlay pi3
Running pre-create checks...
Creating machine...
(pi3) Importing SSH key...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with debian...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env pi3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output looks good. Let&amp;rsquo;s dissect this command a bit to understand what it does.&lt;/p&gt;

&lt;p&gt;We are using the &amp;lsquo;create&amp;rsquo; subcommand of Docker Machine to create a new host that is managed by Docker Machine.
We are also using the &amp;lsquo;generic&amp;rsquo; driver that allows us to communicate with our Raspberry Pi&amp;rsquo;s via SSH.&lt;/p&gt;

&lt;p&gt;For this we need to tell Docker Machine some SSH connection details like the IP address of our target host, the SSH user and the location of our private SSH key.&lt;/p&gt;

&lt;p&gt;The IP address of our Pi can be easily obtained by running&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping -c1 pi3.local
PING pi3.local (192.168.178.59): 56 data bytes
64 bytes from 192.168.178.59: icmp_seq=0 ttl=64 time=1.926 ms

--- pi3.local ping statistics ---
1 packets transmitted, 1 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 1.926/1.926/1.926/0.000 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is important that we provide the absolute path to our private SSH key with the option &amp;lsquo;generic-ssh-key&amp;rsquo;. A relative path did not work for me.&lt;/p&gt;

&lt;p&gt;Furthermore we need to tell Docker Machine which user it should use for the SSH connection.
The default here is the &amp;lsquo;root&amp;rsquo; user. With HypriotOS we can only use an unprivileged user which is why we need to provide the &amp;lsquo;generic-ssh-user&amp;rsquo; option.&lt;/p&gt;

&lt;p&gt;Last but no least we need to tell Machine to use the &amp;lsquo;overlay&amp;rsquo; filesystem for the configuration of the Docker Engine which is the default with HypriotOS.
Without this option Docker Machine would try to use &amp;lsquo;aufs&amp;rsquo; which would fail miserably.&lt;/p&gt;

&lt;p&gt;Alright, let&amp;rsquo;s see if we now have a third host under our Machine control:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine ls
NAME   ACTIVE   DRIVER    STATE     URL                          SWARM   DOCKER        ERRORS
pi1    -        generic   Running   tcp://192.168.178.171:2376           v1.12.0-rc1
pi3    -        generic   Running   tcp://192.168.178.59:2376            v1.12.0-rc1
pi2    -        generic   Running   tcp://192.168.178.24:2376            v1.12.0-rc1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yeah - we do.&lt;/p&gt;

&lt;p&gt;Sometimes you might get SSH timeout errors when setting up another host with Docker-Machine.
If this is the case make sure you did not forget to set up your SSH public key with the remote host first.&lt;/p&gt;

&lt;p&gt;Sometimes when Docker Machine tries to add a new host it happens that it is stuck halfway with an error.
In those cases the best course of action is often to remove the host first and add it again later.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine rm pi3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s assume all went well and we now have a list of host under remote control. How do you work with those now?&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s were the Docker Machine &amp;lsquo;env&amp;rsquo; subcommand comes into play.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine env pi3
export DOCKER_TLS_VERIFY=&amp;quot;1&amp;quot;
export DOCKER_HOST=&amp;quot;tcp://192.168.178.59:2376&amp;quot;
export DOCKER_CERT_PATH=&amp;quot;/Users/govindaf/.docker/machine/machines/pi3&amp;quot;
export DOCKER_MACHINE_NAME=&amp;quot;pi3&amp;quot;
# Run this command to configure your shell:
# eval $(docker-machine env pi3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The env command outputs a bunch of environment variables that control to which Docker instance our local Docker binary is talking to.
Per default the &amp;lsquo;docker&amp;rsquo; command only talks to our local Docker Engine - for instance on our notebook - but by exporting those environment variables this changes fundamentally.&lt;/p&gt;

&lt;p&gt;The easiest way to export the necessary variables is by running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything I do with the &amp;lsquo;docker&amp;rsquo; command runs against the Docker Engine of my &amp;lsquo;pi3&amp;rsquo; host.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check if that is true:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 27
Server Version: 1.12.0-rc1
Storage Driver: overlay
 Backing Filesystem: extfs
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge null host overlay
Swarm: inactive
Runtimes: default
Default Runtime: default
Security Options:
Kernel Version: 4.4.10-hypriotos-v7+
Operating System: Raspbian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 4
Total Memory: 925.4 MiB
Name: pi3
ID: 5DYT:MHTS:4JQK:KNGB:FYZI:EFG4:YIPZ:2WJR:VW5Y:KLPJ:WXCX:S3CG
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
WARNING: No cpuset support
Labels:
 provider=generic
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see with the &amp;lsquo;Name&amp;rsquo; attribute, we are really working on host &amp;lsquo;pi3&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Changing to another host is also easy.&lt;/p&gt;

&lt;p&gt;Just repeat the command from above and replace the hostname with another:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;docker-machine-and-docker-swarm-mode:85b1180b5e32a76ced09e55169dd699d&#34;&gt;Docker Machine and Docker Swarm Mode&lt;/h2&gt;

&lt;p&gt;In the past Docker Machine allowed to set up a Docker Swarm cluster with a &lt;a href=&#34;https://docs.docker.com/machine/reference/create/&#34;&gt;number of options&lt;/a&gt; for the &amp;lsquo;create&amp;rsquo; subcommand.&lt;/p&gt;

&lt;p&gt;With Docker 1.12 we now how a much more powerful version of Swarm that is directly integrated into Docker.
This feature is called Docker Swarm Mode and you can find some inital documentation about it &lt;a href=&#34;https://docs.docker.com/engine/swarm/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I could not find any specifics on how to use it together with Docker Machine. So there might be better ways of how to deal with it than what I am going to show you now.&lt;/p&gt;

&lt;p&gt;Assuming we have three fresh hosts that are managed by Docker Machine, we need to tell Docker to initialize a new Swarm cluster first.&lt;/p&gt;

&lt;p&gt;We can execute the necessary command on any of our hosts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi1)
$ docker swarm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command create a Docker Swarm cluster with one node. This first node automatically becomes a Swarm Manager Node.&lt;/p&gt;

&lt;p&gt;The output of &amp;lsquo;docker info&amp;rsquo; shows us what role our current Docker Engine plays in regard to Swarm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker info
...
Swarm: active
 NodeID: efyap0lxrttld19djs3ygtuac
 IsManager: Yes
 Managers: 1
 Nodes: 1
 CACertHash: sha256:9a29dafb3f6f600b64e8ec7a421fd6386f938de623a3a479ca56229b22a6b680
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also another command that is able to show us which nodes are part of our Swarm cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker node ls
ID                           NAME  MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS
efyap0lxrttld19djs3ygtuac *  pi1   Accepted    Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK. Time to add two more nodes.&lt;/p&gt;

&lt;p&gt;First we need to switch our Docker environment with Docker Machine. Afterwards we join the existing Swarm cluster with the next node.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi2)
$ docker swarm join pi1:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks promising. Let&amp;rsquo;s see what our &amp;lsquo;docker node ls&amp;rsquo; command has to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker node ls
Error response from daemon: this node is not participating as a Swarm manager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s that?&lt;/p&gt;

&lt;p&gt;Obviously we are only able to use the &amp;lsquo;node&amp;rsquo; subcommand from a Swarm Manager node and not from a Swarm Worker node.
So ignoring this for the moment let&amp;rsquo;s add the last node, too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi3)
$ docker swarm join pi1:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s switch back to our original Swarm Manager node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi1)
$ docker node ls
ID                           NAME  MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS
3cgg9qfo6nk77zisgrst1333n    pi2   Accepted    Ready   Active
6lezwd8vplgcdmxyhswbc1cvp    pi3   Accepted    Ready   Active
efyap0lxrttld19djs3ygtuac *  pi1   Accepted    Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we have sucessfully set up a Docker Swarm Cluster with three nodes.&lt;/p&gt;

&lt;p&gt;With the help of Docker Machine this was really easy and straightforward as we only had to switch our Docker environment to work on individual nodes.&lt;/p&gt;

&lt;p&gt;So as a last treat for you and to be able to show another screenshot let&amp;rsquo;s start a small webserver in our Swarm cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker service create --name hypriot-httpd -p 8080:80 --replicas 6 hypriot/rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command creates a Docker Swarm service that consists of six running httpd containers that are spread equally across the three nodes of our Swarm cluster.&lt;/p&gt;

&lt;p&gt;Seeing is believing so let&amp;rsquo;s check this again by using the &amp;lsquo;docker service task&amp;rsquo; sub sub command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker service tasks hypriot-httpd
ID                         NAME             SERVICE        IMAGE                      LAST STATE         DESIRED STATE  NODE
14ywlwfix019b95oizce0hgd2  hypriot-httpd.1  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi1
60k55m336zq04rke696m848w1  hypriot-httpd.2  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi3
55sl8zwi1v8om3pvtb0zscf8d  hypriot-httpd.3  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi2
105gbhovh5p3zmwpqaeg3hprd  hypriot-httpd.4  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi3
8her9l13z78g9mjdrkovs9d46  hypriot-httpd.5  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi2
5xwwxuvbwsr7pmomg91cnf08y  hypriot-httpd.6  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On a Mac we now can open the website that is served by this service with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ open http://$(docker-machine ip pi1):8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are then rewarded with this neat little website:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/docker-machine/hypriot-http.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Hope this tour was fun and gave you a feeling for the power that comes with Docker Machine.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>More Microservices Bliss with Docker 1.12 and Swarm only</title>
      <link>https://blog.hypriot.com/post/more-microservice-bliss-with-docker-1-12/</link>
      <pubDate>Mon, 20 Jun 2016 21:49:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/more-microservice-bliss-with-docker-1-12/</guid>
      <description>&lt;p&gt;A couple of days ago I wrote a &lt;a href=&#34;https://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/&#34;&gt;blog post&lt;/a&gt; about how easy it is to get a microservice application up and running with Docker and a HTTP proxy called Traefik.
I explained how awesome Traefik is because it makes complex setups with HAProxy, Registrator, Consul, etc. a thing of the past.&lt;/p&gt;

&lt;p&gt;I really thought it couldn&amp;rsquo;t get much easier. Oh boy - was I wrong!&lt;/p&gt;

&lt;p&gt;Today as part of the Docker opening keynote Docker demostrated an evolution of Docker Swarm that simplifies this whole scenario even more.
It makes setting up a Docker Swarm Cluster a really simple and straigtforward task.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how this new thing works&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/more-microservices/swarm.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;

&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/thewakingdragon/&#34;&gt;Brent M&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;If you remember the example from my last post - it consisted of a microservice application made of a frontend and a couple of backend services.
The frontend was a Traefik HTTP proxy that routed the requests to the backend services.
And the backend for the sake of simplicity was just a simple Go-based HTTP webserver that returned the ID of the containers it was running within.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/traefik/microsservice_example_end.jpg&#34; alt=&#34;Traffic&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The new Docker Swarm removes the need for a separate HTTP proxy in front of our application containers.
The architecture from above is now slimmed down considerably and looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/more-microservices/architecture_with_swarm.jpg&#34; alt=&#34;With Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Less moving parts - that is great!&lt;/p&gt;

&lt;p&gt;Still we get built-in loadbalancing to our backend services. We even can access those services from every node in our cluster.
Docker Swarm has a kind of built-in mesh routing integrated that takes care of routing requests to the appropriate backend containers.&lt;/p&gt;

&lt;p&gt;With all the new functionality one could assume that setting up a Docker Swarm cluster got even more complicated than before.
But to the contrary - it got much easier - and that by leaps and bounds.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t believe me? Just follow along.&lt;/p&gt;

&lt;p&gt;As you might have guessed, we are doing this on Raspberry Pi cluster again.
I am using a homegrown version of Docker 1.12 that I installed on my Raspberry Pi.
Hopefully when Docker 1.12 is not a release candidate anymore we will have a version for you ready, too.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what we have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker version
Client:
 Version:      1.12.0-rc1
 API version:  1.24
 Go version:   go1.6.2
 Git commit:   1f136c1-unsupported
 Built:        Wed Jun 15 15:35:51 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.0-rc1
 API version:  1.24
 Go version:   go1.6.2
 Git commit:   1f136c1-unsupported
 Built:        Wed Jun 15 15:35:51 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great. Docker 1.12 RC1 is ready. We should have everything we need to get started.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find out if we have same new features hidden in our Docker CLI.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker
Usage: docker [OPTIONS] COMMAND [arg...]
       docker [ --help | -v | --version ]

A self-sufficient runtime for containers.
    ...
    service   Manage Docker services
    ...
    stats     Display a live stream of container(s) resource usage statistics
    ...
    swarm     Manage Docker Swarm
    ...
    update    Update configuration of one or more containers

Run &#39;docker COMMAND --help&#39; for more information on a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I removed the lines of the command output that have not changed compared to the previous release. What remains though is still pretty interesting&amp;hellip;&lt;/p&gt;

&lt;p&gt;We now seem to have a &amp;lsquo;docker swarm&amp;rsquo; command.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what it is all about&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker swarm

Usage:  docker swarm COMMAND

Manage Docker Swarm

Options:
      --help   Print usage

Commands:
  init        Initialize a Swarm.
  join        Join a Swarm as a node and/or manager.
  update      update the Swarm.
  leave       Leave a Swarm.
  inspect     Inspect the Swarm

Run &#39;docker swarm COMMAND --help&#39; for more information on a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &amp;lsquo;Initialize a Swarm.&amp;rsquo; seems to be exactly what we want. Let&amp;rsquo;s start with this one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker swarm init
Swarm initialized: current node (1njlvzi9rk2syv3xojw217o0g) is now a manager.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have a Swarm manger node running it is time to add some more nodes to the cluster.&lt;br /&gt;
And it is really simple as well.&lt;/p&gt;

&lt;p&gt;Just go to another node of your cluster and execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 $ docker swarm join pi6:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this command we basically just tell new nodes that they should join the Swarm Manager node on which we created the inital Swarm cluster.
In the background Docker Swarm now does some work for us.&lt;/p&gt;

&lt;p&gt;For instance it sets up encrypted communication channels between the cluster nodes. We do not need to manage TLS certificates on our own.&lt;/p&gt;

&lt;p&gt;Everybody who knows how involved it could be to get a Docker Swarm cluster up running in the past should realize how easy it is now.&lt;/p&gt;

&lt;p&gt;Still we are not yet finished.&lt;/p&gt;

&lt;p&gt;A &amp;lsquo;docker info&amp;rsquo; on our Swarm Manager node reveals some interesting tidbits.
Again I removed the uninteresting parts for brevity.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker info
...
Swarm: active
 NodeID: 1njlvzi9rk2syv3xojw217o0g
 IsManager: Yes
 Managers: 1
 Nodes: 2
 CACertHash: sha256:de4e2bff3b63700aad01df97bbe0397f131aabed5fabb7732283f044472323fc
...
Kernel Version: 4.4.10-hypriotos-v7+
Operating System: Raspbian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 4
Total Memory: 925.4 MiB
Name: pi6
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we now have a new &amp;lsquo;Swarm&amp;rsquo; part in the &amp;lsquo;docker info&amp;rsquo; output.
It tells us that our current node is a Swarm Manager node and that the cluster is composed of two cluster nodes in total.&lt;/p&gt;

&lt;p&gt;On our second node it looks a bit different as it is not a Manager node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Swarm: active
 NodeID: 3fmwt4taurwxczr2icboojz8g
 IsManager: No
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Until now we just have an interesting, but still very empty Swarm cluster.
Let&amp;rsquo;s change that.&lt;/p&gt;

&lt;p&gt;Before we start let me introduce you to the concept of a service that is also new abstraction with Docker 1.12.
You might have seen a hint of it already in the output of the Docker command above.
Yes, it is the &amp;lsquo;docker service&amp;rsquo; command that I am talking about.
A Docker service is basically just a bit of software running in a container that offers its &amp;lsquo;service&amp;rsquo; to the outside world and runs on a Swarm cluster.&lt;/p&gt;

&lt;p&gt;Such a service can consist of just one container or of multiple containers.
In the latter case we get high availability and/or loadbalancing for our service out of the box.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create such a service based on our &amp;lsquo;whoami&amp;rsquo; image from my last blog post.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service create --name whoami -p 80:8000 hypriot/rpi-whoami
buy0q65lw7nshm76kvy5imxk3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of the &amp;lsquo;docker swarm ls&amp;rsquo; command we can check the status of our new service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service ls
ID            NAME    SCALE  IMAGE               COMMAND
buy0q65lw7ns  whoami  1      hypriot/rpi-whoami
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check if we can request the index page from our whoami container by sending I http request via curl to the ip of eth0 network interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ curl http://192.168.178.24
I&#39;m 1b6df814c654
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is working. Awesome!&lt;/p&gt;

&lt;p&gt;Those who followed along with keen eyes will have noticed the &amp;lsquo;SCALE&amp;rsquo; part in the header line of the &amp;lsquo;docker swarm ls&amp;rsquo; command.
It seems as we can scale our service somehow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service scale whoami=5
whoami scaled to 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK. Let&amp;rsquo;s check what we have now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service ls
ID            NAME    SCALE  IMAGE               COMMAND
buy0q65lw7ns  whoami  5      hypriot/rpi-whoami

root@pi6 $ for i in {1..5}; do curl http://192.168.178.24; done
I&#39;m 8db1657e8517
I&#39;m e1863a2be88d
I&#39;m 1b6df814c654
I&#39;m 8db1657e8517
I&#39;m e1863a2be88d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty neat.&lt;/p&gt;

&lt;p&gt;But this is not just way more simple than the old Swarm, it also feels much more snappier and faster when executing commands.
And remember I am working on Raspberry Pi&amp;rsquo;s and not on a beefy server like you would propably work on.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how this looks from the perspective of an individual Docker engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
e1863a2be88d        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             2 minutes ago       Up 2 minutes        8000/tcp            whoami.4.0lg12zndbal72exqe08r9wvpg
8db1657e8517        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             2 minutes ago       Up 2 minutes        8000/tcp            whoami.5.5z6mvsrdy73m5w24icgsqc8i2
1b6df814c654        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.1.bg4qlpiye6h6uxyf8cmkwuh52
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see from the five containers that were started three reside on &amp;lsquo;pi6&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find the rest:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
db411a119c0a        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             6 minutes ago       Up 6 minutes        8000/tcp            whoami.2.2tf7yhmx9haol7e2b7xib2emj
0a4bf32fa9c4        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             6 minutes ago       Up 6 minutes        8000/tcp            whoami.3.2r6mm091c2ybr0f9jz4qaxw9k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what happens when I just leave the Swarm cluster on &amp;lsquo;pi1&amp;rsquo;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 docker swarm leave
Node left the default swarm.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I should be two containers short, right?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what we have on our remaining node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
58620e3d533c        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             46 seconds ago      Up 43 seconds       8000/tcp            whoami.2.cgc4e2ixulc2f3ehr4laoursg
acc9b523f434        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             46 seconds ago      Up 43 seconds       8000/tcp            whoami.3.67bhlo3nwgehthi3bg5bfdzue
e1863a2be88d        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.4.0lg12zndbal72exqe08r9wvpg
8db1657e8517        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.5.5z6mvsrdy73m5w24icgsqc8i2
1b6df814c654        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             15 minutes ago      Up 14 minutes       8000/tcp            whoami.1.bg4qlpiye6h6uxyf8cmkwuh52
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we witnessed here is the same what would have happened if we just had a failing &amp;lsquo;pi1&amp;rsquo; node.
All the containers that were running on node &amp;lsquo;pi1&amp;rsquo; were migrated to the remaining cluster nodes automatically.
That&amp;rsquo;s pretty impressive.&lt;/p&gt;

&lt;p&gt;So to recap what we just did:&lt;br /&gt;
We created a small dynamic microservice applications with just the plain Docker.
Docker Swarm is now integrated into the Docker-Engine instead of being a separate piece of software.
In many cases this makes a separate proxy for the backend services of your application obsolete. No more nginx, HAProxy or Traefik. Sorry to see you go&amp;hellip;&lt;/p&gt;

&lt;p&gt;Despite having fewer moving parts we now have additional load balancing and high availability features built-in.
I am really looking forward to find out what else there is in store with the new Docker Swarm and how it works together with Docker Compose.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s a story for another day&amp;hellip;&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker was well received at Germany&#39;s biggest Raspberry Pi Jam</title>
      <link>https://blog.hypriot.com/post/docker-was-well-received-at-piandmore/</link>
      <pubDate>Mon, 13 Jun 2016 09:21:00 +0000</pubDate>
      
      <guid>https://blog.hypriot.com/post/docker-was-well-received-at-piandmore/</guid>
      <description>

&lt;p&gt;Last Saturday Germany&amp;rsquo;s biggest Raspberry Pi community event - &lt;a href=&#34;http://piandmore.de/en&#34;&gt;the PiAndMore&lt;/a&gt; - took place for the 9th time.&lt;/p&gt;

&lt;p&gt;In cooperation with the University of Trier the organizers were able to provide a broad range of activities.
There were talks, workshops and many interesting tinker projects at display to delight even the most demanding maker heart.&lt;/p&gt;

&lt;p&gt;It comes as no suprise that Docker was a hot topic at the PiAndMore conference, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/piandmore/piandmore_loves_docker.jpg&#34; alt=&#34;PiAndMore&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;docker-and-the-raspberry-pi-a-dream-team:ce44e480ae6cb7c6d49829357f2a0d42&#34;&gt;Docker and the Raspberry Pi - a dream team?&lt;/h2&gt;

&lt;p&gt;The Docker Pirates were invited to give a talk about &lt;a href=&#34;http://www.slideshare.net/GovindaFichtner/docker-and-raspberry-pi-a-dream-team&#34;&gt;Docker on the Raspberry Pi&lt;/a&gt;.&lt;br /&gt;
Despite being one of the first talks at nine o&amp;rsquo;clock in the morning it was well visited.&lt;/p&gt;

&lt;p&gt;After some inital technical problems with the local power supply, network and beamer (yeah - all three!) the talk went well.&lt;/p&gt;

&lt;p&gt;I started by giving a short introduction to Docker and finished with a live demo on our 5 node Pico-Cluster.
Starting with some basic Docker Fu the demo soon gathered speed and I showed how to use Docker Compose and Swarm to get a
two tiered microservice architecture up and running in less then 5 minutes.&lt;/p&gt;

&lt;p&gt;Here is a recording of the talk made by &lt;a href=&#34;https://call-a-tux.de/&#34;&gt;Call-a-Tux&lt;/a&gt;:
&lt;iframe id=&#34;ytplayer&#34; type=&#34;text/html&#34; width=&#34;1000&#34; height=&#34;560&#34; src=&#34;http://www.youtube.com/embed/9xAkILSdlxE&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;docker-workshop:ce44e480ae6cb7c6d49829357f2a0d42&#34;&gt;Docker Workshop&lt;/h2&gt;

&lt;p&gt;It seems the talk was able to whet the appetite of the audience as many joined the two hour workshop later.
Soon all seats were taken and the attendees embarked on a whirlwind tour through HypriotOS and Docker.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&#34;https://blog.hypriot.com/post/hypriotos-barbossa-for-raspberry-pi-3/&#34;&gt;HypriotOS&lt;/a&gt; and our convenient &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; everybody was able to start with Docker in no time.&lt;br /&gt;
After learning the basic Docker commands everybody started to feel like a real Docker Pirate.&lt;/p&gt;

&lt;p&gt;From there it was mostly smooth sailing and we even started to manage our containers with Docker Compose and Swarm.&lt;/p&gt;

&lt;p&gt;In the end the workshop was rounded off by an excursion into the realm of Dockerfiles and how to build our own Docker images.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/piandmore/workshop.jpg&#34; alt=&#34;PiAndMore&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;It was really nice to see so many people get excited about Docker and ask so many curious questions.
Later when I walked through the exhibition part of the conference I even learned that many people came to PiAndMore specifically because of the Docker talk and workshop.&lt;/p&gt;

&lt;p&gt;All in all it was awesome being at the PiAndMore conference.
It was really well organized and had a very nice nerdy feel about it.
Actually I had a really hard time to pry my colleague Andreas from the event when we finally had to leave to drive home.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/piandmore/organizers_docker_pirates.jpg&#34; alt=&#34;PiAndMore Having fun&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So if you happen to be near Trier next year when the next PiAndMore takes place make sure to pay them a visit.
It is most certainly worth it!&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Microservices Bliss with Docker and Traefik</title>
      <link>https://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/</link>
      <pubDate>Tue, 07 Jun 2016 09:15:00 +0000</pubDate>
      
      <guid>https://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/</guid>
      <description>

&lt;p&gt;A couple of weeks ago I found this really nice and neat HTTP reverse proxy called &lt;a href=&#34;https://docs.traefik.io/&#34;&gt;Traefik&lt;/a&gt;.
It is meant to act as frontend proxy for microservices that are provided by a dynamic backend like Docker.&lt;/p&gt;

&lt;p&gt;Did you realize the important part of the last sentence was &lt;strong&gt;dynamic&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;What makes Traefik really special is its ability of adding and removing container backend services by listening to Docker events.
So whenever a Docker container is started or stopped Traefik knows about it and adds the container to its list of active backend services.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/traefik/architecture.png&#34; alt=&#34;Traffic&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;With this ability Traefik can replace much more complicated setups based on Nginx or HAProxy that have to use additional tools like
&lt;a href=&#34;https://github.com/gliderlabs/registrator&#34;&gt;Registrator&lt;/a&gt;, &lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt; and &lt;a href=&#34;https://github.com/hashicorp/consul-template&#34;&gt;Consul-Template&lt;/a&gt; to achieve the same kind of functionality.&lt;/p&gt;

&lt;p&gt;So let me show you with a simple microservice example how easy it is to get started with Traefik&amp;hellip;&lt;/p&gt;

&lt;p&gt;As you can see in the following architecture overview we will have a simple HTTP service that answers incoming HTTP requests.&lt;/p&gt;

&lt;p&gt;We have multiple backend services that are running on different physical nodes for high availability and loadbalancing reasons.
Traefik serves as a frontend proxy that loadbalances incoming requests to the available backend services.&lt;/p&gt;

&lt;p&gt;Traefik as well as the backend services will run on top of a Docker Swarm cluster as containers.
In this example each backend service will answer with their individual container ID to make it easy to see which one answered.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/traefik/microsservice_example_end.jpg&#34; alt=&#34;Traffic&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So to get started we need a running Docker Swarm Cluster first.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-docker-swarm-cluster:eaccea7a352d1344b842649dc78262ad&#34;&gt;Creating a Docker Swarm Cluster&lt;/h2&gt;

&lt;p&gt;One of fastest and easiest ways to get a Docker Swarm cluster running is to use our &lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;Hypriot Cluster Lab&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As the Cluster Lab comes already preinstalled with out latest HypriotOS &amp;ldquo;Barbossa&amp;rdquo; release for the Raspberr Pi I will show you how to set up a Swarm Cluster with that.&lt;/p&gt;

&lt;p&gt;To follow along you will need at least three Raspberry Pi&amp;rsquo;s. I will use my Pico-Cluster with five nodes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/traefik/picocluster.jpg&#34; alt=&#34;Traffic&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The first step is flashing the necessary SD card images with HypriotOS.&lt;/p&gt;

&lt;p&gt;Clone the Hypriot flash repository and change into the appropriate folder for the operating system you are using to flash the SD cards.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/hypriot/flash.gi://github.com/hypriot/flash.git
$ cd flash/Darwin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the flash tool ready we now can prepare the SD card for our &lt;strong&gt;leader node&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./flash --hostname cl-leader https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.0/hypriotos-rpi-v0.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeat the process for the &lt;strong&gt;follower nodes&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for i in {1..4} do; ./flash --hostname cl-follower${i} https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.0/hypriotos-rpi-v0.8.0.img.zip; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the SD cards for the follower nodes are still being flashed you can already start the leader node.&lt;/p&gt;

&lt;p&gt;SSH into the leader and become root user:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pirate@cl-leader.local
$ sudo su
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make the Cluster Lab work with Traefik we need to update to the most recent version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get update
$ apt-get install hypriot-cluster-lab=0.2.13-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then start the Hypriot Cluster Lab with verbose output logging enabled:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ VERBOSE=true cluster-lab start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the Cluster Lab starts you can see how it configures itself and does a number of self-tests.
If not all steps are green stop it and start it again. If that fails, too, have a look at our &lt;a href=&#34;https://github.com/hypriot/cluster-lab#troubleshooting&#34;&gt;troubleshooting section&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After the leader node is ready, it is time to boot the rest of our nodes and update and start the Cluster Lab in the same fashion.
So go ahead and come back when your are done.&lt;/p&gt;

&lt;p&gt;Allright, We can now check if we really have a healthy five nodes Swarm Cluster by executing the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DOCKER_HOST=tcp://192.168.200.1:2378 docker info | grep Nodes
Nodes: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And voila we now really have five nodes in our cluster.
Congrats!&lt;/p&gt;

&lt;p&gt;As you made it so far the rest will be a piece of a cake!&lt;/p&gt;

&lt;h3 id=&#34;setting-up-our-microservice-app-with-traefik:eaccea7a352d1344b842649dc78262ad&#34;&gt;Setting up our microservice app with Traefik&lt;/h3&gt;

&lt;p&gt;Our example microservice application consists of two parts. The Traefik frontend and the WhoAmI application backend.
For both parts I have prepared images for you that can be pulled from the Docker Hub.&lt;/p&gt;

&lt;p&gt;The Traefik image is called &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-traefik/&#34;&gt;hypriot/rpi-traefik&lt;/a&gt; and the WhoAmI image is called &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-whoami/&#34;&gt;hypriot/rpi-whoami&lt;/a&gt;.
The Dockerfiles for both images can be found on Github in the &lt;a href=&#34;https://github.com/hypriot&#34;&gt;related repositories&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because both Dockerfiles are a fine example of how easy it is to create Docker images for Golang based software I will
show them here, too.&lt;/p&gt;

&lt;p&gt;Dockerfile for &amp;ldquo;rpi-traefik&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM hypriot/rpi-alpine-scratch
RUN apk update &amp;amp;&amp;amp;\
    apk upgrade &amp;amp;&amp;amp;\
    apk add ca-certificates &amp;amp;&amp;amp;\
    rm -rf /var/cache/apk/*
ADD https://github.com/containous/traefik/releases/download/v1.0.0-beta.771/traefik_linux-arm /traefik
RUN chmod +x /traefik
EXPOSE 80 8080
ENTRYPOINT [&amp;quot;/traefik&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we just add the Traefik binary on top of an Alpine linux image. The result is an image that is already quite small with about 41 MB.
It propably could be made even smaller by ensuring that the Traefik binary is compiled as a static binary and then putting it into an empty scratch image.&lt;/p&gt;

&lt;p&gt;You can see how this can be done with the next Dockerfile for the WhoAmI image:&lt;/p&gt;

&lt;p&gt;Dockerfile for &amp;ldquo;rpi-whoami&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM scratch

ADD http /http

ENV PORT 8000
EXPOSE 8000

CMD [&amp;quot;/http&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With about 3 MB the resulting image is really small.&lt;/p&gt;

&lt;p&gt;Well, now it is time to put this all together in a Docker Compose application.&lt;/p&gt;

&lt;p&gt;Clone the following repository on you cluster leader:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/hypriot/rpi-cluster-lab-demos
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the cloning is finished change into the &amp;lsquo;traefik&amp;rsquo; folder and use Docker Compose to start our application on top of our little Docker Swarm cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd rpi-cluster-lab-demos/traefik
$ DOCKER_HOST=tcp://192.168.200.1:2378 docker-compose up -d
Creating network &amp;quot;traefik_default&amp;quot; with the default driver
Creating traefik_traefik_1
Creating traefik_whoami_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this command Docker Compose should start two containers.
One Traefik container on our leader and one WhoAmi container on one of our follower nodes.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check if that really happened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOCKER_HOST=tcp://192.168.200.1:2378 docker ps | grep &#39;traefik\|whoami&#39;
cba8d9a7d8f7        hypriot/rpi-whoami         &amp;quot;/http&amp;quot;                  About a minute ago   Up About a minute   8000/tcp                                                 cl-follower1/traefik_whoami_1
7dc2b48a24e2        hypriot/rpi-traefik        &amp;quot;/traefik --web --doc&amp;quot;   About a minute ago   Up About a minute   192.168.200.1:80-&amp;gt;80/tcp, 192.168.200.1:8080-&amp;gt;8080/tcp   cl-leader/traefik_traefik_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks good. So let&amp;rsquo;s test our application by flinging some HTTP request towards our frontend:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for i in {1..5}; do curl -H Host:whoami.docker.localhost http://192.168.200.1; done
I&#39;am f72892c9187c
I&#39;am f72892c9187c
I&#39;am f72892c9187c
I&#39;am f72892c9187c
I&#39;am f72892c9187c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see it is always the same backend container which is responding and that&amp;rsquo;s just as it should be.&lt;/p&gt;

&lt;p&gt;Next we are going to increase the number of backend containers with the help of Docker Compose scale command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOCKER_HOST=tcp://192.168.200.1:2378 docker-compose scale whoami=5
Creating and starting traefik_whoami_2 ... done
Creating and starting traefik_whoami_3 ... done
Creating and starting traefik_whoami_4 ... done
Creating and starting traefik_whoami_5 ... done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can watch as Docker Compose tells Docker Swarm to spin up more containers.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s verify again if we now have five backend containers running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for i in {1..5}; do curl -H Host:whoami.docker.localhost http://192.168.200.1; done
I&#39;m 5d829fecbdaa
I&#39;m 5eb115353885
I&#39;m e0313ac24554
I&#39;m 642b5d2c8d09
I&#39;m f72892c9187c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perfect. Obviously Traefik did recognise that we started more containers and made them available to the frontend automatically.&lt;/p&gt;

&lt;p&gt;We can see what happened by looking at the logs of the Traefik container:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOCKER_HOST=tcp://192.168.200.1:2378 docker-compose logs traefik
...
traefik_1  | time=&amp;quot;2016-06-07T06:50:38Z&amp;quot; level=debug msg=&amp;quot;Configuration received from provider docker: {\&amp;quot;backends\&amp;quot;:{\&amp;quot;backend-whoami\&amp;quot;:{\&amp;quot;servers\&amp;quot;:{\&amp;quot;server-traefik_whoami_1\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.3:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1},\&amp;quot;server-traefik_whoami_2\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.5:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1},\&amp;quot;server-traefik_whoami_3\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.6:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1},\&amp;quot;server-traefik_whoami_4\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.4:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1},\&amp;quot;server-traefik_whoami_5\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.7:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1}}}},\&amp;quot;frontends\&amp;quot;:{\&amp;quot;frontend-Host-whoami-docker-localhost\&amp;quot;:{\&amp;quot;backend\&amp;quot;:\&amp;quot;backend-whoami\&amp;quot;,\&amp;quot;routes\&amp;quot;:{\&amp;quot;route-frontend-Host-whoami-docker-localhost\&amp;quot;:{\&amp;quot;rule\&amp;quot;:\&amp;quot;Host:whoami.docker.localhost\&amp;quot;}},\&amp;quot;passHostHeader\&amp;quot;:true}}}&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:38Z&amp;quot; level=debug msg=&amp;quot;Last docker config received less than 2s, waiting...&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Waited for docker config, OK&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating frontend frontend-Host-whoami-docker-localhost&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Wiring frontend frontend-Host-whoami-docker-localhost to entryPoint http&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating route route-frontend-Host-whoami-docker-localhost Host:whoami.docker.localhost&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating backend backend-whoami&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating load-balancer wrr&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_4 at http://10.0.0.4:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_3 at http://10.0.0.6:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_2 at http://10.0.0.5:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_1 at http://10.0.0.3:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_5 at http://10.0.0.7:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=info msg=&amp;quot;Server configuration reloaded on :80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the logs we can now clearly see how Traefik catched the Docker event and how it reacted.&lt;/p&gt;

&lt;p&gt;Isnt&amp;rsquo; awesome?&lt;/p&gt;

&lt;p&gt;OK. So this was basically our quick tour on how to do set up a simple microservice example with Docker and Traefik.&lt;/p&gt;

&lt;p&gt;The only thing that is left for us now is to clean up again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOCKER_HOST=tcp://192.168.200.1:2378 docker-compose down -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Did you notice the &amp;lsquo;-v&amp;rsquo; option? This seems to be really important as it cleans up all the containers including the overlay network that was created for us.
Without the &amp;lsquo;-v&amp;rsquo; option we would get an error the next time we start the application again with Docker Compose.&lt;/p&gt;

&lt;p&gt;It is also a good idea to stop the Cluster Lab on all nodes before you switch of your Raspberry Pi&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;So do a&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cluster-lab stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;on all your cluster nodes.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s just amazing how many interesting technologies we used in this small blog post.
And it wasn&amp;rsquo;t to hard to get them running together, wasn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;That is mostly due to the work the &lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;Hypriot Cluster Lab&lt;/a&gt; does for us and of course under the hood it is the Docker-Engine, Docker-Swarm and Docker-Compose that let&amp;rsquo;s us do so much with so little effort.&lt;/p&gt;

&lt;p&gt;So make sure to give our Hypriot Cluster Lab a spin and try some of the examples in our &lt;a href=&#34;https://github.com/hypriot/rpi-cluster-lab-demos&#34;&gt;Hypriot Cluster Lab Demos&lt;/a&gt; repository or add some of your own. Pull requests are always welcome.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning about Cloud Computing with Hypriot Cluster Lab at ICT 2016</title>
      <link>https://blog.hypriot.com/post/talk_ict_2016_international_conference_telecommunications/</link>
      <pubDate>Mon, 06 Jun 2016 18:03:34 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/talk_ict_2016_international_conference_telecommunications/</guid>
      <description>

&lt;p&gt;Our cooperation with University of Bamberg pays off once again: We had the chance to present our Hypriot Cluster Lab at &lt;a href=&#34;http://ict-2016.org/&#34;&gt;ICT 2016&lt;/a&gt;, the International Conference on Telecommunications. There, we were able to show the Hypriot Cluster Lab to the attendees, who were mainly scientific researchers from all over the globe.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/ict-2016-greece/ict_logo.jpg&#34; alt=&#34;IoT-requirements&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;We built the Hypriot Cluster Lab as lab environment that allows to easily teach about clustering and cloud computing. At the conference, the Hypriot Cluster Lab piqued lots of interest, so we are confident that it will be used more and more in educational institutions.&lt;/p&gt;

&lt;p&gt;Now, after the show, we are publishing &lt;a href=&#34;http://ict-2016.org/pdf/Demo1.pdf&#34;&gt;the paper&lt;/a&gt; that has been accepted at the conference and the &lt;a href=&#34;https://blog.hypriot.com/images/ict-2016-greece/ICT-Presentation.pdf&#34;&gt;presentation slides&lt;/a&gt;. However, the paper is (intentionally) very brief and the slides are not throughout self-explanatory, so we&amp;rsquo;ve also written down what we&amp;rsquo;ve presented to the audience back in Greece.&lt;/p&gt;

&lt;h2 id=&#34;iot-requires-expansion-to-small:e2e346a019a074ac80ebae91f71aeae5&#34;&gt;IoT requires &amp;ldquo;Expansion to small&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;Building cloud computing infrastructures with big servers is well understood. Even large cloud infrastructures powered by container technology are commonly in use. One of the pioneers to mention here is Google with its container-based cloud platform &lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, the uprising Internet of Things (IoT) will not allow to equip the edge of the network such as sensor networks in smart home/grid/production environments with big servers only. There, you especially need small devices with less computational power and energy demand. These devices require to be small and cheap enough to install up to several thousands of them in a smart environment, thereby creating sensor networks. For example think of sensor networks on wind farms:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/ict-2016-greece/wind.jpg&#34; alt=&#34;IoT-requirements&#34; /&gt;

&lt;div style=&#34;padding-left:34.4em; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/ewea/16577911487/in/photolist-rfW8w8-ipD2tM-ipC49q-7d8FqR-ipCNzR-ipC1dU-ipBRBC-ipCGWN-ipCkFm-njeuG6-ipCC31-ipCnPv-ayYLge-ipCJ61-ayYMmc-ipBGVN-ayYHLH-9mZuNi-ayYMzX-oWbzp6-ayYK6n-7ZaHBQ-q8T7wm-az2p4W-8LowiB-az2o8s-ayYJJt-az2p2f-3euhCb-ayYMWD-ayYNgZ-ayYL48-az2riu-6YiWvR-az2qkC-ayYMev-az2rxU-az2on1-ayYK2V-ayYHrz-az2oru-az2ov7-az2oeW-qQMUJN-auVRqy-az2oDm-ayYM8Z-i5kW85-ayYJTV-az2rCE&#34;&gt;European Wind Energy Association&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;At this point, Hypriot Cluster Lab (HCL) comes into play:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;HCL is a proof of concept that building clusters using container technology (in our case: Docker) also works well on small devices, not only on big servers.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This &amp;ldquo;Expansion to Small&amp;rdquo; was the theme of the ICT 2016, which made HCL a perfect fit to the conference&amp;rsquo;s agenda.&lt;/p&gt;

&lt;h2 id=&#34;hcl-makes-a-tangible-iot-like-cluster-affordable:e2e346a019a074ac80ebae91f71aeae5&#34;&gt;HCL makes a tangible IoT-like cluster affordable&lt;/h2&gt;

&lt;p&gt;HCL is not only a proof of concept that clustering with container technology on IoT devices works, it also serves a second purpose: It is cheap enough to be used as a learning platform to play with clustering or cloud computing on your desk. The minimal hardware configuration requires three Raspberry Pis plus accessoires, which is affordable for everyone to get their hands on a real, tangible cluster. We&amp;rsquo;ve already seen lecturers, students and pupils getting started on the HCL with different topics related to cloud computing, e.g. playing with micro services or load balancing. Some use cases can be found &lt;a href=&#34;https://github.com/hypriot/rpi-cluster-lab-demos&#34;&gt;in one of our repos here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even though the HCL is intended to be used as a tool to learn, its containing concepts are applicable for promising IoT software solutions. Comparing IoT&amp;rsquo;s general requirements for hard- and software that I identified in my bachelor thesis (&lt;a href=&#34;https://medium.com/@mathiasrenner/docker-container-virtualization-and-the-internet-of-things-bachelor-thesis-a6bc783b81fa#.f09czsq2e&#34;&gt;details here&lt;/a&gt;) show that many of those aspects are already visible in the HCL:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/ict-2016-greece/iot-requirements.jpg&#34; alt=&#34;IoT-requirements&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;conclusion:e2e346a019a074ac80ebae91f71aeae5&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;All in all, the conference was an enriching experience. Discussing with scientific researches and professors from many different countries resulted in high-grade feedback and inspirations of how we can further improve the HCL. Particularly interesting were the discussions after some glasses of good, greek wine. They resulted in less high-grade feedback, but much fun instead :)&lt;/p&gt;

&lt;p&gt;Thus, we look forward to attend more conferences. Well, the next conference is already set: In two weeks, three of the Hypriot team (Dieter, Stefan and myself) will attend DockerCon in Seattle, USA! We will give workshops and talks, so we are happy to meet you there! For everyone who won&amp;rsquo;t attend: Stay tuned, we try to share as much as possible via our channels.&lt;/p&gt;

&lt;p&gt;Last but not least, I give special thanks Marcel Großmann (research assistant at University of Bamberg) for his great support. He is not only providing high quality feedback to our work, meanwhile he also contributes to the HCL. Not to mention that he also provides the venue for our Docker Meetups. His continunous support is worth a virtual applause!&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Making of HypriotOS</title>
      <link>https://blog.hypriot.com/post/making-of-hypriotos/</link>
      <pubDate>Wed, 25 May 2016 18:03:32 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/making-of-hypriotos/</guid>
      <description>

&lt;p&gt;Today we have released a new version of HypriotOS &amp;ldquo;Barbossa&amp;rdquo; - the SD card image with a ready-to-go Docker toolset for all Raspberry Pi&amp;rsquo;s. Beginning with this release we have &lt;strong&gt;open sourced every step&lt;/strong&gt; to build each parts, from the kernel and root filesystem up to the SD card image.&lt;/p&gt;

&lt;p&gt;We have also moved every build step out in the cloud to use the &amp;ldquo;programmable internet&amp;rdquo; to build and test everything with just a &lt;strong&gt;git push&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/making-of-hypriotos/hypriotos-release.png&#34; alt=&#34;release process&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This diagram above shows the release process of a new SD card image for any of the new HypriotOS supported ARM boards. We have moved all building steps to Cloud services. This helps us all to build any SD card without the need to have the specific ARM board. And this also &lt;strong&gt;enables the community to contribute&lt;/strong&gt; to all our repos with pull requests.&lt;/p&gt;

&lt;h2 id=&#34;ci-driven-builds:ce95f1b761ab1b4f8ebf52d516170ec1&#34;&gt;CI driven builds&lt;/h2&gt;

&lt;p&gt;To build the SD card images in the Cloud we have chosen a mixture of &lt;strong&gt;Travis CI&lt;/strong&gt; and &lt;strong&gt;CircleCI&lt;/strong&gt; as the Docker support fits our needs. Only where we need ARM servers to built natively we have our own &lt;strong&gt;Drone&lt;/strong&gt; and &lt;strong&gt;Jenkins&lt;/strong&gt; servers running on Scaleway C1 servers.&lt;/p&gt;

&lt;p&gt;The build process downloads some other artifacts like the root filesystem for the specific ARM CPU type and installs further DEB packages like the &lt;strong&gt;Linux kernel&lt;/strong&gt;, the &lt;strong&gt;Docker Engine&lt;/strong&gt; and &lt;strong&gt;Docker Compose&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;After each build Travis also runs &lt;strong&gt;Serverspec&lt;/strong&gt; tests against the SD card image to have a minimal test of the generated output.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/making-of-hypriotos/travis-serverspec-tests.png&#34; alt=&#34;travis serverspec tests&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;When we trigger a release build, Travis deploys the newly generated SD card image to the &lt;strong&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases&#34;&gt;GitHub releases&lt;/a&gt;&lt;/strong&gt; page. You can find releases, as well as pre-releases of upcoming versions there.&lt;/p&gt;

&lt;h2 id=&#34;join-the-movement:ce95f1b761ab1b4f8ebf52d516170ec1&#34;&gt;Join the movement&lt;/h2&gt;

&lt;p&gt;The advantage of open sourcing is that the community can give us feedback and sometimes even start contributing back. The SD card image can be built locally on your Linux or Mac notebook as well. So you also are able to build a SD card image without having the device.&lt;/p&gt;

&lt;p&gt;As we love Docker the build process runs in a Docker Container. This simplifies the setup on your local machine. Each GitHub repository has a README with the steps needed to build and test the specific HypriotOS SD card image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/making-of-hypriotos/hypriotos-local-build.png&#34; alt=&#34;local build&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The normal workflow looks like this&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone&lt;/code&gt; - get the repo you want to build&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make docker-machine&lt;/code&gt; - create a local VM with Docker&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make sd-image&lt;/code&gt; - build the SD card image within a Docker Container&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flash sd-card*.zip&lt;/code&gt; - flash the new SD card image and boot your ARM device.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOARD=ip make test-integration&lt;/code&gt; - run Serverspec tests if everything is fine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have added over &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/tree/master/builder/test-integration/spec&#34;&gt;200 Serverspec tests&lt;/a&gt; to ensure the Docker tools, Kernel and additional packages are installed correctly. You can even run these tests for the latest release to check if it is working for you as well.
This enables everyone to make changes to the code base and send us Pull Requests without breaking other parts.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Pull Requests&lt;/strong&gt; are tested with &lt;strong&gt;Travis CI&lt;/strong&gt; of course, so we can see if it works well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/making-of-hypriotos/github-pr-success.png&#34; alt=&#34;pull request successful&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As there are several GitHub repositories involved to build the SD card image we use &lt;strong&gt;Waffle.io&lt;/strong&gt; to have and overview of all issues, pull requests and tasks to do for a release.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/making-of-hypriotos/waffle.png&#34; alt=&#34;waffle board&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;what-s-next:ce95f1b761ab1b4f8ebf52d516170ec1&#34;&gt;What&amp;rsquo;s next&lt;/h2&gt;

&lt;p&gt;We also started to add more boards and created new GitHub repos for each. But we focused on the Raspberry Pi to finish the &amp;ldquo;Barbossa&amp;rdquo; release. Here is a list of boards we have started to support:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;Raspberry Pi Zero, 1, 2, 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-c1&#34;&gt;ODROID C1/C1+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-xu4&#34;&gt;ODROID XU3/XU4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-c2&#34;&gt;ODROID C2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-bananapi&#34;&gt;Banana Pi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-nvidia-shieldtv&#34;&gt;NVIDIA ShieldTV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pine A64, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will pick one of these boards next to add all features of &amp;ldquo;Barbossa&amp;rdquo; to have a great Docker experience with it.
The other boards are still a work in progress - any help is welcome from the community!&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HypriotOS 0.8.0 Barbossa for Raspberry Pi 3</title>
      <link>https://blog.hypriot.com/post/hypriotos-barbossa-for-raspberry-pi-3/</link>
      <pubDate>Wed, 25 May 2016 03:30:00 +0000</pubDate>
      
      <guid>https://blog.hypriot.com/post/hypriotos-barbossa-for-raspberry-pi-3/</guid>
      <description>

&lt;p&gt;While it is quite hard to make something better that is already good, we feel that we were able to just do that with our latest release of HypriotOS.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS is the easiest and fastest way to get you started with Docker on ARM and IoT devices.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It is the perfect playground for your first steps with Docker and it allows you to move to advanced stuff like Docker Clustering without breaking a sweat, too.&lt;/p&gt;

&lt;p&gt;This is possible because we included a lot of the tools that make the Docker ecosystem awesome - for instance Docker Compose or Docker Swarm - out of the box.
We also integrated the Hypriot Cluster-Lab into this release, which makes it really easy and painless to set up complex Docker Clusters.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s just the tip of the iceberg. So read on to get all the glory details of this new release &amp;hellip; :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/hypriotos-barbossa/iceberg.jpg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;

&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/davidw/&#34;&gt;David&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;features-at-a-glance:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Features at a glance&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;support for Raspberry Pi Zero, 1, 2 and 3&lt;/li&gt;
&lt;li&gt;Linux kernel 4.4.10&lt;/li&gt;
&lt;li&gt;Docker Engine 1.11.1&lt;/li&gt;
&lt;li&gt;Docker Compose 1.7.1&lt;/li&gt;
&lt;li&gt;Docker Machine 0.7.0&lt;/li&gt;
&lt;li&gt;Docker Swarm 1.2.2&lt;/li&gt;
&lt;li&gt;Cluster-Lab 0.2.12&lt;/li&gt;
&lt;li&gt;device-init 0.1.7&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;updated-docker-and-docker-tools:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Updated Docker and Docker-Tools&lt;/h2&gt;

&lt;p&gt;Compared to our latest HypriotOS Berry 0.7 we did upgrade the Docker Engine to v1.11 which now has several binaries instead of one.
Besides the original Docker binary there is now also a Containerd and a runC binary. Containerd is basically a supervisor for individual containers that are run by runC.&lt;/p&gt;

&lt;p&gt;The main reasons for splitting up the Docker binary were the efforts of Docker to support the &lt;a href=&#34;https://www.opencontainers.org/&#34;&gt;standardization of container technology&lt;/a&gt; and to make it easier to maintain the existing technology stack.
You can get a good overview about these changes in the &lt;a href=&#34;https://blog.docker.com/2016/04/docker-engine-1-11-runc/&#34;&gt;blog post&lt;/a&gt; announcing the release of Docker 1.11.&lt;/p&gt;

&lt;p&gt;And there is also a very interesting deep dive into the details of those changes:&lt;/p&gt;

&lt;iframe id=&#34;ytplayer&#34; type=&#34;text/html&#34; width=&#34;1000&#34; height=&#34;560&#34; src=&#34;http://www.youtube.com/embed/QL8F2MLCybo&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;full-raspberry-pi-3-support:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Full Raspberry Pi 3 Support&lt;/h2&gt;

&lt;p&gt;Noteworthy is also that we now have full support for the Raspberry Pi 3.&lt;/p&gt;

&lt;p&gt;With the help of our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash-tool&lt;/a&gt; it is really easy to bring a Raspberry Pi 3 online with only WiFi network connectivity:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --ssid MyNetworkName --password SomeSecret https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.0/hypriotos-rpi-v0.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that you can usually connect to your Pi by:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The password is &amp;lsquo;hypriot&amp;rsquo;. And that&amp;rsquo;s it.&lt;/p&gt;

&lt;p&gt;By the way this also works if you attach an external WiFi adapter to a Raspberry Pi Zero, 1 and 2.&lt;/p&gt;

&lt;h2 id=&#34;customizing-your-raspberry-pi-configuration:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Customizing your Raspberry Pi Configuration&lt;/h2&gt;

&lt;p&gt;The ability to customize the hostname of your Pi, to add WiFi credentials and more is made possible by a small tool of ours called &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In previous versions we used a tool called &lt;a href=&#34;https://github.com/adafruit/Adafruit-Occi&#34;&gt;occi&lt;/a&gt; from Adafruit to allow hostname and WiFi customization.&lt;/p&gt;

&lt;p&gt;In this release we removed it and replaced it with device-init.&lt;/p&gt;

&lt;p&gt;device-init is a small programm that is started when your Raspberry Pi boots and it allows to customize a couple of settings.
It takes its configuration from a file called &amp;lsquo;device-init.yaml&amp;rsquo; which is located in the /boot directory.&lt;/p&gt;

&lt;p&gt;This /boot directory is basically a small FAT partition on the SD card that contains HypriotOS.
It can be easily accessed from your host computer before you boot your Pi. You can edit the &amp;lsquo;device-init.yaml&amp;rsquo; file directly with a text editor or by using the flash tool as demonstrated above.&lt;/p&gt;

&lt;p&gt;We are going to add more features - like adding public ssh keys, setting the locale or timezone - to device-init step by step in the next weeks.&lt;/p&gt;

&lt;h2 id=&#34;hypriot-cluster-lab:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Hypriot Cluster-Lab&lt;/h2&gt;

&lt;p&gt;We added the Hypriot Cluster-Lab to the image, too.&lt;/p&gt;

&lt;p&gt;It is disabled by default, but can easily be enabled when you flash the image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --clusterlab true https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.0/hypriotos-rpi-v0.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setting this options starts the Cluster-Lab on boot.&lt;/p&gt;

&lt;p&gt;By flashing a couple of SD cards with different hostnames and Cluster-Lab enabled you can get a fully working Docker Swarm cluster up and running in minutes.
The individual machines will find themselves automatically and form a Swarm cluster.&lt;/p&gt;

&lt;p&gt;You can read more about the Hypriot Cluster-Lab and why it is awesome on &lt;a href=&#34;https://github.com/hypriot/cluster-lab/&#34;&gt;its website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can download the new release in our &lt;a href=&#34;https://blog.hypriot.com/downloads&#34;&gt;download section&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you encounter any problems with this new release please open up issues in one of the following repositories:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;https://github.com/hypriot/image-builder-rpi&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;https://github.com/hypriot/cluster-lab&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;https://github.com/hypriot/device-init&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;https://github.com/hypriot/flash&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There is also our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter-Chat&lt;/a&gt; were you&amp;rsquo;ll find a very friendly community that always likes to help.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Close Encounters of the Third Kind, or Microsoft Windows meets Docker ARM Containers for IoT</title>
      <link>https://blog.hypriot.com/post/close-encounters-of-the-third-kind/</link>
      <pubDate>Tue, 29 Mar 2016 17:20:34 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/close-encounters-of-the-third-kind/</guid>
      <description>

&lt;p&gt;Running an ARM-based Docker container for IoT applications directly on Microsoft Windows
looks like an unbelievable &lt;strong&gt;extraterrestrial technology&lt;/strong&gt; from outer space.&lt;/p&gt;

&lt;p&gt;This cannot be true, it must be a fake, right?&lt;br /&gt;
Or, is this maybe just a &lt;strong&gt;cheap magic trick&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/close-encounters-of-the-third-kind/docker4win-arm-webpage.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Nope, believe me, that&amp;rsquo;s really true&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;behind-the-scenes:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Behind the scenes&lt;/h2&gt;

&lt;p&gt;As I showed in my last blog post about the &lt;a href=&#34;https://blog.hypriot.com/post/first-touch-down-with-docker-for-mac/&#34;&gt;First Touch Down with Docker for Mac&lt;/a&gt;,
&amp;ldquo;Docker for Mac&amp;rdquo; uses an Alpine Linux VM under the hood with the capability of emulating
ARM binaries on Intel CPUs. Because of &amp;ldquo;Docker for Windows&amp;rdquo; uses exactly the same
Alpine Linux in a Hyper-V virtual machine, this should work on Windows 10, too.&lt;/p&gt;

&lt;p&gt;The only problem here is, that the bind-mounting of a single binary doesn&amp;rsquo;t work
right now on Windows. I guess this will be fixed in a later release for sure. But
we can easily prepare an ARM-based Docker container to make the magic happen.&lt;/p&gt;

&lt;p&gt;We just have to put the &lt;a href=&#34;https://en.wikipedia.org/wiki/QEMU&#34;&gt;QEMU&lt;/a&gt; emulator binary
into the Docker container, and as long as we
place it at the correct path &lt;code&gt;/usr/bin/qemu-arm-static&lt;/code&gt;, this should work. The easiest
way to include the binary to the correct folder is to create a tar archive and use
the ADD command in the Dockerfile.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar vtf qemu-arm-static.tar
drwxr-xr-x  0 dieter staff       0 Mar 28 18:34 usr/
drwxr-xr-x  0 dieter staff       0 Mar 28 18:34 usr/bin/
-rwxr-xr-x  0 dieter staff 2899840 Mar 28 18:34 usr/bin/qemu-arm-static
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dockerfile:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;FROM hypriot/rpi-busybox-httpd
ADD qemu-arm-static.tar /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this easy preparation we&amp;rsquo;re able to start an ARM-based Docker container on
Windows 10 with two steps only.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; Create the modified Docker image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t rpi-busybox-httpd .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; Start the QEMU-enabled Docker container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here in this screenshot you can see all the necessary steps we need, there is really
nothing else to do.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/close-encounters-of-the-third-kind/docker4win-arm-container.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Voilà&lt;/strong&gt; - that was the magic trick which can be applied to almost all ARM-based Docker
images to make them run in &amp;ldquo;Docker for Windows&amp;rdquo; and &amp;ldquo;Docker for Mac&amp;rdquo; even on an Intel-based
CPU architecture.&lt;/p&gt;

&lt;h2 id=&#34;watch-the-results:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Watch the results&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Docker for Windows&amp;rdquo; publishes the Docker Engine network with the local network name
&lt;code&gt;docker&lt;/code&gt;. Thus to access the ARM web server, which is running inside of a Linux container,
 we just have to point our preferred web browser to &lt;code&gt;http://docker/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/close-encounters-of-the-third-kind/docker4win-arm-webpage2.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;key-takeaways:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Key Takeaways&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Docker for Windows&amp;rdquo; uses Windows native hypervisor Hyper-V&lt;/li&gt;
&lt;li&gt;the Docker Engine is running in a tiny Alpine Linux VM&lt;/li&gt;
&lt;li&gt;ARM-based Docker containers can be easily enabled with QEMU emulator&lt;/li&gt;
&lt;li&gt;Docker works great on Windows 10&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Are you curious now and want to get in touch with &amp;ldquo;Docker for Windows&amp;rdquo; by yourself?
Then you should register for the Docker BETA program at &lt;a href=&#34;https://beta.docker.com&#34;&gt;https://beta.docker.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>