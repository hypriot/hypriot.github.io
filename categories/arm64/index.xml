<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arm64 on Docker Pirates ARMed with explosive stuff</title>
    <link>https://blog.hypriot.com/categories/arm64/index.xml</link>
    <description>Recent content in Arm64 on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://blog.hypriot.com/categories/arm64/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NVIDIA Jetson Nano Developer Kit - Introduction</title>
      <link>https://blog.hypriot.com/post/nvidia-jetson-nano-intro/</link>
      <pubDate>Fri, 19 Apr 2019 14:16:25 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/nvidia-jetson-nano-intro/</guid>
      <description>&lt;p&gt;Let me introduce the brand new &lt;strong&gt;NVIDIA Jetson Nano Developer Kit&lt;/strong&gt;, which is basically a quad-core 64bit ARM Cortex-A57 CPU with 128 GPU cores - suitable for all kinds of maker ideas: AI, Robotics, and of course for running Docker Containers&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/Jetson-Nano-Box.jpg&#34; alt=&#34;Jetson-Nano-Box.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;unboxing&#34;&gt;Unboxing&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s unbox the board and do the initial configuration&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/Jetson-Nano-Upacked.jpg&#34; alt=&#34;Jetson-Nano-Upacked.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When opening the box we&amp;rsquo;ll find the board itself and a short getting started flyer which heads us to the NVIDIA website &lt;a href=&#34;https://NVIDIA.com/JetsonNano-Start&#34;&gt;https://NVIDIA.com/JetsonNano-Start&lt;/a&gt; where we can find all basic information about the new DevKit.&lt;/p&gt;

&lt;p&gt;Please note, there are no other parts included in the DevKit. So, in order to use the DevKit you&amp;rsquo;ll need some additional accessories:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MicroSD card (at least 16GByte)&lt;/li&gt;
&lt;li&gt;Monitor with HDMI or DisplayPort connector&lt;/li&gt;
&lt;li&gt;HDMI or DisplayPort cable to connect to the monitor&lt;/li&gt;
&lt;li&gt;USB Keyboard and Mouse&lt;/li&gt;
&lt;li&gt;Micro-USB power supply (5V, 2Amps for 10 watts)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;Following the official documentation &lt;a href=&#34;https://developer.nvidia.com/embedded/learn/get-started-jetson-nano-devkit&#34;&gt;Getting Started With Jetson Nano Developer Kit&lt;/a&gt; we have to download and flash the SD card. I don&amp;rsquo;t want to repeat these basic steps here, because it&amp;rsquo;s covered in great detail directy in the official NVIDIA tutorial &lt;a href=&#34;https://developer.nvidia.com/embedded/learn/get-started-jetson-nano-devkit#write&#34;&gt;Write Image to the microSD Card&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When downloading the SD card image, please be aware this one isn&amp;rsquo;t small at all. The download is a zipped image file of 5 GByte of compressed data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -alh jetson-nano-sd-r32.1-2019-03-18.zip
-rw-r--r--@ 1 dieter  staff   5.3G Mar 15 22:49 jetson-nano-sd-r32.1-2019-03-18.zip 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The SD card image is a huge 12 GByte data blob. I would strongly recommend to use a SD card size with at least 32 GByte, with the recommended 16 GByte minimum you won&amp;rsquo;t get really happy. So, please do yourself a favour and get a 32 or 64 GByte SD card.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -alh jetson-nano-sd-r32.1-2019-03-18.img
-rwxr-xr-x  1 dieter  staff    12G Mar 15 19:19 jetson-nano-sd-r32.1-2019-03-18.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For flashing the SD card image you could also use the Hypriot &lt;code&gt;flash&lt;/code&gt; tool, which can be found here &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;https://github.com/hypriot/flash&lt;/a&gt;. That&amp;rsquo;s exactly what I did from macOS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ flash --device /dev/disk2 jetson-nano-sd-r32.1-2019-03-18.img

Is /dev/disk2 correct? y
Unmounting /dev/disk2 ...
Unmount of all volumes on disk2 was successful
Unmount of all volumes on disk2 was successful
Flashing jetson-nano-sd-r32.1-2019-03-18.img to /dev/rdisk2 ...
Password:
12.0GiB 0:03:58 [51.6MiB/s] [=======================================================================================&amp;gt;] 100%
0+196608 records in
0+196608 records out
12884901888 bytes transferred in 234.213296 secs (55013537 bytes/sec)
Mounting Disk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our SD card is flashed with the latest image version, which is from March 18th 2019 as of time of this writing. But before using the SD card to boot up the NVIDIA Jetson Nano device, let&amp;rsquo;s have a short look at what&amp;rsquo;s on the SD card. Please, re-insert the SD card and list the current partitions. On macOS it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diskutil list /dev/disk2
/dev/disk2 (external, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:      GUID_partition_scheme                        *64.0 GB    disk2
   1:           Linux Filesystem                         12.9 GB    disk2s1
   2:           Linux Filesystem                         131.1 KB   disk2s2
   3:           Linux Filesystem                         458.8 KB   disk2s3
   4:           Linux Filesystem                         589.8 KB   disk2s4
   5:           Linux Filesystem                         65.5 KB    disk2s5
   6:           Linux Filesystem                         196.6 KB   disk2s6
   7:           Linux Filesystem                         589.8 KB   disk2s7
   8:           Linux Filesystem                         65.5 KB    disk2s8
   9:           Linux Filesystem                         655.4 KB   disk2s9
  10:           Linux Filesystem                         458.8 KB   disk2s10
  11:           Linux Filesystem                         131.1 KB   disk2s11
  12:           Linux Filesystem                         81.9 KB    disk2s12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, we&amp;rsquo;ll find at least 12 different partitions from NVIDIA. Currently we don&amp;rsquo;t look into all the details, maybe we can do this as part of a future blog post. For now we just know, 12 partitions are here and therefore flashing should be successful.&lt;/p&gt;

&lt;h3 id=&#34;initial-configuration&#34;&gt;Initial Configuration&lt;/h3&gt;

&lt;p&gt;For &lt;a href=&#34;https://developer.nvidia.com/embedded/learn/get-started-jetson-nano-devkit#setup&#34;&gt;Setup and First Boot&lt;/a&gt; of the NVIDIA Jetson Nano DevKit you need to attach a computer display, mouse and keyboard. All these steps are well documented at the NVIDIA web site, just following the prior hyperlink.&lt;/p&gt;

&lt;p&gt;Then power up the board with the Micro-USB power supply and follow the tutorial. This procedure will take a few minutes and then you&amp;rsquo;ll have a fully configured desktop system up and running which is based upon Ubuntu 18.04 LTS.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/Jetson-Nano-Board-Closeup.jpg&#34; alt=&#34;Jetson-Nano-Board-Closeup.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As I already said, the initial configuration of the Nano board has to be done interactively with the help of a computer monitor, mouse and keyboard. It&amp;rsquo;s really straight forward and consists of the following steps and settings. I also did a short video of this initial setup, so it&amp;rsquo;s maybe a little bit easier for you to follow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Settings:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Accept NVIDIA End User License Agreements: YES&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Select system language: ENGLISH&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Select keyboard layout: ENGLISH (US)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Select location/timezone: BERLIN&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set username: pirate&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set computer name: jetson-nano&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set password: hypriot&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[Here is the video link: NVIDIA-Jetson-Nano&amp;ndash;Initial-Setup &lt;strong&gt;Coming soon!&lt;/strong&gt;]&lt;/p&gt;

&lt;p&gt;At the end we login with the defined username &amp;ldquo;pirate&amp;rdquo; and get this nice Ubuntu desktop on our computer monitor. Yes, it&amp;rsquo;s really a fully Linux desktop system running on a 64bit ARM Cortex A57 board with 4 GByte of memory!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/jetson-desktop.jpg&#34; alt=&#34;jetson-desktop.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;running-docker&#34;&gt;Running Docker&lt;/h3&gt;

&lt;p&gt;TL;DR &lt;strong&gt;Docker is running out-of-the-box on the NVIDIA Jetson Nano board!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[Here is the video link: NVIDIA-Jetson-Nano&amp;ndash;Running-Docker &lt;strong&gt;Coming soon!&lt;/strong&gt;]&lt;/p&gt;

&lt;p&gt;As soon as the Jetson Nano board is configured and attached with an ethernet network cable, we can also discover it on the network with ping. Just use the computer name you defined. Here I used &lt;code&gt;jetson-nano&lt;/code&gt;, or you have to add &lt;code&gt;.local&lt;/code&gt;, this depends on your router setup. But just trying both it&amp;rsquo;s easy to do.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ping -c 3 jetson-nano
PING jetson-nano.lan (192.168.7.158): 56 data bytes
64 bytes from 192.168.7.158: icmp_seq=0 ttl=64 time=1.786 ms
64 bytes from 192.168.7.158: icmp_seq=1 ttl=64 time=1.954 ms
64 bytes from 192.168.7.158: icmp_seq=2 ttl=64 time=2.227 ms

--- jetson-nano.lan ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 1.786/1.989/2.227/0.182 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ping -c 3 jetson-nano.local
PING jetson-nano.local (192.168.7.158): 56 data bytes
64 bytes from 192.168.7.158: icmp_seq=0 ttl=64 time=1.338 ms
64 bytes from 192.168.7.158: icmp_seq=1 ttl=64 time=2.198 ms
64 bytes from 192.168.7.158: icmp_seq=2 ttl=64 time=1.964 ms

--- jetson-nano.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 1.338/1.833/2.198/0.363 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, I&amp;rsquo;m going to check the kernel version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ uname -a
Linux jetson-nano 4.9.140-tegra #1 SMP PREEMPT Wed Mar 13 00:32:22 PDT 2019 aarch64 aarch64 aarch64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We do have a LTS 4.9 kernel available on the Jetson Nano, which is pretty OK for running Docker and Containers.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s check if there is already a Docker Engine preinstalled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker version
[sudo] password for pirate:
Client:
 Version:           18.06.1-ce
 API version:       1.38
 Go version:        go1.10.1
 Git commit:        e68fc7a
 Built:             Fri Jan 25 14:35:17 2019
 OS/Arch:           linux/arm64
 Experimental:      false

Server:
 Engine:
  Version:          18.06.1-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.1
  Git commit:       e68fc7a
  Built:            Thu Jan 24 10:49:48 2019
  OS/Arch:          linux/arm64
  Experimental:     false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And show what details we&amp;rsquo;ll get from a &lt;code&gt;docker info&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker info
Containers: 2
 Running: 2
 Paused: 0
 Stopped: 0
Images: 1
Server Version: 18.06.1-ce
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version:  (expected: 468a545b9edcd5932818eb9de8e72413e616e86e)
runc version: N/A (expected: 69663f0bd4b60df09991c08812a60108003fa340)
init version: v0.18.0 (expected: fec3683b971d9c3ef73f284f176672c44b448662)
Security Options:
 seccomp
  Profile: default
Kernel Version: 4.9.140-tegra
Operating System: Ubuntu 18.04.2 LTS
OSType: linux
Architecture: aarch64
CPUs: 4
Total Memory: 3.868GiB
Name: jetson-nano
ID: CR66:D4BV:6TQC:GI4I:CXLP:EQMK:NK2P:FUFM:OATD:5F6M:J657:LU5T
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
Labels:
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is another screenshot directly from the Jetson Nano desktop with running the &lt;code&gt;docker version&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/jetson-desktop-docker.jpg&#34; alt=&#34;jetson-desktop-docker.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;starting-a-docker-container-for-arm&#34;&gt;Starting a Docker Container for ARM&lt;/h3&gt;

&lt;p&gt;Pull a first Docker Image which should run on ARM, here I&amp;rsquo;m going to use a Docker Image I did created almost four years ago for the Raspberry Pi and showcased live on stage at DockerCon 2015 in San Francisco, see &lt;a href=&#34;https://blog.hypriot.com/post/dockercon2015/&#34;&gt;Hypriot-Demo and challenge at DockerCon 2015&lt;/a&gt;. As this is an 32bit ARM image, let&amp;rsquo;s see if it works out-of-the-box on this brandnew Jetson Nano board.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker pull hypriot/rpi-busybox-httpd
Using default tag: latest
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Already exists
6f1938f6d8ae: Already exists
e1347d4747a6: Already exists
a3ed95caeb02: Already exists
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Image is up to date for hypriot/rpi-busybox-httpd:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Docker Image is pulled directly from Docker Hub and we can have a closer look, it&amp;rsquo;s pretty small in size with 2.16MByte only and it is already 3 years old.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker images
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
hypriot/rpi-busybox-httpd   latest              fbd9685c5ffc        3 years ago         2.16MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s see how it runs on the Jetson Nano.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker run -d -p 8000:80 hypriot/rpi-busybox-httpd
ed6e7838c9af3f73e6f7129e7c38bf369bb9a33aa67a3b160b1f1c6c7251b2b2

pirate@jetson-nano:~$ sudo docker ps
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                  NAMES
ed6e7838c9af        hypriot/rpi-busybox-httpd   &amp;quot;/bin/busybox httpd â€¦&amp;quot;   8 seconds ago       Up 7 seconds        0.0.0.0:8000-&amp;gt;80/tcp   laughing_lalande
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Opening up a web browser with the URL &lt;code&gt;http://192.168.7.158:8000&lt;/code&gt; and we should see the web page served by our Docker container running on the NVIDIA Jetson Nano.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/docker-container-webpage.jpg&#34; alt=&#34;docker-container-webpage.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here is another screenshot directly from the Jetson Nano desktop and a Chromium browser window which is showing our webpage served from the Docker container.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/jetson-desktop-container-webpage.jpg&#34; alt=&#34;jetson-desktop-container-webpage.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SUCCESS:&lt;/strong&gt; Docker Engine 18.06.1-CE is preinstalled on the brandnew NVIDIA Jetson Nano board and even old 32bit ARM Docker Images are running easily!&lt;/p&gt;

&lt;h3 id=&#34;recap&#34;&gt;Recap&lt;/h3&gt;

&lt;p&gt;As you can see, there is already a fully running version of the Docker Engine preinstalled on the official SD card image for the NVIDIA Jetson Nano board. The Linux kernel 4.9.x has all the basic features enabled to run containers locally.&lt;/p&gt;

&lt;p&gt;So, Docker just works out-of-the-box and you are able to use Docker Images right away. Even 32bit Docker images are able to run on this board because it&amp;rsquo;s based upon an ARM Cortex A57 CPU and this one is capable to run 64bit and 32bit ARM instructions.&lt;/p&gt;

&lt;p&gt;If you want to learn more general details about the NVIDIA Jetson Nano Developer Kit, please visit the JetsonHacks website at &lt;a href=&#34;https://www.jetsonhacks.com/2019/03/25/nvidia-jetson-nano-developer-kit/&#34;&gt;https://www.jetsonhacks.com/2019/03/25/nvidia-jetson-nano-developer-kit/&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bootstrapping a Cloud with Cloud-Init and HypriotOS</title>
      <link>https://blog.hypriot.com/post/cloud-init-cloud-on-hypriot-x64/</link>
      <pubDate>Sun, 29 Oct 2017 00:14:00 -0700</pubDate>
      
      <guid>https://blog.hypriot.com/post/cloud-init-cloud-on-hypriot-x64/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Things may come to those who wait, but only the things left by those who hustle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Over the last year, a lot has happened in the Raspberry Pi and Docker communities, there are Docker Captains helping lead the charge, one of those, &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;Dieter Reuter&lt;/a&gt; really has been pushing the cause for ARM64 support with both Raspberry Pi 3 and LinuxKit. He isn&amp;rsquo;t a single man army, the rest of the &lt;a href=&#34;http://blog.hypriot.com/crew/&#34;&gt;Docker Pirates&lt;/a&gt; over at &lt;a href=&#34;http://blog.hypriot.com/&#34;&gt;Hypriot&lt;/a&gt; have been doing some awesome things as well!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/cloud-init/brown-airplanes.jpg&#34; alt=&#34;airplanes&#34; /&gt;
&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/horiavarlan/5019447085/in/photolist-8DxYK8-6RFbEf-6RFfrw-6RLCGd-6RAH6n-6RF9gf-6RATnx-6RGCKM-6RB7L2-6REXqA-6T4VEQ-6RBeKg-brFbp6-6RAZU8-6RGwNk-6RAiLD-6RBgp6-6RLAvm-6RBbwM-6RAE5e-6RLJVj-6RLFdN-6RBsmr-6RFxxw-6RLJrY-6RFvGJ-6RFtZS-6REvrf-6RENUY-6RFwCC-6RGBEn-6RGz9n-6RFpb3-6RFzo1-if9tn-9NF66y-84UZy9-6RFew9-6RFq2m-6RLHWJ-6T4Wd9-9NChKc-6RAZ5V-9NCiK8-6T5Lbf-6RAUfp-6RBhb6-9NF3UW-9NF979-9NFaFW&#34;&gt;Horia Varlan&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Building on the backs of these outstanding community members, I was finally able to spin up a Raspberry Pi, exactly like I do in the &amp;ldquo;real world&amp;rdquo;, just turn it on, let it self-configure, then software just runs.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A lot of this is really about having &lt;a href=&#34;http://cloudinit.readthedocs.io/en/latest/index.html&#34;&gt;cloud-init &lt;/a&gt; available in the HypriotOS 64bit images thanks to another Pirate &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;Stefan Scherer&lt;/a&gt;. In the &amp;ldquo;cloud world&amp;rdquo;, you spin up instances, give it some user-data, then when it boots, the machines self-configures based on the instance meta-data and the user-data provided.&lt;/p&gt;

&lt;h2 id=&#34;before&#34;&gt;Before&lt;/h2&gt;

&lt;p&gt;Before we talk about the &amp;ldquo;new&amp;rdquo; pirate way, let&amp;rsquo;t talk about the &amp;ldquo;old&amp;rdquo; non-pirate way.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Download Raspbian Lite (the easiest for nubbies like me)&lt;/li&gt;
&lt;li&gt;Flash said image to an SD Card&lt;/li&gt;
&lt;li&gt;Optionally re-mount SD Card and monkey some stuff around&lt;/li&gt;
&lt;li&gt;Put the card in your RPi&lt;/li&gt;
&lt;li&gt;Power up the RPi&lt;/li&gt;
&lt;li&gt;If you don&amp;rsquo;t have avahi/bonjour, go find the IP in your router&lt;/li&gt;
&lt;li&gt;SSH into the server&lt;/li&gt;
&lt;li&gt;Update Packages&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;raspi-config&lt;/code&gt; and modify some junk&lt;/li&gt;
&lt;li&gt;Reboot&lt;/li&gt;
&lt;li&gt;Install Docker&lt;/li&gt;
&lt;li&gt;Initialize Docker Swarm&lt;/li&gt;
&lt;li&gt;Configure &lt;a href=&#34;http://portainer.io&#34;&gt;Portainer&lt;/a&gt; service (if not, are you broken?)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;try&amp;rdquo; and find some images you can run on arm&lt;/li&gt;
&lt;li&gt;Cheer at your glory based nginx hello world page!&lt;/li&gt;
&lt;li&gt;Figure out how to use automation tools like Ansible to make your life easier when you need a cluster&lt;/li&gt;
&lt;li&gt;Bang head on desk learning so much&amp;hellip;&lt;/li&gt;
&lt;li&gt;Do victory dances when you created a bunch of automation around setting up servers&lt;/li&gt;
&lt;li&gt;Go find out what the community is doing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is at that point, when the community really is an awesome place. Given the latest &lt;a href=&#34;https://github.com/DieterReuter/image-builder-rpi64/releases/tag/v20171013-172949&#34;&gt;HypriotOS-rpi64&lt;/a&gt;, the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash&lt;/a&gt; utility (also from Hypriot), Docker images now being multi-architecture supported through the &lt;a href=&#34;https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md&#34;&gt;manifest v2 API&lt;/a&gt; and Docker pushing to get all the &lt;a href=&#34;https://github.com/docker-library/official-images#architectures-other-than-amd64&#34;&gt;supported images covering a lot of architectures&lt;/a&gt;, life begins to get much &lt;strong&gt;much&lt;/strong&gt; easier.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: Before we continue, we need to talk about ARM 64 naming issues.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/ARM_architecture#64.2F32-bit_architecture&#34;&gt;ARM is complicated&lt;/a&gt; when it comes to the latest version of the architecture (v8). A lot of the distros still haven&amp;rsquo;t settled on what to call it, and you will find a lot of differences: &lt;code&gt;AArch64&lt;/code&gt; and &lt;code&gt;ARM64v8&lt;/code&gt; being the two most popular. When in doubt, do what &lt;a href=&#34;https://github.com/docker-library/official-images#architectures-other-than-amd64&#34;&gt;Docker does&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;after&#34;&gt;After&lt;/h2&gt;

&lt;p&gt;Now that we got that out of the way, let&amp;rsquo;s get into some code. Given the list of &lt;code&gt;arm64v8&lt;/code&gt; images in the &lt;a href=&#34;https://hub.docker.com/u/arm64v8/&#34;&gt;Docker registry&lt;/a&gt; I wanted to find something that would be interesting. Luckily, I was able to find &lt;a href=&#34;https://nextcloud.com/&#34;&gt;NextCloud&lt;/a&gt;. I have no idea if this software is worth keeping around, but it was something I could play with, try to break, reboot to see if it lives, and have something to play with when I succeed!&lt;/p&gt;

&lt;h3 id=&#34;user-data&#34;&gt;User Data&lt;/h3&gt;

&lt;p&gt;The first thing we need to do, is create our &lt;code&gt;user-data&lt;/code&gt; file. This will be placed inside of our SD card when we flash it and instruct &lt;code&gt;cloud-init&lt;/code&gt; what to do when the system boots for the first time.&lt;/p&gt;

&lt;p&gt;It should be noted, that at this time, the cloud-init version available for Debian distribution is &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/&#34;&gt;0.7.9&lt;/a&gt;, not the 17.1 you would have thought (as latest). Currently only Ubuntu is the only distribution I know of that is using 17.1.&lt;/p&gt;

&lt;p&gt;The next important fact to know is that the Data Source we are utilizing is the &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/topics/datasources/nocloud.html&#34;&gt;NoCloud&lt;/a&gt; data source. This basically means (in the 0.7.9 and below version) that the &lt;code&gt;user-data&lt;/code&gt; and &lt;code&gt;meta-data&lt;/code&gt; are on the local file system, not pulled from a remote resource or other means.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;user-data&lt;/code&gt; file is simply a YAML file, you can get a lot more complicated, but for the sake of simplicity, let&amp;rsquo;s just call it a YAML file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;user-data&lt;/code&gt; for this project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#cloud-config
# vim: syntax=yaml
#

hostname: nextcloud-pi64
manage_etc_hosts: true

resize_rootfs: true
growpart:
    mode: auto
    devices: [&amp;quot;/&amp;quot;]
    ignore_growroot_disabled: false

users:
  - name: pirate
    gecos: &amp;quot;Hypriot Pirate&amp;quot;
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    groups: users,docker,video
    plain_text_passwd: hypriot
    lock_passwd: false
    ssh_pwauth: true
    chpasswd: { expire: false }

package_update: true
package_upgrade: true
package_reboot_if_required: true
packages:
  - ntp

locale: &amp;quot;en_US.UTF-8&amp;quot;
timezone: &amp;quot;America/Los_Angeles&amp;quot;

write_files:
    - path: &amp;quot;/etc/docker/daemon.json&amp;quot;
      owner: &amp;quot;root:root&amp;quot;
      content: |
        {
          &amp;quot;labels&amp;quot;: [ &amp;quot;os=linux&amp;quot;, &amp;quot;arch=arm64&amp;quot; ],
          &amp;quot;experimental&amp;quot;: true
        }

runcmd:
  - [ systemctl, restart, avahi-daemon ]
  - [ systemctl, restart, docker ]
  - [docker, swarm, init ]
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;portainer&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;9000:9000&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=portainer_data,dst=/data&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock&amp;quot;,
      &amp;quot;portainer/portainer&amp;quot;, &amp;quot;-H&amp;quot;, &amp;quot;unix:///var/run/docker.sock&amp;quot;, &amp;quot;--no-auth&amp;quot;
    ]
  - [mkdir, &amp;quot;-p&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]
  - [setfacl, &amp;quot;-m&amp;quot;, &amp;quot;u:www-data:rwx&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;nextcloud&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;80:80&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=nextcloud,dst=/var/www/html&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/cloud/data,dst=/var/www/html/data&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;SQLITE_DATABASE=nextcloud&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_USER=pirate&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_PASSWORD=hypriot&amp;quot;,
      &amp;quot;nextcloud:latest&amp;quot;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is extremely important that before you flash this to a disk and attempt to boot, that you run this file through a YAML linter. There are some good ones &lt;a href=&#34;http://www.yamllint.com/&#34;&gt;available online&lt;/a&gt;, but you should never use an online linter if your &lt;code&gt;user-data&lt;/code&gt; contains real passwords or SSH keys, you can&amp;rsquo;t trust if they store the YAML or not on the server side.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s break this down into somewhat readable chunks&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;configure-host-name&#34;&gt;Configure Host Name&lt;/h4&gt;

&lt;p&gt;This will simply configure your hostname of the machine as well as make sure that &lt;code&gt;/etc/hosts&lt;/code&gt; is appropriately updated. You can specify an &lt;code&gt;fqdn&lt;/code&gt; here, as you will see below. However, the hostname in this file isn&amp;rsquo;t super important, as we will use the &lt;code&gt;--hostname&lt;/code&gt; option with the flash utility later to change this when we write the image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;hostname: nextcloud-pi64
manage_etc_hosts: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;resize-file-system&#34;&gt;Resize File System&lt;/h4&gt;

&lt;p&gt;This is something that had plagued RPi users for years, finally at some point the foundation images included this on first boot, but the wonderful thing about &lt;code&gt;cloud-init&lt;/code&gt; is it already had this built in. You &amp;ldquo;really&amp;rdquo; don&amp;rsquo;t need these settings in the file, I put these here to show that this is just built in functionality for &lt;code&gt;cloud-init&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;resize_rootfs: true
growpart:
    mode: auto
    devices: [&amp;quot;/&amp;quot;]
    ignore_growroot_disabled: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;create-users&#34;&gt;Create Users&lt;/h4&gt;

&lt;p&gt;Creating users is pretty simple, plop in an array element, give it some information, and your off to the races. The below is actually what is in the default &lt;code&gt;cloud-init&lt;/code&gt; for the HypriotOS image if you don&amp;rsquo;t overwrite it.  You can actually do a lot more with this, including adding SSH keys. Check out the &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/topics/modules.html#users-and-groups&#34;&gt;users documentation&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;users:
  - name: pirate
    gecos: &amp;quot;Hypriot Pirate&amp;quot;
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    groups: users,docker,video
    plain_text_passwd: hypriot
    lock_passwd: false
    ssh_pwauth: true
    chpasswd: { expire: false }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;update-and-add-packages&#34;&gt;Update and Add Packages&lt;/h4&gt;

&lt;p&gt;Because we live in a world of ever updating software, you really don&amp;rsquo;t know what is out of date in your image. This ensures that on first boot, all packages are updated. Additionally, you can install additional packages you might need. In this case I am installing NTP (there is a better way to do this, but there is an outstanding issue with it atm). Additionally, we instruct &lt;code&gt;cloud-init&lt;/code&gt; to reboot the server if the updates require one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;package_update: true
package_upgrade: true
package_reboot_if_required: true
packages:
  - ntp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NTP missing from the HypriotOS image is something I will be bringing up with the team to get fixed in the future!&lt;/p&gt;

&lt;h4 id=&#34;set-localized-settings&#34;&gt;Set Localized Settings&lt;/h4&gt;

&lt;p&gt;These will setup your server in your correct part of the world. The Raspbian comes with UK as default, at least HypriotOS came with a sane UTC default, but sometimes you just want your local time. This is definitely one of those time savers where most people used &lt;code&gt;raspi-config&lt;/code&gt; to set these (horrible horrible menus).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;locale: &amp;quot;en_US.UTF-8&amp;quot;
timezone: &amp;quot;America/Los_Angeles&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is something I feel like you should also be able to configure in the flash utility, and will be bringing it up as well with the Pirates.&lt;/p&gt;

&lt;h4 id=&#34;write-some-arbitrary-files&#34;&gt;Write some arbitrary files&lt;/h4&gt;

&lt;p&gt;The power to create files on boot&amp;hellip; This simple file output below is configuring docker labels as well as doing the (currently required) experimental features flag. This will require a Docker daemon restart, but we will cover that soon enough!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;write_files:
    - path: &amp;quot;/etc/docker/daemon.json&amp;quot;
      owner: &amp;quot;root:root&amp;quot;
      content: |
        {
          &amp;quot;labels&amp;quot;: [ &amp;quot;os=linux&amp;quot;, &amp;quot;arch=arm64&amp;quot; ],
          &amp;quot;experimental&amp;quot;: true
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;run-a-bunch-of-commands&#34;&gt;Run a bunch of commands&lt;/h4&gt;

&lt;p&gt;There are actually a few ways to run commands in &lt;code&gt;cloud-init&lt;/code&gt;, this is the most used, because it is the last thing that is done during initialization.&lt;/p&gt;

&lt;p&gt;In this, we are essentially restarting Docker and avahi to pickup our configuration changes, initializing Docker Swarm, running good ol Portainer (so we can see what is going on without SSH).&lt;/p&gt;

&lt;p&gt;The last steps are all specific to NextCloud. I create a new directory to store the files and SQL Lite database, set permissions for the &lt;code&gt;www-data&lt;/code&gt; user since NextCloud is using Apache, and running as a known user, we need to give that specific user permissions, and finally bootstrap NextCloud to self-configure and initialize.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;runcmd:
  # Pickup the hostname changes
  - [ systemctl, restart, avahi-daemon ]

  # Pickup the daemon.json changes
  - [ systemctl, restart, docker ]

  # Init a swarm, because why not
  - [docker, swarm, init ]

  # Run portainer, so we can see our logs and control stuff from a UI
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;portainer&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;9000:9000&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=portainer_data,dst=/data&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock&amp;quot;,
      &amp;quot;portainer/portainer&amp;quot;, &amp;quot;-H&amp;quot;, &amp;quot;unix:///var/run/docker.sock&amp;quot;, &amp;quot;--no-auth&amp;quot;
    ]

  # Create a specific directory to store all the data,
  # this way you could mount an external drive later (coming soon!)
  - [mkdir, &amp;quot;-p&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]

  # This gives the nextcloud permissions to write to this directory
  # since it runs as www-data
  - [setfacl, &amp;quot;-m&amp;quot;, &amp;quot;u:www-data:rwx&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]

  # Create the nextcloud instance configuring it on startup
  # - you should change the user/password below to something less obvious
  # or use the config UI
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;nextcloud&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;80:80&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=nextcloud,dst=/var/www/html&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/cloud/data,dst=/var/www/html/data&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;SQLITE_DATABASE=nextcloud&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_USER=pirate&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_PASSWORD=hypriot&amp;quot;,
      &amp;quot;nextcloud:latest&amp;quot;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are some important bits here, the &lt;code&gt;SQLITE_DATABASE=&amp;lt;name&amp;gt;&lt;/code&gt; is actually what triggers the &amp;ldquo;auto-configure&amp;rdquo; option, without that, the &lt;code&gt;NEXTCLOUD_*&lt;/code&gt; variables are ignored, despite what the documentation says.&lt;/p&gt;

&lt;h3 id=&#34;flash&#34;&gt;FLASH&lt;/h3&gt;

&lt;p&gt;If you don&amp;rsquo;t know about this utility yet, please head over to the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;github repo&lt;/a&gt; and check it out.&lt;/p&gt;

&lt;p&gt;Good, your back, now lets see my command line I use to run this on my Ubuntu 16.x Server.&lt;/p&gt;

&lt;p&gt;The following statements will install the prerequisites for flash, download the script, download this blog posts &lt;code&gt;user-data.yml&lt;/code&gt; file, then attempt to flash the image to an SD card.&lt;/p&gt;

&lt;p&gt;I highly recommend using a 32 or 64 GB flash card for this project, because if you decide to keep this cloud around, you might want to store one or two things in it.&lt;/p&gt;

&lt;p&gt;When prompted, insert your SD flash card into an available USB slot, then choose the right one, and verify the right one. You really don&amp;rsquo;t want DD to mount/flash/unmount your main drive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install pv unzip hdparm
curl -O https://raw.githubusercontent.com/hypriot/flash/master/$(uname -s)/flash
chmod +x flash
sudo mv flash /usr/local/bin/flash

# Just make sure the existing is gone
rm ./user-data.yml

# Download this yaml from this repo
curl -O https://gist.githubusercontent.com/RenEvo/6a9e244b670df334c42578b8fe95400b/raw/user-data.yml

// flash it
flash \
  --hostname mycloud.home.renevo.com \
  --userdata ./user-data.yml \
  https://github.com/DieterReuter/image-builder-rpi64/releases/download/v20171013-172949/hypriotos-rpi64-v20171013-172949.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When finished, pull out that sweet SD card, and let&amp;rsquo;s get ready to plug in.&lt;/p&gt;

&lt;h3 id=&#34;boot-and-forget&#34;&gt;Boot and Forget&lt;/h3&gt;

&lt;p&gt;For this, I simply put the SD card into a random RPi3 I had laying around, plugged in a network cable to my switch and the RPi, and then applied power to it.&lt;/p&gt;

&lt;p&gt;This is really where the waiting game begins, the RPi is going to boot up, self-name, self-update, possible reboot, pull down some Docker images, bootstrap a Docker Swarm, run Portainer, then finally&amp;hellip; start a personal cloud.&lt;/p&gt;

&lt;p&gt;At the time of writing this, you are still going to have to go fish out your IP from DNS unless you are on Mac or Linux with avahi, at that case, you can just navigate to &lt;code&gt;http://&amp;lt;hostname&amp;gt;.local&lt;/code&gt; or &lt;code&gt;http://&amp;lt;hostname&amp;gt;&lt;/code&gt; if you used an fqdn like I did. There are actually ways to get the RPi to phone home when it is finished bootstrapping, but I am going to save that for another post!&lt;/p&gt;

&lt;p&gt;So, after you get some coffee, you can try navigating to your RPi on port 9000 with your browser, that should get you into the Portainer instance without any type of authentication (don&amp;rsquo;t do this in a real environment please, go read the docs on securing it).&lt;/p&gt;

&lt;p&gt;After you go get a snack and take a short walk, you can try navigating to your RPi on port 80 with your browser, once you get prompted, login with user: &lt;code&gt;pirate&lt;/code&gt; and password: &lt;code&gt;hypriot&lt;/code&gt; to get access to your cloud. Click close on the annoying modal about downloading sync programs, and there you have it&amp;hellip; Your own personal cloud, bootstrapped from a simple YAML file, without you ever having to SSH into your PI.&lt;/p&gt;

&lt;p&gt;Here is the fun part, you can reflash that anytime you want to recreate the exact same baseline SD card image.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;This was a lot of fun for me, and without having to actually figure out some nitty gritty details, not over documenting things, and getting prepared to write this post, it realistically took me about 10 minutes to go from downloading the OS image to running NextCloud on my RPi. And that is all due to the hard work of the community, and especially the Docker Pirates at Hypriot, and to them, I thank you.&lt;/p&gt;

&lt;p&gt;I plan to continue playing with this, potentially updating the server to use an external USB drive for data and auto-mounting it on boot, possible setup a GlusterFS and run them in a small 2 or 3 node cluster, and call it my PiCloud.&lt;/p&gt;

&lt;p&gt;Who knows, it&amp;rsquo;s all about having fun and experimenting right?&lt;/p&gt;

&lt;p&gt;All the samples can be &lt;a href=&#34;https://gist.github.com/RenEvo/6a9e244b670df334c42578b8fe95400b&#34;&gt;found on on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;about-me&#34;&gt;About Me&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Who is this guy, and why is he posting on this blog?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My name is &lt;a href=&#34;https://twitter.com/TribalTom&#34;&gt;Tom Anderson&lt;/a&gt;, I am a Senior II Cloud Software Engineer by day at a killer gaming company, and by night I am a father, musician, tinkerer, and still&amp;hellip; a hobbiest programmer of all the things. Dieter Reuter was nice enough to ask me to guest post this topic, and I just felt it had to be done! The Pirates have given so much to the community, I felt I needed to give a little something back.&lt;/p&gt;

&lt;p&gt;Additionally, I build and talk about some things I think are cool on my own blog &lt;a href=&#34;http://tomanderson.me&#34;&gt;tomanderson.me&lt;/a&gt;, feel free to stop by and say hi!&lt;/p&gt;

&lt;p&gt;Finally, because legaleeze and stuff&amp;hellip; All opinions here are my own, and do not reflect the opinions of Blizzard Entertainment.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building a 64bit Docker OS for the Raspberry Pi 3</title>
      <link>https://blog.hypriot.com/post/building-a-64bit-docker-os-for-rpi3/</link>
      <pubDate>Thu, 02 Mar 2017 11:28:42 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/building-a-64bit-docker-os-for-rpi3/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m happy to announce the start of a &amp;ldquo;short&amp;rdquo; workshop were I&amp;rsquo;m going through all the steps to build a complete 64bit operating system for the Raspberry Pi 3. This 64bit HypriotOS is mainly focused on running Docker containers easily on this popular DIY and IoT device.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/e/e6/Raspberry-Pi-3-Flat-Top.jpg&#34; alt=&#34;Raspi3-Image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll see that I&amp;rsquo;m using Docker heavily for each and every build step, because it really helps us a lot to run a local build with &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;Docker-for-Mac&lt;/a&gt; or later on the cloud build servers at &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/building-a-64bit-docker-os-for-rpi3/bee42-workshop.jpg&#34; alt=&#34;bee42-workshop.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This workshop is sponsored by &lt;a href=&#34;http://bee42.com&#34;&gt;bee42 solutions&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bee42solutions&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @bee42solutions&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background-and-contents&#34;&gt;Background and Contents&lt;/h3&gt;

&lt;p&gt;As you may already know, a complete Linux operating system consists of several important building blocks and I&amp;rsquo;d like to show you how to build all of these step by step.&lt;/p&gt;

&lt;p&gt;For this purpose I&amp;rsquo;m not going to reinvent the wheel and so I&amp;rsquo;ll reuse all of the existing parts which are already published by the Raspberry Pi Organisation, by the Debian Linux project and will add some more glue code.&lt;/p&gt;

&lt;p&gt;At the end you should have learned how to build all the necessary parts and how to automatically create a finished SD card image which could be flashed on an empty SD card. Then boot your Raspberry Pi 3 with and in less than a minute you have a fully running Docker Engine on a Debian-based 64bit Linux OS.&lt;/p&gt;

&lt;p&gt;Here is a short overview of the contents of the workshop:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 1: Bootloader&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 2: Kernel&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 3: Root filesystem&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 4: SD Card Image&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, that&amp;rsquo;s enough for explaining the background of this workshop. For more informations please follow along the details I&amp;rsquo;ll publish on the coming tweets at Twitter and in the GitHub repos until all the parts of this workshop are finished and available as OpenSource.&lt;/p&gt;

&lt;p&gt;Please be aware that this OS is in a development phase and far from being perfect. So you are encouraged to help me with reporting issues and filing pull-requests to add features and fix bugs.&lt;/p&gt;

&lt;h3 id=&#34;further-links&#34;&gt;Further Links&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to publish all the details and steps to build the new operating system in a public GitHub repo. All other details and necessary GitHub repos will be linked here in this section as a future reference.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Workshop Repo&lt;/strong&gt; &lt;a href=&#34;https://github.com/dieterreuter/workshop-raspberrypi-64bit-os&#34;&gt;https://github.com/dieterreuter/workshop-raspberrypi-64bit-os&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So please stay tuned, this link list will be extended over the next few days.&lt;/p&gt;

&lt;h3 id=&#34;acknowledgments&#34;&gt;Acknowledgments&lt;/h3&gt;

&lt;p&gt;Please follow along the detailed tweets about this workshop via&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; &lt;a href=&#34;https://twitter.com/Quintus23M&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @Quintus23M&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt; &lt;a href=&#34;https://twitter.com/HypriotTweets&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @HypriotTweets&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/bee42solutions&#34;&gt;@bee42solutions&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bee42solutions&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @bee42solutions&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Special thanks goes to &lt;a href=&#34;http://bee42.com&#34;&gt;bee42 solutions&lt;/a&gt; for giving me the time to work on this awesome topic to build a complete Docker-enabled 64bit OS for the Raspberry Pi 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/building-a-64bit-docker-os-for-rpi3/bee42-logo.jpg&#34; alt=&#34;bee42-logo.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Getting Docker running on a high-end 64-bit ARM gaming console for fun and profit</title>
      <link>https://blog.hypriot.com/post/getting-docker-running-on-a-highend-arm-gaming-console-for-fun-and-profit/</link>
      <pubDate>Mon, 28 Dec 2015 09:00:00 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/getting-docker-running-on-a-highend-arm-gaming-console-for-fun-and-profit/</guid>
      <description>&lt;p&gt;I don&amp;rsquo;t really know how this happened. Again. :(&lt;br /&gt;
Somehow over and over again these little ARM devices and maker devboards end up on my desk.&lt;/p&gt;

&lt;p&gt;So what is it this time?&lt;/p&gt;

&lt;p&gt;Well, look at this beauty because words cannot even begin to describe it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/docker-on-nvidia-shieldtv.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Alright, start breathing again.&lt;/p&gt;

&lt;p&gt;It is called the &lt;a href=&#34;http://shield.nvidia.com&#34;&gt;Nvidia ShieldTV&lt;/a&gt; and it&amp;rsquo;s meant to be a media center.
Besides, it is one of the first Android gaming consoles that actually is worthy of the name.&lt;/p&gt;

&lt;p&gt;It would be a really great Christmas present for my son. But that is purely hypothetical and he is totally out of luck here.&lt;/p&gt;

&lt;p&gt;Why? Well, because the Nvidia Tegra X1 CPU is one of the first &lt;strong&gt;64-bit ARM CPU&amp;rsquo;s&lt;/strong&gt; that can be bought &lt;strong&gt;now&lt;/strong&gt; and it is even &lt;strong&gt;affordable&lt;/strong&gt; with a price tag well under 200 bucks.&lt;/p&gt;

&lt;p&gt;Being both Dieter and part of the Hypriot crew it should be clear now where this is heading, right?
As you all know Docker pirates love to be ARMed with little explosive stuff - and it doesn&amp;rsquo;t get more explosive than the Nvidia ShieldTV.&lt;/p&gt;

&lt;p&gt;So my son won&amp;rsquo;t get to play any games soon because &lt;strong&gt;I need&lt;/strong&gt; to get Docker running on this little beauty.
A device engineered for performance and made to game. So, let&amp;rsquo;s start playing&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-it-all-started&#34;&gt;How it all started&lt;/h3&gt;

&lt;p&gt;This spring, I was really happy to see Jen-Hsun Huang, CEO of Nvidia Corp. announcing a great new &lt;a href=&#34;https://www.youtube.com/watch?v=1q30y_pfz5Q&#34;&gt;gaming console&lt;/a&gt; - the &lt;a href=&#34;http://shield.nvidia.com/android-tv&#34;&gt;Nvidia ShieldTV&lt;/a&gt;.
It&amp;rsquo;s basically a 4K AndroidTV gaming machine and SmartTV device for the living room that easily connects to your big TV screen.&lt;/p&gt;

&lt;p&gt;This device has some remarkable features and performance specs. The hardware is based upon the new &lt;a href=&#34;http://www.nvidia.com/object/tegra-x1-processor.html&#34;&gt;Nvidia Tegra X1&lt;/a&gt; chip with an incredible CPU/GPU power of more than 1 TeraFLOPs of performance. This is an ARMv8 (64-bit) processor with eight cores in a big-little configuration (4x A57 1.9GHz + 4x A53) and 3 Gbyte of memory.
For fast and efficient graphics, Nvidia has included 256 Maxwell GPU cores as well.&lt;/p&gt;

&lt;p&gt;Looking at the Tegra X1 chip, it&amp;rsquo;s dominated by the 256x CUDA GPU cores. Can you find the CPU cores? They are pretty hard to find. ;-)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/nvidia-tegra-x1-chip.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;All in all, this device has a lot of CPU power and an incredible amount of GPU power as well - especially for a low-cost device &lt;a href=&#34;http://www.amazon.com/NVIDIA-SHIELD-Remote/dp/B013HJ13V0/ref=sr_1_3?ie=UTF8&amp;amp;qid=1451218402&amp;amp;sr=8-3&amp;amp;keywords=nvidia+shield&#34;&gt;at just $199.99&lt;/a&gt;.
It is easy to imagine that the ShieldTV could be used for so much more than just simple media streaming and gaming.&lt;/p&gt;

&lt;p&gt;But how?&lt;/p&gt;

&lt;h3 id=&#34;in-the-beginning-there-was&#34;&gt;In the beginning there was &amp;hellip;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip; Android&lt;/strong&gt;. Yeah, that is the strange operating system from Google that comes preinstalled with the Nvidia ShieldTV.&lt;/p&gt;

&lt;p&gt;Android is OK for running the ShieldTV as a media center or gaming console, but for using it as general purpose desktop computer, another operating system would be much more convenient.
Linux for instance - if we were only able to hack the ShieldTV and install a Linux system on it, we would open it up for a much broader range of use cases.&lt;/p&gt;

&lt;p&gt;Alright, I would be content with Docker for a start.&lt;/p&gt;

&lt;p&gt;It turned out that this is everything but easy.&lt;/p&gt;

&lt;h3 id=&#34;then-there-was&#34;&gt;Then there was &amp;hellip;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip; Ubuntu&lt;/strong&gt;. A few weeks ago I was able to install a basic Ubuntu 14.04 provided by Nvidia for their development boards.
This so called &lt;a href=&#34;https://developer.nvidia.com/embedded/linux-tegra&#34;&gt;Nvidia Linux For Tegra (L4T)&lt;/a&gt; is running a 64-bit kernel, but does only provide a 32-bit root file system.
Nvidia really? What a bummer. Hopefully they will change this in the future.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/nvidia-shieldtv-running-ubuntu.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Later on, I created a Debian Jessie root file system directly from upstream, which is compiled for the ARM64 architecture.
Combining the standard Nvidia 64-bit kernel and a Debian Jessie root file system, I am able to boot the ShieldTV into a pure 64-bit Linux system - HELL YEAH, that&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;Building the basic root file system was easy, but fixing all the network issues and Systemd settings was a real challenge.
Fortunately I got a lot of help from Andreas (another member of our Hypriot crew), who managed to fix them all.&lt;/p&gt;

&lt;h3 id=&#34;and-after-some-more-hard-work-there-was&#34;&gt;And after some more hard work there was &amp;hellip;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip; HypriotOS&lt;/strong&gt;. As a result the ShieldTV is now booting into a pure 64-bit environment in less than ten seconds.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/nvidia-shieldtv-running-hypriotos-arm64.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see the Nvidia ShieldTV is running our new 64-bit HypriotOS system on four CPU cores and has almost three gigabyte of memory available.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/nvidia-shieldtv-running-hypriotos-htop.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;in-the-end-there-was&#34;&gt;In the end there was &amp;hellip;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&amp;hellip; Docker&lt;/strong&gt;. This is the final piece that I wanted to get running. A first step in this direction is to get &lt;strong&gt;Go 1.5.1&lt;/strong&gt; and its build dependencies compiled.
After that it was a walk in the park to get the latest &lt;strong&gt;Docker v1.10.0-dev&lt;/strong&gt; compiled.&lt;/p&gt;

&lt;p&gt;The only annoying thing that remains right now is that we still have an old 3.10.61 kernel that is not optimized for running Docker.&lt;/p&gt;

&lt;h3 id=&#34;damn-it-the-last-20-are-always-the-toughest&#34;&gt;Damn it! The last 20% are always the toughest&amp;hellip;&lt;/h3&gt;

&lt;p&gt;The last few days I tried to build a custom Linux kernel for the ShieldTV that has all the right kernel settings for Docker enabled.
But I had no luck at all.&lt;/p&gt;

&lt;p&gt;I was able to cross-compile a lot of different generic kernels for ARM64, but none of them were able to boot successfully on the ShieldTV.
And as you can imagine, debugging some kernel and boot issues without having a serial or UART console to get early boot messages, one is easily lost.&lt;/p&gt;

&lt;p&gt;Enabling different kernel settings, building the kernel, flashing it and then trying to boot it was a really difficult and time consuming process.
Yesterday I was finally lucky enough to get almost all of the important kernel settings for Docker working im my custom 3.10.61 Linux kernel.
Honestly, this is quite an old kernel version and far from being perfect for Docker but it works for now and the Docker Engine is running the first time on this great device!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/nvidia-shieldtv-running-docker-1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s spin up a Docker image or two! Funny enough even a Docker image that was built for the Raspberry Pi can run on ARM64.
Who can remember it? This is exactly the same web server container I was demoing live on stage at &lt;a href=&#34;https://blog.hypriot.com/post/dockercon2015/&#34;&gt;DockerCon 2015 in San Francisco&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/nvidia-shieldtv-running-docker-3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Maybe it is more interesting to run a real ARM64 Docker image to proof that our ARM 64-bit Docker engine is working just fine.
So here we go&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/nvidia-shieldtv-running-docker-4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That is already pretty impressive, but there is still a lot to do.&lt;/p&gt;

&lt;p&gt;In the spirit of HypriotOS we want to deliver an easy out-of-the-box experience with the latest and greatest of software components.
This means we need a really easy way to flash and install HypriotOS on the ShieldTV similar to how we do it for the Raspberry Pi.
And all the included components should be really up-to-date: the Linux kernel (4.x) and of course all of the Docker tools as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-shieldtv/nvidia-shieldtv-on-my-desktop.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Maybe there are some of you who - after reading this article - want to get started hacking on the ShieldTV, too.
We really would appreciate getting some help here to move faster.
That&amp;rsquo;s why we will publish the technical details in the coming weeks, so you can have a look and start hacking yourself.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; &amp;amp; Andreas &lt;a href=&#34;https://twitter.com/firecyberice&#34;&gt;@firecyberice&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>