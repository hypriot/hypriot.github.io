<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arm on Docker Pirates ARMed with explosive stuff</title>
    <link>http://blog.hypriot.com/tags/arm/</link>
    <description>Recent content in Arm on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Aug 2016 12:30:00 +0200</lastBuildDate>
    <atom:link href="http://blog.hypriot.com/tags/arm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Releasing HypriotOS 1.0.0 &#34;Blackbeard&#34;</title>
      <link>http://blog.hypriot.com/post/releasing-HypriotOS-1-0/</link>
      <pubDate>Sun, 21 Aug 2016 12:30:00 +0200</pubDate>
      
      <guid>http://blog.hypriot.com/post/releasing-HypriotOS-1-0/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Today we proudly present our 1.0.0 release of HypriotOS – a container OS that takes you from Zero to Docker within 5 Minutes only, on any device of the complete Raspberry Pi family.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For this major release we&amp;rsquo;ve taken an especially great deal of trouble. Out of the box, you not only get the breaking features of the Docker Engine 1.12.1 and the latest versions of Docker Compose and Docker Machine, but also many improvements that enhance the performance, reliability and usability.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/release-1-0/docker_pirate_650px_full-width.jpg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Therefore, this release illustrates very much how we work as Hypriot Team: We don&amp;rsquo;t stop after a &lt;code&gt;docker run&lt;/code&gt; just works on a Raspberry Pi. Meanwhile this has been possible for a long time. We only stop, when we went all the way down the rabbit whole and identified all adjusting screws of the operating system that can be used to improve the &lt;strong&gt;performance, reliability and usability&lt;/strong&gt; to run containers efficiently on ARM. Just to name a few examples: we include a Linux Kernel that is optimized for running Docker, we set all recommended configuration settings stated by Docker (and more), and provide tools that make the process of downloading HypriotOS and flashing it on a SD card super easy (see our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; and &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;As a result, you can be sure that we fine-tuned all adjusting screws to ensure we provide not some container OS, but an awesome one.&lt;/p&gt;

&lt;h2 id=&#34;feature-highlights-of-hypriotos:6302a5b7b7c942e4a845691a2c858ddf&#34;&gt;Feature Highlights of HypriotOS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Latest Docker Engine 1.12.1 with Swarm Mode&lt;/strong&gt; &lt;/br&gt;
You can get your hands on the new features of the freshly-baked Engine Docker 1.12.1 that is still warm. It includes the new Swarm Mode, which allows high availability of services in a multi-node cluster within just a few commands.
&lt;a href=&#34;https://blog.docker.com/2016/07/swarm-mode-on-a-raspberry-pi-cluster/&#34;&gt;See this short video how it works.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Support for the complete Raspberry Pi family&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS on each and every model of the Raspberry Pi family - we&amp;rsquo;re supporting Pi 1, 2, 3, Zero and even the Compute Module. Thus, all Raspberry Pi devices ever built are fully supported. This is possible through the dual kernels for ARMv6 and ARMv7 architecure we included on the SD card. Guess what: you can even switch your SD card from one Pi model to the other and it just works.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Easy flashing and configuration&lt;/strong&gt; &lt;/br&gt;
We improved our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;, which puts HypriotOS onto a SD card that is ready to boot from with a single command. After you flashed the SD card, you can store the settings of your environment, e.g. Wi-Fi connection parameters into a configuration file on the SD card &lt;code&gt;/boot/device-init.yaml&lt;/code&gt;. HypriotOS includes &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;, which makes your Raspberry Pi directly connecting to your Wi-Fi network after booting.
After booting, you can find the Raspberry Pi at your network with a simple &lt;code&gt;ping black-pearl.local&lt;/code&gt; – no more searching for IP addresses required thanks to the integrated Avahi service discovery.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enhanced security out of the box&lt;/strong&gt; &lt;/br&gt;
We think that security should be shipped out-of-the-box. We make HypriotOS more secure without you even noticing it. For instance, there is no built-in &amp;ldquo;root&amp;rdquo; user any more. Also, the default user &amp;ldquo;pirate&amp;rdquo; (password &amp;ldquo;hypriot&amp;rdquo;) is able to run Docker commands directly, which usually requires sudo rights. For an even better security, we strongly recommend to change the default user password and to restrict SSH access to pre-shared keys only with disabling SSH password authentication.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maximum performance out of the box&lt;/strong&gt; &lt;/br&gt;
As with security, running Docker with high performance comes out-of-the-box with HypriotOS. This includes faster booting times (15-17 sec.), an optimized file system to support more Inodes, minimal memory footprint and disk usage, and the reliable overlay storage driver for Docker by default.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Now 50% smaller in size, even smaller than Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
Even though HypriotOS 1.0.0 is fully packed with the complete and latest Docker tool set, it now comes at a size smaller than the tiniest version of Raspbian (&amp;ldquo;Raspbian Lite&amp;rdquo;). We achieved this mainly by reducing the cache&amp;rsquo;s footprint and leaving out some unused packages, so you won&amp;rsquo;t miss any features you are used to. You just need to download only 232 MB instead of 504 MB as before. With this improvements the minimum disk usage is reduced down to 600 MB.&lt;/p&gt;

&lt;p&gt;Please see all details in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases/tag/v1.0.0&#34;&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;quick-start:6302a5b7b7c942e4a845691a2c858ddf&#34;&gt;Quick start&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Download our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; and run&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash https://downloads.hypriot.com/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Afterwards, put the SD card into the Raspberry Pi and power it. That&amp;rsquo;s all to get HypriotOS up and running!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps:6302a5b7b7c942e4a845691a2c858ddf&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;If you wanna connect to the Raspberry Pi, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with password &amp;ldquo;hypriot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you want the Raspberry Pi to connect directly to your Wi-Fi after boot, change the hostname of the Raspberry Pi and more, edit &lt;code&gt;/boot/device-init.yaml&lt;/code&gt; of the SD card and have a look at the &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;documentation of device-init&lt;/a&gt;. Alternatively, checkout the parameters of the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt; that also allows you to define configurations. Really, it&amp;rsquo;s just so damn easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n myHOSTNAME -s mySSID -p myWIFIPASSWORD https://downloads.hypriot.com/hypriotos-rpi-v1.0.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;feedback-please:6302a5b7b7c942e4a845691a2c858ddf&#34;&gt;Feedback, please&lt;/h2&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Your Hypriot Team:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Andreas &lt;a href=&#34;https://twitter.com/firecyberice&#34;&gt;@firecyberice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mathias &lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Building Docker 1.12 on a Raspberry Pi</title>
      <link>http://blog.hypriot.com/post/building-docker-directly-on-a-raspberry-pi/</link>
      <pubDate>Sun, 31 Jul 2016 15:24:03 +0200</pubDate>
      
      <guid>http://blog.hypriot.com/post/building-docker-directly-on-a-raspberry-pi/</guid>
      <description>

&lt;p&gt;Over time many of our users have asked us exactly how we build the Docker Engine
and the associated Debian packages. For instance: they&amp;rsquo;d like to hack on some
 new features and need the latest software releases as soon as possible.&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;ll share all the details on building the latest Docker version - even on
a Raspberry Pi itself. Beware: while it&amp;rsquo;s not too complicated it will require
a large amount of time!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/build-docker-on-raspberrypi/docker-on-raspberrypi.jpg&#34; alt=&#34;Docker on Raspberry&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s get started. Follow me down the &lt;em&gt;Rabbit Hole&lt;/em&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;background:c68665982a08b259934801e30d513d89&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;The goal of this tutorial is to give you all the details you need to build the
Docker Engine yourself on your cool and fast $35 super-computer (the Raspberry Pi).&lt;/p&gt;

&lt;h3 id=&#34;prepare-the-build-environment:c68665982a08b259934801e30d513d89&#34;&gt;Prepare the Build Environment&lt;/h3&gt;

&lt;p&gt;Before we begin this arduous task have to prepare our build environment for what
will be a large, long-running workload.&lt;/p&gt;

&lt;h4 id=&#34;hardware-and-software-requirements:c68665982a08b259934801e30d513d89&#34;&gt;Hardware and Software Requirements&lt;/h4&gt;

&lt;p&gt;For building the Docker Engine in the recommended way we need a Linux computer which
already has a recent version of Docker running. Yeah, the Docker Engine will be build
inside of a Docker container to get a consistent and reproducible build environment.
As this requires some CPU power and disk space, I&amp;rsquo;m giving you here the minimal
specs for the hardware.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3 (a Pi 2 will work, but the build process will take even longer!)&lt;/li&gt;
&lt;li&gt;16 GByte SD card (8 GByte is not enough!)&lt;/li&gt;
&lt;li&gt;enabled swap space (1 GByte of memory is not sufficient!)&lt;/li&gt;
&lt;li&gt;Docker Engine 1.11&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;installing-the-build-environment:c68665982a08b259934801e30d513d89&#34;&gt;Installing the Build Environment&lt;/h4&gt;

&lt;p&gt;As you will see, setting up the build environment is damn easy, because we&amp;rsquo;ll just
use the latest release of HypriotOS which has the required Docker Engine 1.11.1
already pre-installed. These steps here are done on OS X, on a Linux or Windows
box it&amp;rsquo;s a little bit different.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step 1:&lt;/em&gt; install HypriotOS 0.8.2 on a SD card&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ flash https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.2/hypriotos-rpi-v0.8.2.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now boot the Raspberry Pi 3 with the newly flashed SD card.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Step 2:&lt;/em&gt; deploy SSH keys&lt;/p&gt;

&lt;p&gt;(Note: login credentials are username=pirate, password=hypriot)&lt;/p&gt;

&lt;p&gt;First, wait until the Raspberry Pi is booted up and is visible on the network
to gather it&amp;rsquo;s IP address.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping -c 1 black-pearl.local
PING black-pearl.local (192.168.2.113): 56 data bytes
64 bytes from 192.168.2.113: icmp_seq=0 ttl=64 time=5.697 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, deploy your standard SSH keys to the Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-add
$ ssh-keygen -R 192.168.2.113
$ ssh-copy-id pirate@192.168.2.113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re able to login into the Raspberry Pi without using a password.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pirate@192.168.2.113

$ uname -a
Linux black-pearl 4.4.15-hypriotos-v7+ #1 SMP PREEMPT Mon Jul 25 08:46:52 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Step 3:&lt;/em&gt; install some build dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install -y make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Step 4:&lt;/em&gt; using a swap file&lt;/p&gt;

&lt;p&gt;This will create and use a default 2x 1GByte swap file at /var/swap.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install -y dphys-swapfile
$ ls -alh /var/swap
-rw------- 1 root root 1.8G Jul 30 17:58 /var/swap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we need a larger swap file, we could edit the config file &lt;code&gt;/etc/dphys-swapfile&lt;/code&gt;,
but for our use case the default 1.8 GByte swap file is sufficient.&lt;/p&gt;

&lt;h3 id=&#34;clone-the-docker-repo:c68665982a08b259934801e30d513d89&#34;&gt;Clone the Docker repo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/docker/docker.git
$ cd docker
$ git checkout v1.12.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we&amp;rsquo;re using a tagged release for Docker to build this exact version.&lt;/p&gt;

&lt;h3 id=&#34;how-to-apply-some-extra-pull-requests:c68665982a08b259934801e30d513d89&#34;&gt;How to apply some extra Pull Requests&lt;/h3&gt;

&lt;p&gt;Just to be honest, right now the build process for Docker v1.12.0 will fail on ARM.
This is a known issue and will be fixed hopefully soon. But luckily there is already
a &lt;a href=&#34;https://github.com/docker/docker/pull/25192&#34;&gt;pull request&lt;/a&gt;
which enables us to build the Docker .deb packages. This gives me
the change to explain how you can easily apply a PR on top of a release version.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s cherry pick this specific pull request.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin pull/25192/head:fix-manpages-on-arm
$ git cherry-pick fix-manpages-on-arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally let&amp;rsquo;s check if everything is OK with the git history.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;commit e15322b4fcb173674fd62a329a51b0756f02d503
Author: Daniel Nephin &amp;lt;dnephin@docker.com&amp;gt;
Date:   Thu Jul 28 14:53:08 2016 -0400

    Fix the man/Dockerfile for arm

    Signed-off-by: Daniel Nephin &amp;lt;dnephin@docker.com&amp;gt;

commit 8eab29edd820017901796eb60d4bea28d760f16f
Author: Tibor Vass &amp;lt;tibor@docker.com&amp;gt;
Date:   Wed Jul 27 16:35:10 2016 -0700

    Bump VERSION to v1.12.0

    Signed-off-by: Tibor Vass &amp;lt;tibor@docker.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the second last commit is the release commit for the official v1.12.0
version of the Docker Engine. The last commit is from the applied PR.&lt;/p&gt;

&lt;h3 id=&#34;run-the-build:c68665982a08b259934801e30d513d89&#34;&gt;Run the build&lt;/h3&gt;

&lt;p&gt;And here comes the magic: we&amp;rsquo;ll start the build process and then have to wait
for a really long time for it to finish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time make deb

...
real	350m48.228s
user	0m22.140s
sys	0m4.870s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete build process takes almost 6 hours on a fast Raspberry Pi 3, but finally
we&amp;rsquo;ll get the Docker Engine v1.12.0 build for a few different ARM operating systems.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -al ~/docker/bundles/1.12.0/build-deb/*/*.deb
-rw-r--r-- 1 root root 15933554 Jul 31 10:46 /home/pirate/docker/bundles/1.12.0/build-deb/debian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb
-rw-r--r-- 1 root root 15945462 Jul 31 12:28 /home/pirate/docker/bundles/1.12.0/build-deb/raspbian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb
-rw-r--r-- 1 root root 15915910 Jul 31 13:40 /home/pirate/docker/bundles/1.12.0/build-deb/ubuntu-trusty/docker-engine_1.12.0-0~trusty_armhf.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install the Docker Engine on our Raspberry Pi&amp;rsquo;s, we just pick&lt;/p&gt;

&lt;p&gt;&lt;code&gt;raspbian-jessie/docker-engine_1.12.0-0~jessie_armhf.deb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the install process on HypriotOS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get purge -y docker-hypriot
$ sudo dpkg -i docker-engine_1.12.0-0~jessie_armhf.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we do have the latest release version v1.12.0 of the Docker Engine running
on our Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker version
Client:
 Version:      1.12.0
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   e15322b4f
 Built:        Sun Jul 31 11:41:45 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.0
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   e15322b4f
 Built:        Sun Jul 31 11:41:45 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;what-other-build-options-can-be-used:c68665982a08b259934801e30d513d89&#34;&gt;What other build options can be used?&lt;/h3&gt;

&lt;p&gt;Some Raspberry Pi owners such as &lt;a href=&#34;http://blog.alexellis.io/&#34;&gt;Alex Ellis&lt;/a&gt; run Docker on &lt;a href=&#34;http://archlinuxarm.org&#34;&gt;Arch Linux for ARM (ALARM)&lt;/a&gt; or other compatible Linux distributions. For most non-Debian
distributions it makes sense to build a static binary with the below command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/docker
$ time make binary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will find the binary files in the &lt;code&gt;bundles&lt;/code&gt; folder and can then move then to &lt;code&gt;/usr/bin&lt;/code&gt; or &lt;code&gt;/usr/local/bin&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;lessons-learned:c68665982a08b259934801e30d513d89&#34;&gt;Lessons learned&lt;/h3&gt;

&lt;p&gt;With the right Raspberry Pi OS and the Docker Engine already pre-installed, it&amp;rsquo;s
pretty easy and straight forward to build the next version of the Docker Engine
directly and natively on a standard Raspberry Pi.&lt;/p&gt;

&lt;p&gt;I strongly recommend to use the faster Raspberry Pi 3 and a SD card of at least
16 GByte, with a smaller SD card the build will crash after some hours and you
have to start all over again!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please:c68665982a08b259934801e30d513d89&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Edits by &lt;a href=&#34;http://twitter.com/alexellisuk&#34;&gt;Alex Ellis&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swarm Machines or Having fun with Docker Machine and the new Docker Swarm orchestration</title>
      <link>http://blog.hypriot.com/post/swarm-machines-or-having-fun-with-docker-machine-and-the-new-docker-swarm-orchestration/</link>
      <pubDate>Tue, 21 Jun 2016 13:49:00 +0200</pubDate>
      
      <guid>http://blog.hypriot.com/post/swarm-machines-or-having-fun-with-docker-machine-and-the-new-docker-swarm-orchestration/</guid>
      <description>

&lt;p&gt;In the last couple of days there were some users on our Gitter channel having problems accessing their Raspberry Pi&amp;rsquo;s with HypriotOS via Docker Machine.
As we have not yet written how that works I thought I would do a short blog post on how to use Docker Machine with HypriotOS.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not all. Yesterday when I watched the DockerCon Keynote Livestream of the new Docker orchestration I wondered how Docker Machine and the new orchestration would work together.&lt;/p&gt;

&lt;p&gt;So just for the fun of it I decided I will explore that a bit, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/docker-machine/swarm_machines.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;

&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/thewakingdragon/&#34;&gt;Brent M&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;I am using the latest Docker4Mac with Docker on my notebook and three Raspberry Pi&amp;rsquo;s with HypriotOS 0.8 as hosts for my remote Docker Engines.&lt;/p&gt;

&lt;p&gt;The Docker version on the notebook and on the Pi&amp;rsquo;s is 1.12 RC1. Having the lastest Docker 1.12 is not necessary for the part about Docker Machine, but it is for the part about the new Docker orchestration.&lt;/p&gt;

&lt;h2 id=&#34;docker-machine:85b1180b5e32a76ced09e55169dd699d&#34;&gt;Docker Machine&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/machine/&#34;&gt;Docker Machine&lt;/a&gt; is used to control remote Docker-Engines as if they were locally installed.&lt;/p&gt;

&lt;p&gt;That is very convenient in many cases, for instance if you have set up a Docker host with the help of Amazon AWS or Microsoft Azure and you can access it only remotely.
In that case you do not have to establish a SSH connection first in order to work with a specific Docker Engine.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not all - Docker Machine also helps if there is no Docker-Engine present on a remote host.&lt;/p&gt;

&lt;p&gt;With the help of Docker Machine it is very easy to install and configure a new Docker Engine.&lt;/p&gt;

&lt;p&gt;Both in case of an existing or a new Docker Engine Docker Machine reconfigures the Engine to make it availabe via a HTTP network socket.
To ensure that only authorized clients can connect to the remote Docker Engine Docker Machine also sets up everything that is needed for &lt;a href=&#34;https://docs.docker.com/engine/security/https/&#34;&gt;securing the communication with TLS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To remotely manage my Pi&amp;rsquo;s with Docker Machine I first need to copy my SSH public key to the remote host.
If you do not have a SSH key pair you need to &lt;a href=&#34;https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#generating-a-new-ssh-key&#34;&gt;generate one first&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Transfering your public key to a remote host is easily done with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-copy-id pirate@pi3.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command configures the remote host &amp;lsquo;pi3.local&amp;rsquo; in a way that I can access this host via SSH with my default SSH key (~/.ssh/id_rsa).&lt;/p&gt;

&lt;p&gt;We can test this now by executing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pirate@pi3.local ls -lah
total 32K
drwxr-xr-x 3 pirate pirate 4.0K Jun 21 12:01 .
drwxr-xr-x 3 root   root   4.0K May 17 22:43 ..
-rw------- 1 pirate pirate  116 Jun 21 12:01 .bash_history
-rw-r--r-- 1 pirate pirate  220 Oct 18  2014 .bash_logout
-rw-r--r-- 1 pirate pirate 2.5K May 17 22:42 .bash_prompt
-rw-r--r-- 1 pirate pirate  570 May 17 22:42 .bashrc
-rw-r--r-- 1 pirate pirate  314 May 17 22:42 .profile
drwx------ 2 pirate pirate 4.0K Jun 21 12:09 .ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command establishes a SSH connection to the host &amp;lsquo;pi3.local&amp;rsquo; and executes &amp;lsquo;ls -lah&amp;rsquo;. If you can see a similar output everything is OK.&lt;/p&gt;

&lt;p&gt;Next we need to add our &amp;lsquo;pi3.local&amp;rsquo; host to the list of hosts that are managed by Docker Machine.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we already have some existing hosts that are managed by Docker Machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine ls
NAME   ACTIVE   DRIVER    STATE     URL                          SWARM   DOCKER        ERRORS
pi1    -        generic   Running   tcp://192.168.178.171:2376           v1.12.0-rc1
pi2    -        generic   Running   tcp://192.168.178.24:2376            v1.12.0-rc1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And indeed we have two hosts that are already managed by Docker Machine.&lt;/p&gt;

&lt;p&gt;Adding another one is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine create --driver generic --generic-ip-address=192.168.178.59 --generic-ssh-key=/Users/govindaf/.ssh/id_rsa --generic-ssh-user=pirate --engine-storage-driver=overlay pi3
Running pre-create checks...
Creating machine...
(pi3) Importing SSH key...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with debian...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env pi3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output looks good. Let&amp;rsquo;s dissect this command a bit to understand what it does.&lt;/p&gt;

&lt;p&gt;We are using the &amp;lsquo;create&amp;rsquo; subcommand of Docker Machine to create a new host that is managed by Docker Machine.
We are also using the &amp;lsquo;generic&amp;rsquo; driver that allows us to communicate with our Raspberry Pi&amp;rsquo;s via SSH.&lt;/p&gt;

&lt;p&gt;For this we need to tell Docker Machine some SSH connection details like the IP address of our target host, the SSH user and the location of our private SSH key.&lt;/p&gt;

&lt;p&gt;The IP address of our Pi can be easily obtained by running&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping -c1 pi3.local
PING pi3.local (192.168.178.59): 56 data bytes
64 bytes from 192.168.178.59: icmp_seq=0 ttl=64 time=1.926 ms

--- pi3.local ping statistics ---
1 packets transmitted, 1 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 1.926/1.926/1.926/0.000 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is important that we provide the absolute path to our private SSH key with the option &amp;lsquo;generic-ssh-key&amp;rsquo;. A relative path did not work for me.&lt;/p&gt;

&lt;p&gt;Furthermore we need to tell Docker Machine which user it should use for the SSH connection.
The default here is the &amp;lsquo;root&amp;rsquo; user. With HypriotOS we can only use an unprivileged user which is why we need to provide the &amp;lsquo;generic-ssh-user&amp;rsquo; option.&lt;/p&gt;

&lt;p&gt;Last but no least we need to tell Machine to use the &amp;lsquo;overlay&amp;rsquo; filesystem for the configuration of the Docker Engine which is the default with HypriotOS.
Without this option Docker Machine would try to use &amp;lsquo;aufs&amp;rsquo; which would fail miserably.&lt;/p&gt;

&lt;p&gt;Alright, let&amp;rsquo;s see if we now have a third host under our Machine control:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine ls
NAME   ACTIVE   DRIVER    STATE     URL                          SWARM   DOCKER        ERRORS
pi1    -        generic   Running   tcp://192.168.178.171:2376           v1.12.0-rc1
pi3    -        generic   Running   tcp://192.168.178.59:2376            v1.12.0-rc1
pi2    -        generic   Running   tcp://192.168.178.24:2376            v1.12.0-rc1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yeah - we do.&lt;/p&gt;

&lt;p&gt;Sometimes you might get SSH timeout errors when setting up another host with Docker-Machine.
If this is the case make sure you did not forget to set up your SSH public key with the remote host first.&lt;/p&gt;

&lt;p&gt;Sometimes when Docker Machine tries to add a new host it happens that it is stuck halfway with an error.
In those cases the best course of action is often to remove the host first and add it again later.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine rm pi3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s assume all went well and we now have a list of host under remote control. How do you work with those now?&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s were the Docker Machine &amp;lsquo;env&amp;rsquo; subcommand comes into play.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-machine env pi3
export DOCKER_TLS_VERIFY=&amp;quot;1&amp;quot;
export DOCKER_HOST=&amp;quot;tcp://192.168.178.59:2376&amp;quot;
export DOCKER_CERT_PATH=&amp;quot;/Users/govindaf/.docker/machine/machines/pi3&amp;quot;
export DOCKER_MACHINE_NAME=&amp;quot;pi3&amp;quot;
# Run this command to configure your shell:
# eval $(docker-machine env pi3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The env command outputs a bunch of environment variables that control to which Docker instance our local Docker binary is talking to.
Per default the &amp;lsquo;docker&amp;rsquo; command only talks to our local Docker Engine - for instance on our notebook - but by exporting those environment variables this changes fundamentally.&lt;/p&gt;

&lt;p&gt;The easiest way to export the necessary variables is by running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything I do with the &amp;lsquo;docker&amp;rsquo; command runs against the Docker Engine of my &amp;lsquo;pi3&amp;rsquo; host.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check if that is true:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 27
Server Version: 1.12.0-rc1
Storage Driver: overlay
 Backing Filesystem: extfs
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge null host overlay
Swarm: inactive
Runtimes: default
Default Runtime: default
Security Options:
Kernel Version: 4.4.10-hypriotos-v7+
Operating System: Raspbian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 4
Total Memory: 925.4 MiB
Name: pi3
ID: 5DYT:MHTS:4JQK:KNGB:FYZI:EFG4:YIPZ:2WJR:VW5Y:KLPJ:WXCX:S3CG
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
WARNING: No cpuset support
Labels:
 provider=generic
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see with the &amp;lsquo;Name&amp;rsquo; attribute, we are really working on host &amp;lsquo;pi3&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Changing to another host is also easy.&lt;/p&gt;

&lt;p&gt;Just repeat the command from above and replace the hostname with another:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;docker-machine-and-docker-swarm-mode:85b1180b5e32a76ced09e55169dd699d&#34;&gt;Docker Machine and Docker Swarm Mode&lt;/h2&gt;

&lt;p&gt;In the past Docker Machine allowed to set up a Docker Swarm cluster with a &lt;a href=&#34;https://docs.docker.com/machine/reference/create/&#34;&gt;number of options&lt;/a&gt; for the &amp;lsquo;create&amp;rsquo; subcommand.&lt;/p&gt;

&lt;p&gt;With Docker 1.12 we now how a much more powerful version of Swarm that is directly integrated into Docker.
This feature is called Docker Swarm Mode and you can find some inital documentation about it &lt;a href=&#34;https://docs.docker.com/engine/swarm/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I could not find any specifics on how to use it together with Docker Machine. So there might be better ways of how to deal with it than what I am going to show you now.&lt;/p&gt;

&lt;p&gt;Assuming we have three fresh hosts that are managed by Docker Machine, we need to tell Docker to initialize a new Swarm cluster first.&lt;/p&gt;

&lt;p&gt;We can execute the necessary command on any of our hosts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi1)
$ docker swarm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command create a Docker Swarm cluster with one node. This first node automatically becomes a Swarm Manager Node.&lt;/p&gt;

&lt;p&gt;The output of &amp;lsquo;docker info&amp;rsquo; shows us what role our current Docker Engine plays in regard to Swarm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker info
...
Swarm: active
 NodeID: efyap0lxrttld19djs3ygtuac
 IsManager: Yes
 Managers: 1
 Nodes: 1
 CACertHash: sha256:9a29dafb3f6f600b64e8ec7a421fd6386f938de623a3a479ca56229b22a6b680
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also another command that is able to show us which nodes are part of our Swarm cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker node ls
ID                           NAME  MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS
efyap0lxrttld19djs3ygtuac *  pi1   Accepted    Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK. Time to add two more nodes.&lt;/p&gt;

&lt;p&gt;First we need to switch our Docker environment with Docker Machine. Afterwards we join the existing Swarm cluster with the next node.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi2)
$ docker swarm join pi1:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks promising. Let&amp;rsquo;s see what our &amp;lsquo;docker node ls&amp;rsquo; command has to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker node ls
Error response from daemon: this node is not participating as a Swarm manager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s that?&lt;/p&gt;

&lt;p&gt;Obviously we are only able to use the &amp;lsquo;node&amp;rsquo; subcommand from a Swarm Manager node and not from a Swarm Worker node.
So ignoring this for the moment let&amp;rsquo;s add the last node, too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi3)
$ docker swarm join pi1:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s switch back to our original Swarm Manager node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(docker-machine env pi1)
$ docker node ls
ID                           NAME  MEMBERSHIP  STATUS  AVAILABILITY  MANAGER STATUS
3cgg9qfo6nk77zisgrst1333n    pi2   Accepted    Ready   Active
6lezwd8vplgcdmxyhswbc1cvp    pi3   Accepted    Ready   Active
efyap0lxrttld19djs3ygtuac *  pi1   Accepted    Ready   Active        Leader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we have sucessfully set up a Docker Swarm Cluster with three nodes.&lt;/p&gt;

&lt;p&gt;With the help of Docker Machine this was really easy and straightforward as we only had to switch our Docker environment to work on individual nodes.&lt;/p&gt;

&lt;p&gt;So as a last treat for you and to be able to show another screenshot let&amp;rsquo;s start a small webserver in our Swarm cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker service create --name hypriot-httpd -p 8080:80 --replicas 6 hypriot/rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command creates a Docker Swarm service that consists of six running httpd containers that are spread equally across the three nodes of our Swarm cluster.&lt;/p&gt;

&lt;p&gt;Seeing is believing so let&amp;rsquo;s check this again by using the &amp;lsquo;docker service task&amp;rsquo; sub sub command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker service tasks hypriot-httpd
ID                         NAME             SERVICE        IMAGE                      LAST STATE         DESIRED STATE  NODE
14ywlwfix019b95oizce0hgd2  hypriot-httpd.1  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi1
60k55m336zq04rke696m848w1  hypriot-httpd.2  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi3
55sl8zwi1v8om3pvtb0zscf8d  hypriot-httpd.3  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi2
105gbhovh5p3zmwpqaeg3hprd  hypriot-httpd.4  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi3
8her9l13z78g9mjdrkovs9d46  hypriot-httpd.5  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi2
5xwwxuvbwsr7pmomg91cnf08y  hypriot-httpd.6  hypriot-httpd  hypriot/rpi-busybox-httpd  Running 6 minutes  Running        pi1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On a Mac we now can open the website that is served by this service with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ open http://$(docker-machine ip pi1):8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are then rewarded with this neat little website:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/docker-machine/hypriot-http.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Hope this tour was fun and gave you a feeling for the power that comes with Docker Machine.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>More Microservices Bliss with Docker 1.12 and Swarm only</title>
      <link>http://blog.hypriot.com/post/more-microservice-bliss-with-docker-1-12/</link>
      <pubDate>Mon, 20 Jun 2016 21:49:00 +0200</pubDate>
      
      <guid>http://blog.hypriot.com/post/more-microservice-bliss-with-docker-1-12/</guid>
      <description>&lt;p&gt;A couple of days ago I wrote a &lt;a href=&#34;http://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/&#34;&gt;blog post&lt;/a&gt; about how easy it is to get a microservice application up and running with Docker and a HTTP proxy called Traefik.
I explained how awesome Traefik is because it makes complex setups with HAProxy, Registrator, Consul, etc. a thing of the past.&lt;/p&gt;

&lt;p&gt;I really thought it couldn&amp;rsquo;t get much easier. Oh boy - was I wrong!&lt;/p&gt;

&lt;p&gt;Today as part of the Docker opening keynote Docker demostrated an evolution of Docker Swarm that simplifies this whole scenario even more.
It makes setting up a Docker Swarm Cluster a really simple and straigtforward task.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how this new thing works&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/more-microservices/swarm.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;

&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/thewakingdragon/&#34;&gt;Brent M&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;If you remember the example from my last post - it consisted of a microservice application made of a frontend and a couple of backend services.
The frontend was a Traefik HTTP proxy that routed the requests to the backend services.
And the backend for the sake of simplicity was just a simple Go-based HTTP webserver that returned the ID of the containers it was running within.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/traefik/microsservice_example_end.jpg&#34; alt=&#34;Traffic&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The new Docker Swarm removes the need for a separate HTTP proxy in front of our application containers.
The architecture from above is now slimmed down considerably and looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/more-microservices/architecture_with_swarm.jpg&#34; alt=&#34;With Swarm&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Less moving parts - that is great!&lt;/p&gt;

&lt;p&gt;Still we get built-in loadbalancing to our backend services. We even can access those services from every node in our cluster.
Docker Swarm has a kind of built-in mesh routing integrated that takes care of routing requests to the appropriate backend containers.&lt;/p&gt;

&lt;p&gt;With all the new functionality one could assume that setting up a Docker Swarm cluster got even more complicated than before.
But to the contrary - it got much easier - and that by leaps and bounds.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t believe me? Just follow along.&lt;/p&gt;

&lt;p&gt;As you might have guessed, we are doing this on Raspberry Pi cluster again.
I am using a homegrown version of Docker 1.12 that I installed on my Raspberry Pi.
Hopefully when Docker 1.12 is not a release candidate anymore we will have a version for you ready, too.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what we have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker version
Client:
 Version:      1.12.0-rc1
 API version:  1.24
 Go version:   go1.6.2
 Git commit:   1f136c1-unsupported
 Built:        Wed Jun 15 15:35:51 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.0-rc1
 API version:  1.24
 Go version:   go1.6.2
 Git commit:   1f136c1-unsupported
 Built:        Wed Jun 15 15:35:51 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great. Docker 1.12 RC1 is ready. We should have everything we need to get started.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find out if we have same new features hidden in our Docker CLI.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker
Usage: docker [OPTIONS] COMMAND [arg...]
       docker [ --help | -v | --version ]

A self-sufficient runtime for containers.
    ...
    service   Manage Docker services
    ...
    stats     Display a live stream of container(s) resource usage statistics
    ...
    swarm     Manage Docker Swarm
    ...
    update    Update configuration of one or more containers

Run &#39;docker COMMAND --help&#39; for more information on a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I removed the lines of the command output that have not changed compared to the previous release. What remains though is still pretty interesting&amp;hellip;&lt;/p&gt;

&lt;p&gt;We now seem to have a &amp;lsquo;docker swarm&amp;rsquo; command.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what it is all about&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker swarm

Usage:  docker swarm COMMAND

Manage Docker Swarm

Options:
      --help   Print usage

Commands:
  init        Initialize a Swarm.
  join        Join a Swarm as a node and/or manager.
  update      update the Swarm.
  leave       Leave a Swarm.
  inspect     Inspect the Swarm

Run &#39;docker swarm COMMAND --help&#39; for more information on a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &amp;lsquo;Initialize a Swarm.&amp;rsquo; seems to be exactly what we want. Let&amp;rsquo;s start with this one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker swarm init
Swarm initialized: current node (1njlvzi9rk2syv3xojw217o0g) is now a manager.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have a Swarm manger node running it is time to add some more nodes to the cluster.&lt;br /&gt;
And it is really simple as well.&lt;/p&gt;

&lt;p&gt;Just go to another node of your cluster and execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 $ docker swarm join pi6:2377
This node joined a Swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this command we basically just tell new nodes that they should join the Swarm Manager node on which we created the inital Swarm cluster.
In the background Docker Swarm now does some work for us.&lt;/p&gt;

&lt;p&gt;For instance it sets up encrypted communication channels between the cluster nodes. We do not need to manage TLS certificates on our own.&lt;/p&gt;

&lt;p&gt;Everybody who knows how involved it could be to get a Docker Swarm cluster up running in the past should realize how easy it is now.&lt;/p&gt;

&lt;p&gt;Still we are not yet finished.&lt;/p&gt;

&lt;p&gt;A &amp;lsquo;docker info&amp;rsquo; on our Swarm Manager node reveals some interesting tidbits.
Again I removed the uninteresting parts for brevity.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker info
...
Swarm: active
 NodeID: 1njlvzi9rk2syv3xojw217o0g
 IsManager: Yes
 Managers: 1
 Nodes: 2
 CACertHash: sha256:de4e2bff3b63700aad01df97bbe0397f131aabed5fabb7732283f044472323fc
...
Kernel Version: 4.4.10-hypriotos-v7+
Operating System: Raspbian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 4
Total Memory: 925.4 MiB
Name: pi6
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we now have a new &amp;lsquo;Swarm&amp;rsquo; part in the &amp;lsquo;docker info&amp;rsquo; output.
It tells us that our current node is a Swarm Manager node and that the cluster is composed of two cluster nodes in total.&lt;/p&gt;

&lt;p&gt;On our second node it looks a bit different as it is not a Manager node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Swarm: active
 NodeID: 3fmwt4taurwxczr2icboojz8g
 IsManager: No
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Until now we just have an interesting, but still very empty Swarm cluster.
Let&amp;rsquo;s change that.&lt;/p&gt;

&lt;p&gt;Before we start let me introduce you to the concept of a service that is also new abstraction with Docker 1.12.
You might have seen a hint of it already in the output of the Docker command above.
Yes, it is the &amp;lsquo;docker service&amp;rsquo; command that I am talking about.
A Docker service is basically just a bit of software running in a container that offers its &amp;lsquo;service&amp;rsquo; to the outside world and runs on a Swarm cluster.&lt;/p&gt;

&lt;p&gt;Such a service can consist of just one container or of multiple containers.
In the latter case we get high availability and/or loadbalancing for our service out of the box.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create such a service based on our &amp;lsquo;whoami&amp;rsquo; image from my last blog post.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service create --name whoami -p 80:8000 hypriot/rpi-whoami
buy0q65lw7nshm76kvy5imxk3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of the &amp;lsquo;docker swarm ls&amp;rsquo; command we can check the status of our new service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service ls
ID            NAME    SCALE  IMAGE               COMMAND
buy0q65lw7ns  whoami  1      hypriot/rpi-whoami
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check if we can request the index page from our whoami container by sending I http request via curl to the ip of eth0 network interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ curl http://192.168.178.24
I&#39;m 1b6df814c654
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is working. Awesome!&lt;/p&gt;

&lt;p&gt;Those who followed along with keen eyes will have noticed the &amp;lsquo;SCALE&amp;rsquo; part in the header line of the &amp;lsquo;docker swarm ls&amp;rsquo; command.
It seems as we can scale our service somehow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service scale whoami=5
whoami scaled to 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK. Let&amp;rsquo;s check what we have now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker service ls
ID            NAME    SCALE  IMAGE               COMMAND
buy0q65lw7ns  whoami  5      hypriot/rpi-whoami

root@pi6 $ for i in {1..5}; do curl http://192.168.178.24; done
I&#39;m 8db1657e8517
I&#39;m e1863a2be88d
I&#39;m 1b6df814c654
I&#39;m 8db1657e8517
I&#39;m e1863a2be88d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty neat.&lt;/p&gt;

&lt;p&gt;But this is not just way more simple than the old Swarm, it also feels much more snappier and faster when executing commands.
And remember I am working on Raspberry Pi&amp;rsquo;s and not on a beefy server like you would propably work on.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how this looks from the perspective of an individual Docker engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi6 $ docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
e1863a2be88d        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             2 minutes ago       Up 2 minutes        8000/tcp            whoami.4.0lg12zndbal72exqe08r9wvpg
8db1657e8517        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             2 minutes ago       Up 2 minutes        8000/tcp            whoami.5.5z6mvsrdy73m5w24icgsqc8i2
1b6df814c654        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.1.bg4qlpiye6h6uxyf8cmkwuh52
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see from the five containers that were started three reside on &amp;lsquo;pi6&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see if we can find the rest:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
db411a119c0a        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             6 minutes ago       Up 6 minutes        8000/tcp            whoami.2.2tf7yhmx9haol7e2b7xib2emj
0a4bf32fa9c4        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             6 minutes ago       Up 6 minutes        8000/tcp            whoami.3.2r6mm091c2ybr0f9jz4qaxw9k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what happens when I just leave the Swarm cluster on &amp;lsquo;pi1&amp;rsquo;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@pi1 docker swarm leave
Node left the default swarm.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I should be two containers short, right?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what we have on our remaining node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps
CONTAINER ID        IMAGE                       COMMAND             CREATED             STATUS              PORTS               NAMES
58620e3d533c        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             46 seconds ago      Up 43 seconds       8000/tcp            whoami.2.cgc4e2ixulc2f3ehr4laoursg
acc9b523f434        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             46 seconds ago      Up 43 seconds       8000/tcp            whoami.3.67bhlo3nwgehthi3bg5bfdzue
e1863a2be88d        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.4.0lg12zndbal72exqe08r9wvpg
8db1657e8517        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             8 minutes ago       Up 8 minutes        8000/tcp            whoami.5.5z6mvsrdy73m5w24icgsqc8i2
1b6df814c654        hypriot/rpi-whoami:latest   &amp;quot;/http&amp;quot;             15 minutes ago      Up 14 minutes       8000/tcp            whoami.1.bg4qlpiye6h6uxyf8cmkwuh52
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we witnessed here is the same what would have happened if we just had a failing &amp;lsquo;pi1&amp;rsquo; node.
All the containers that were running on node &amp;lsquo;pi1&amp;rsquo; were migrated to the remaining cluster nodes automatically.
That&amp;rsquo;s pretty impressive.&lt;/p&gt;

&lt;p&gt;So to recap what we just did:&lt;br /&gt;
We created a small dynamic microservice applications with just the plain Docker.
Docker Swarm is now integrated into the Docker-Engine instead of being a separate piece of software.
In many cases this makes a separate proxy for the backend services of your application obsolete. No more nginx, HAProxy or Traefik. Sorry to see you go&amp;hellip;&lt;/p&gt;

&lt;p&gt;Despite having fewer moving parts we now have additional load balancing and high availability features built-in.
I am really looking forward to find out what else there is in store with the new Docker Swarm and how it works together with Docker Compose.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s a story for another day&amp;hellip;&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker was well received at Germany&#39;s biggest Raspberry Pi Jam</title>
      <link>http://blog.hypriot.com/post/docker-was-well-received-at-piandmore/</link>
      <pubDate>Mon, 13 Jun 2016 09:21:00 +0000</pubDate>
      
      <guid>http://blog.hypriot.com/post/docker-was-well-received-at-piandmore/</guid>
      <description>

&lt;p&gt;Last Saturday Germany&amp;rsquo;s biggest Raspberry Pi community event - &lt;a href=&#34;http://piandmore.de/en&#34;&gt;the PiAndMore&lt;/a&gt; - took place for the 9th time.&lt;/p&gt;

&lt;p&gt;In cooperation with the University of Trier the organizers were able to provide a broad range of activities.
There were talks, workshops and many interesting tinker projects at display to delight even the most demanding maker heart.&lt;/p&gt;

&lt;p&gt;It comes as no suprise that Docker was a hot topic at the PiAndMore conference, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/piandmore/piandmore_loves_docker.jpg&#34; alt=&#34;PiAndMore&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;docker-and-the-raspberry-pi-a-dream-team:ce44e480ae6cb7c6d49829357f2a0d42&#34;&gt;Docker and the Raspberry Pi - a dream team?&lt;/h2&gt;

&lt;p&gt;The Docker Pirates were invited to give a talk about &lt;a href=&#34;http://www.slideshare.net/GovindaFichtner/docker-and-raspberry-pi-a-dream-team&#34;&gt;Docker on the Raspberry Pi&lt;/a&gt;.&lt;br /&gt;
Despite being one of the first talks at nine o&amp;rsquo;clock in the morning it was well visited.&lt;/p&gt;

&lt;p&gt;After some inital technical problems with the local power supply, network and beamer (yeah - all three!) the talk went well.&lt;/p&gt;

&lt;p&gt;I started by giving a short introduction to Docker and finished with a live demo on our 5 node Pico-Cluster.
Starting with some basic Docker Fu the demo soon gathered speed and I showed how to use Docker Compose and Swarm to get a
two tiered microservice architecture up and running in less then 5 minutes.&lt;/p&gt;

&lt;p&gt;Here is a recording of the talk made by &lt;a href=&#34;https://call-a-tux.de/&#34;&gt;Call-a-Tux&lt;/a&gt;:
&lt;iframe id=&#34;ytplayer&#34; type=&#34;text/html&#34; width=&#34;1000&#34; height=&#34;560&#34; src=&#34;http://www.youtube.com/embed/9xAkILSdlxE&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;docker-workshop:ce44e480ae6cb7c6d49829357f2a0d42&#34;&gt;Docker Workshop&lt;/h2&gt;

&lt;p&gt;It seems the talk was able to whet the appetite of the audience as many joined the two hour workshop later.
Soon all seats were taken and the attendees embarked on a whirlwind tour through HypriotOS and Docker.&lt;/p&gt;

&lt;p&gt;Thanks to &lt;a href=&#34;http://blog.hypriot.com/post/hypriotos-barbossa-for-raspberry-pi-3/&#34;&gt;HypriotOS&lt;/a&gt; and our convenient &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; everybody was able to start with Docker in no time.&lt;br /&gt;
After learning the basic Docker commands everybody started to feel like a real Docker Pirate.&lt;/p&gt;

&lt;p&gt;From there it was mostly smooth sailing and we even started to manage our containers with Docker Compose and Swarm.&lt;/p&gt;

&lt;p&gt;In the end the workshop was rounded off by an excursion into the realm of Dockerfiles and how to build our own Docker images.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/piandmore/workshop.jpg&#34; alt=&#34;PiAndMore&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;It was really nice to see so many people get excited about Docker and ask so many curious questions.
Later when I walked through the exhibition part of the conference I even learned that many people came to PiAndMore specifically because of the Docker talk and workshop.&lt;/p&gt;

&lt;p&gt;All in all it was awesome being at the PiAndMore conference.
It was really well organized and had a very nice nerdy feel about it.
Actually I had a really hard time to pry my colleague Andreas from the event when we finally had to leave to drive home.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/piandmore/organizers_docker_pirates.jpg&#34; alt=&#34;PiAndMore Having fun&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So if you happen to be near Trier next year when the next PiAndMore takes place make sure to pay them a visit.
It is most certainly worth it!&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Microservices Bliss with Docker and Traefik</title>
      <link>http://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/</link>
      <pubDate>Tue, 07 Jun 2016 09:15:00 +0000</pubDate>
      
      <guid>http://blog.hypriot.com/post/microservices-bliss-with-docker-and-traefik/</guid>
      <description>

&lt;p&gt;A couple of weeks ago I found this really nice and neat HTTP reverse proxy called &lt;a href=&#34;https://docs.traefik.io/&#34;&gt;Traefik&lt;/a&gt;.
It is meant to act as frontend proxy for microservices that are provided by a dynamic backend like Docker.&lt;/p&gt;

&lt;p&gt;Did you realize the important part of the last sentence was &lt;strong&gt;dynamic&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;What makes Traefik really special is its ability of adding and removing container backend services by listening to Docker events.
So whenever a Docker container is started or stopped Traefik knows about it and adds the container to its list of active backend services.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/traefik/architecture.png&#34; alt=&#34;Traffic&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;With this ability Traefik can replace much more complicated setups based on Nginx or HAProxy that have to use additional tools like
&lt;a href=&#34;https://github.com/gliderlabs/registrator&#34;&gt;Registrator&lt;/a&gt;, &lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt; and &lt;a href=&#34;https://github.com/hashicorp/consul-template&#34;&gt;Consul-Template&lt;/a&gt; to achieve the same kind of functionality.&lt;/p&gt;

&lt;p&gt;So let me show you with a simple microservice example how easy it is to get started with Traefik&amp;hellip;&lt;/p&gt;

&lt;p&gt;As you can see in the following architecture overview we will have a simple HTTP service that answers incoming HTTP requests.&lt;/p&gt;

&lt;p&gt;We have multiple backend services that are running on different physical nodes for high availability and loadbalancing reasons.
Traefik serves as a frontend proxy that loadbalances incoming requests to the available backend services.&lt;/p&gt;

&lt;p&gt;Traefik as well as the backend services will run on top of a Docker Swarm cluster as containers.
In this example each backend service will answer with their individual container ID to make it easy to see which one answered.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/traefik/microsservice_example_end.jpg&#34; alt=&#34;Traffic&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So to get started we need a running Docker Swarm Cluster first.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-docker-swarm-cluster:eaccea7a352d1344b842649dc78262ad&#34;&gt;Creating a Docker Swarm Cluster&lt;/h2&gt;

&lt;p&gt;One of fastest and easiest ways to get a Docker Swarm cluster running is to use our &lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;Hypriot Cluster Lab&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As the Cluster Lab comes already preinstalled with out latest HypriotOS &amp;ldquo;Barbossa&amp;rdquo; release for the Raspberr Pi I will show you how to set up a Swarm Cluster with that.&lt;/p&gt;

&lt;p&gt;To follow along you will need at least three Raspberry Pi&amp;rsquo;s. I will use my Pico-Cluster with five nodes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/traefik/picocluster.jpg&#34; alt=&#34;Traffic&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The first step is flashing the necessary SD card images with HypriotOS.&lt;/p&gt;

&lt;p&gt;Clone the Hypriot flash repository and change into the appropriate folder for the operating system you are using to flash the SD cards.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/hypriot/flash.gi://github.com/hypriot/flash.git
$ cd flash/Darwin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the flash tool ready we now can prepare the SD card for our &lt;strong&gt;leader node&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./flash --hostname cl-leader https://downloads.hypriot.com/hypriotos-rpi-v0.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeat the process for the &lt;strong&gt;follower nodes&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for i in {1..4} do; ./flash --hostname cl-follower${i} https://downloads.hypriot.com/hypriotos-rpi-v0.8.0.img.zip; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the SD cards for the follower nodes are still being flashed you can already start the leader node.&lt;/p&gt;

&lt;p&gt;SSH into the leader and become root user:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pirate@cl-leader.local
$ sudo su
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make the Cluster Lab work with Traefik we need to update to the most recent version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get update
$ apt-get install hypriot-cluster-lab=0.2.13-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then start the Hypriot Cluster Lab with verbose output logging enabled:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ VERBOSE=true cluster-lab start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the Cluster Lab starts you can see how it configures itself and does a number of self-tests.
If not all steps are green stop it and start it again. If that fails, too, have a look at our &lt;a href=&#34;https://github.com/hypriot/cluster-lab#troubleshooting&#34;&gt;troubleshooting section&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After the leader node is ready, it is time to boot the rest of our nodes and update and start the Cluster Lab in the same fashion.
So go ahead and come back when your are done.&lt;/p&gt;

&lt;p&gt;Allright, We can now check if we really have a healthy five nodes Swarm Cluster by executing the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DOCKER_HOST=tcp://192.168.200.1:2378 docker info | grep Nodes
Nodes: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And voila we now really have five nodes in our cluster.
Congrats!&lt;/p&gt;

&lt;p&gt;As you made it so far the rest will be a piece of a cake!&lt;/p&gt;

&lt;h3 id=&#34;setting-up-our-microservice-app-with-traefik:eaccea7a352d1344b842649dc78262ad&#34;&gt;Setting up our microservice app with Traefik&lt;/h3&gt;

&lt;p&gt;Our example microservice application consists of two parts. The Traefik frontend and the WhoAmI application backend.
For both parts I have prepared images for you that can be pulled from the Docker Hub.&lt;/p&gt;

&lt;p&gt;The Traefik image is called &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-traefik/&#34;&gt;hypriot/rpi-traefik&lt;/a&gt; and the WhoAmI image is called &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-whoami/&#34;&gt;hypriot/rpi-whoami&lt;/a&gt;.
The Dockerfiles for both images can be found on Github in the &lt;a href=&#34;https://github.com/hypriot&#34;&gt;related repositories&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because both Dockerfiles are a fine example of how easy it is to create Docker images for Golang based software I will
show them here, too.&lt;/p&gt;

&lt;p&gt;Dockerfile for &amp;ldquo;rpi-traefik&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM hypriot/rpi-alpine-scratch
RUN apk update &amp;amp;&amp;amp;\
    apk upgrade &amp;amp;&amp;amp;\
    apk add ca-certificates &amp;amp;&amp;amp;\
    rm -rf /var/cache/apk/*
ADD https://github.com/containous/traefik/releases/download/v1.0.0-beta.771/traefik_linux-arm /traefik
RUN chmod +x /traefik
EXPOSE 80 8080
ENTRYPOINT [&amp;quot;/traefik&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we just add the Traefik binary on top of an Alpine linux image. The result is an image that is already quite small with about 41 MB.
It propably could be made even smaller by ensuring that the Traefik binary is compiled as a static binary and then putting it into an empty scratch image.&lt;/p&gt;

&lt;p&gt;You can see how this can be done with the next Dockerfile for the WhoAmI image:&lt;/p&gt;

&lt;p&gt;Dockerfile for &amp;ldquo;rpi-whoami&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM scratch

ADD http /http

ENV PORT 8000
EXPOSE 8000

CMD [&amp;quot;/http&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With about 3 MB the resulting image is really small.&lt;/p&gt;

&lt;p&gt;Well, now it is time to put this all together in a Docker Compose application.&lt;/p&gt;

&lt;p&gt;Clone the following repository on you cluster leader:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/hypriot/rpi-cluster-lab-demos
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the cloning is finished change into the &amp;lsquo;traefik&amp;rsquo; folder and use Docker Compose to start our application on top of our little Docker Swarm cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd rpi-cluster-lab-demos/traefik
$ DOCKER_HOST=tcp://192.168.200.1:2378 docker-compose up -d
Creating network &amp;quot;traefik_default&amp;quot; with the default driver
Creating traefik_traefik_1
Creating traefik_whoami_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this command Docker Compose should start two containers.
One Traefik container on our leader and one WhoAmi container on one of our follower nodes.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check if that really happened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOCKER_HOST=tcp://192.168.200.1:2378 docker ps | grep &#39;traefik\|whoami&#39;
cba8d9a7d8f7        hypriot/rpi-whoami         &amp;quot;/http&amp;quot;                  About a minute ago   Up About a minute   8000/tcp                                                 cl-follower1/traefik_whoami_1
7dc2b48a24e2        hypriot/rpi-traefik        &amp;quot;/traefik --web --doc&amp;quot;   About a minute ago   Up About a minute   192.168.200.1:80-&amp;gt;80/tcp, 192.168.200.1:8080-&amp;gt;8080/tcp   cl-leader/traefik_traefik_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks good. So let&amp;rsquo;s test our application by flinging some HTTP request towards our frontend:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for i in {1..5}; do curl -H Host:whoami.docker.localhost http://192.168.200.1; done
I&#39;am f72892c9187c
I&#39;am f72892c9187c
I&#39;am f72892c9187c
I&#39;am f72892c9187c
I&#39;am f72892c9187c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see it is always the same backend container which is responding and that&amp;rsquo;s just as it should be.&lt;/p&gt;

&lt;p&gt;Next we are going to increase the number of backend containers with the help of Docker Compose scale command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOCKER_HOST=tcp://192.168.200.1:2378 docker-compose scale whoami=5
Creating and starting traefik_whoami_2 ... done
Creating and starting traefik_whoami_3 ... done
Creating and starting traefik_whoami_4 ... done
Creating and starting traefik_whoami_5 ... done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can watch as Docker Compose tells Docker Swarm to spin up more containers.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s verify again if we now have five backend containers running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ for i in {1..5}; do curl -H Host:whoami.docker.localhost http://192.168.200.1; done
I&#39;m 5d829fecbdaa
I&#39;m 5eb115353885
I&#39;m e0313ac24554
I&#39;m 642b5d2c8d09
I&#39;m f72892c9187c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perfect. Obviously Traefik did recognise that we started more containers and made them available to the frontend automatically.&lt;/p&gt;

&lt;p&gt;We can see what happened by looking at the logs of the Traefik container:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOCKER_HOST=tcp://192.168.200.1:2378 docker-compose logs traefik
...
traefik_1  | time=&amp;quot;2016-06-07T06:50:38Z&amp;quot; level=debug msg=&amp;quot;Configuration received from provider docker: {\&amp;quot;backends\&amp;quot;:{\&amp;quot;backend-whoami\&amp;quot;:{\&amp;quot;servers\&amp;quot;:{\&amp;quot;server-traefik_whoami_1\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.3:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1},\&amp;quot;server-traefik_whoami_2\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.5:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1},\&amp;quot;server-traefik_whoami_3\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.6:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1},\&amp;quot;server-traefik_whoami_4\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.4:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1},\&amp;quot;server-traefik_whoami_5\&amp;quot;:{\&amp;quot;url\&amp;quot;:\&amp;quot;http://10.0.0.7:8000\&amp;quot;,\&amp;quot;weight\&amp;quot;:1}}}},\&amp;quot;frontends\&amp;quot;:{\&amp;quot;frontend-Host-whoami-docker-localhost\&amp;quot;:{\&amp;quot;backend\&amp;quot;:\&amp;quot;backend-whoami\&amp;quot;,\&amp;quot;routes\&amp;quot;:{\&amp;quot;route-frontend-Host-whoami-docker-localhost\&amp;quot;:{\&amp;quot;rule\&amp;quot;:\&amp;quot;Host:whoami.docker.localhost\&amp;quot;}},\&amp;quot;passHostHeader\&amp;quot;:true}}}&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:38Z&amp;quot; level=debug msg=&amp;quot;Last docker config received less than 2s, waiting...&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Waited for docker config, OK&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating frontend frontend-Host-whoami-docker-localhost&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Wiring frontend frontend-Host-whoami-docker-localhost to entryPoint http&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating route route-frontend-Host-whoami-docker-localhost Host:whoami.docker.localhost&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating backend backend-whoami&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating load-balancer wrr&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_4 at http://10.0.0.4:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_3 at http://10.0.0.6:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_2 at http://10.0.0.5:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_1 at http://10.0.0.3:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=debug msg=&amp;quot;Creating server server-traefik_whoami_5 at http://10.0.0.7:8000 with weight 1&amp;quot;
traefik_1  | time=&amp;quot;2016-06-07T06:50:40Z&amp;quot; level=info msg=&amp;quot;Server configuration reloaded on :80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the logs we can now clearly see how Traefik catched the Docker event and how it reacted.&lt;/p&gt;

&lt;p&gt;Isnt&amp;rsquo; awesome?&lt;/p&gt;

&lt;p&gt;OK. So this was basically our quick tour on how to do set up a simple microservice example with Docker and Traefik.&lt;/p&gt;

&lt;p&gt;The only thing that is left for us now is to clean up again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ DOCKER_HOST=tcp://192.168.200.1:2378 docker-compose down -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Did you notice the &amp;lsquo;-v&amp;rsquo; option? This seems to be really important as it cleans up all the containers including the overlay network that was created for us.
Without the &amp;lsquo;-v&amp;rsquo; option we would get an error the next time we start the application again with Docker Compose.&lt;/p&gt;

&lt;p&gt;It is also a good idea to stop the Cluster Lab on all nodes before you switch of your Raspberry Pi&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;So do a&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cluster-lab stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;on all your cluster nodes.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s just amazing how many interesting technologies we used in this small blog post.
And it wasn&amp;rsquo;t to hard to get them running together, wasn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;That is mostly due to the work the &lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;Hypriot Cluster Lab&lt;/a&gt; does for us and of course under the hood it is the Docker-Engine, Docker-Swarm and Docker-Compose that let&amp;rsquo;s us do so much with so little effort.&lt;/p&gt;

&lt;p&gt;So make sure to give our Hypriot Cluster Lab a spin and try some of the examples in our &lt;a href=&#34;https://github.com/hypriot/rpi-cluster-lab-demos&#34;&gt;Hypriot Cluster Lab Demos&lt;/a&gt; repository or add some of your own. Pull requests are always welcome.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Making of HypriotOS</title>
      <link>http://blog.hypriot.com/post/making-of-hypriotos/</link>
      <pubDate>Wed, 25 May 2016 18:03:32 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/making-of-hypriotos/</guid>
      <description>

&lt;p&gt;Today we have released a new version of HypriotOS &amp;ldquo;Barbossa&amp;rdquo; - the SD card image with a ready-to-go Docker toolset for all Raspberry Pi&amp;rsquo;s. Beginning with this release we have &lt;strong&gt;open sourced every step&lt;/strong&gt; to build each parts, from the kernel and root filesystem up to the SD card image.&lt;/p&gt;

&lt;p&gt;We have also moved every build step out in the cloud to use the &amp;ldquo;programmable internet&amp;rdquo; to build and test everything with just a &lt;strong&gt;git push&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/making-of-hypriotos/hypriotos-release.png&#34; alt=&#34;release process&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This diagram above shows the release process of a new SD card image for any of the new HypriotOS supported ARM boards. We have moved all building steps to Cloud services. This helps us all to build any SD card without the need to have the specific ARM board. And this also &lt;strong&gt;enables the community to contribute&lt;/strong&gt; to all our repos with pull requests.&lt;/p&gt;

&lt;h2 id=&#34;ci-driven-builds:ce95f1b761ab1b4f8ebf52d516170ec1&#34;&gt;CI driven builds&lt;/h2&gt;

&lt;p&gt;To build the SD card images in the Cloud we have chosen a mixture of &lt;strong&gt;Travis CI&lt;/strong&gt; and &lt;strong&gt;CircleCI&lt;/strong&gt; as the Docker support fits our needs. Only where we need ARM servers to built natively we have our own &lt;strong&gt;Drone&lt;/strong&gt; and &lt;strong&gt;Jenkins&lt;/strong&gt; servers running on Scaleway C1 servers.&lt;/p&gt;

&lt;p&gt;The build process downloads some other artifacts like the root filesystem for the specific ARM CPU type and installs further DEB packages like the &lt;strong&gt;Linux kernel&lt;/strong&gt;, the &lt;strong&gt;Docker Engine&lt;/strong&gt; and &lt;strong&gt;Docker Compose&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;After each build Travis also runs &lt;strong&gt;Serverspec&lt;/strong&gt; tests against the SD card image to have a minimal test of the generated output.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/making-of-hypriotos/travis-serverspec-tests.png&#34; alt=&#34;travis serverspec tests&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;When we trigger a release build, Travis deploys the newly generated SD card image to the &lt;strong&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases&#34;&gt;GitHub releases&lt;/a&gt;&lt;/strong&gt; page. You can find releases, as well as pre-releases of upcoming versions there.&lt;/p&gt;

&lt;h2 id=&#34;join-the-movement:ce95f1b761ab1b4f8ebf52d516170ec1&#34;&gt;Join the movement&lt;/h2&gt;

&lt;p&gt;The advantage of open sourcing is that the community can give us feedback and sometimes even start contributing back. The SD card image can be built locally on your Linux or Mac notebook as well. So you also are able to build a SD card image without having the device.&lt;/p&gt;

&lt;p&gt;As we love Docker the build process runs in a Docker Container. This simplifies the setup on your local machine. Each GitHub repository has a README with the steps needed to build and test the specific HypriotOS SD card image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/making-of-hypriotos/hypriotos-local-build.png&#34; alt=&#34;local build&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The normal workflow looks like this&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone&lt;/code&gt; - get the repo you want to build&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make docker-machine&lt;/code&gt; - create a local VM with Docker&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make sd-image&lt;/code&gt; - build the SD card image within a Docker Container&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flash sd-card*.zip&lt;/code&gt; - flash the new SD card image and boot your ARM device.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOARD=ip make test-integration&lt;/code&gt; - run Serverspec tests if everything is fine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have added over &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/tree/master/builder/test-integration/spec&#34;&gt;200 Serverspec tests&lt;/a&gt; to ensure the Docker tools, Kernel and additional packages are installed correctly. You can even run these tests for the latest release to check if it is working for you as well.
This enables everyone to make changes to the code base and send us Pull Requests without breaking other parts.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Pull Requests&lt;/strong&gt; are tested with &lt;strong&gt;Travis CI&lt;/strong&gt; of course, so we can see if it works well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/making-of-hypriotos/github-pr-success.png&#34; alt=&#34;pull request successful&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As there are several GitHub repositories involved to build the SD card image we use &lt;strong&gt;Waffle.io&lt;/strong&gt; to have and overview of all issues, pull requests and tasks to do for a release.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/making-of-hypriotos/waffle.png&#34; alt=&#34;waffle board&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;what-s-next:ce95f1b761ab1b4f8ebf52d516170ec1&#34;&gt;What&amp;rsquo;s next&lt;/h2&gt;

&lt;p&gt;We also started to add more boards and created new GitHub repos for each. But we focused on the Raspberry Pi to finish the &amp;ldquo;Barbossa&amp;rdquo; release. Here is a list of boards we have started to support:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;Raspberry Pi Zero, 1, 2, 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-c1&#34;&gt;ODROID C1/C1+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-xu4&#34;&gt;ODROID XU3/XU4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-c2&#34;&gt;ODROID C2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-bananapi&#34;&gt;Banana Pi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-nvidia-shieldtv&#34;&gt;NVIDIA ShieldTV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pine A64, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will pick one of these boards next to add all features of &amp;ldquo;Barbossa&amp;rdquo; to have a great Docker experience with it.
The other boards are still a work in progress - any help is welcome from the community!&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HypriotOS 0.8.0 Barbossa for Raspberry Pi 3</title>
      <link>http://blog.hypriot.com/post/hypriotos-barbossa-for-raspberry-pi-3/</link>
      <pubDate>Wed, 25 May 2016 03:30:00 +0000</pubDate>
      
      <guid>http://blog.hypriot.com/post/hypriotos-barbossa-for-raspberry-pi-3/</guid>
      <description>

&lt;p&gt;While it is quite hard to make something better that is already good, we feel that we were able to just do that with our latest release of HypriotOS.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS is the easiest and fastest way to get you started with Docker on ARM and IoT devices.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It is the perfect playground for your first steps with Docker and it allows you to move to advanced stuff like Docker Clustering without breaking a sweat, too.&lt;/p&gt;

&lt;p&gt;This is possible because we included a lot of the tools that make the Docker ecosystem awesome - for instance Docker Compose or Docker Swarm - out of the box.
We also integrated the Hypriot Cluster-Lab into this release, which makes it really easy and painless to set up complex Docker Clusters.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s just the tip of the iceberg. So read on to get all the glory details of this new release &amp;hellip; :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/hypriotos-barbossa/iceberg.jpg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;

&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/davidw/&#34;&gt;David&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;features-at-a-glance:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Features at a glance&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;support for Raspberry Pi Zero, 1, 2 and 3&lt;/li&gt;
&lt;li&gt;Linux kernel 4.4.10&lt;/li&gt;
&lt;li&gt;Docker Engine 1.11.1&lt;/li&gt;
&lt;li&gt;Docker Compose 1.7.1&lt;/li&gt;
&lt;li&gt;Docker Machine 0.7.0&lt;/li&gt;
&lt;li&gt;Docker Swarm 1.2.2&lt;/li&gt;
&lt;li&gt;Cluster-Lab 0.2.12&lt;/li&gt;
&lt;li&gt;device-init 0.1.7&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;updated-docker-and-docker-tools:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Updated Docker and Docker-Tools&lt;/h2&gt;

&lt;p&gt;Compared to our latest HypriotOS Berry 0.7 we did upgrade the Docker Engine to v1.11 which now has several binaries instead of one.
Besides the original Docker binary there is now also a Containerd and a runC binary. Containerd is basically a supervisor for individual containers that are run by runC.&lt;/p&gt;

&lt;p&gt;The main reasons for splitting up the Docker binary were the efforts of Docker to support the &lt;a href=&#34;https://www.opencontainers.org/&#34;&gt;standardization of container technology&lt;/a&gt; and to make it easier to maintain the existing technology stack.
You can get a good overview about these changes in the &lt;a href=&#34;https://blog.docker.com/2016/04/docker-engine-1-11-runc/&#34;&gt;blog post&lt;/a&gt; announcing the release of Docker 1.11.&lt;/p&gt;

&lt;p&gt;And there is also a very interesting deep dive into the details of those changes:&lt;/p&gt;

&lt;iframe id=&#34;ytplayer&#34; type=&#34;text/html&#34; width=&#34;1000&#34; height=&#34;560&#34; src=&#34;http://www.youtube.com/embed/QL8F2MLCybo&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;full-raspberry-pi-3-support:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Full Raspberry Pi 3 Support&lt;/h2&gt;

&lt;p&gt;Noteworthy is also that we now have full support for the Raspberry Pi 3.&lt;/p&gt;

&lt;p&gt;With the help of our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash-tool&lt;/a&gt; it is really easy to bring a Raspberry Pi 3 online with only WiFi network connectivity:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --ssid MyNetworkName --password SomeSecret https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.0/hypriotos-rpi-v0.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that you can usually connect to your Pi by:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The password is &amp;lsquo;hypriot&amp;rsquo;. And that&amp;rsquo;s it.&lt;/p&gt;

&lt;p&gt;By the way this also works if you attach an external WiFi adapter to a Raspberry Pi Zero, 1 and 2.&lt;/p&gt;

&lt;h2 id=&#34;customizing-your-raspberry-pi-configuration:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Customizing your Raspberry Pi Configuration&lt;/h2&gt;

&lt;p&gt;The ability to customize the hostname of your Pi, to add WiFi credentials and more is made possible by a small tool of ours called &lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;device-init&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In previous versions we used a tool called &lt;a href=&#34;https://github.com/adafruit/Adafruit-Occi&#34;&gt;occi&lt;/a&gt; from Adafruit to allow hostname and WiFi customization.&lt;/p&gt;

&lt;p&gt;In this release we removed it and replaced it with device-init.&lt;/p&gt;

&lt;p&gt;device-init is a small programm that is started when your Raspberry Pi boots and it allows to customize a couple of settings.
It takes its configuration from a file called &amp;lsquo;device-init.yaml&amp;rsquo; which is located in the /boot directory.&lt;/p&gt;

&lt;p&gt;This /boot directory is basically a small FAT partition on the SD card that contains HypriotOS.
It can be easily accessed from your host computer before you boot your Pi. You can edit the &amp;lsquo;device-init.yaml&amp;rsquo; file directly with a text editor or by using the flash tool as demonstrated above.&lt;/p&gt;

&lt;p&gt;We are going to add more features - like adding public ssh keys, setting the locale or timezone - to device-init step by step in the next weeks.&lt;/p&gt;

&lt;h2 id=&#34;hypriot-cluster-lab:77d190f6290bd80a7b0b949a77766fb9&#34;&gt;Hypriot Cluster-Lab&lt;/h2&gt;

&lt;p&gt;We added the Hypriot Cluster-Lab to the image, too.&lt;/p&gt;

&lt;p&gt;It is disabled by default, but can easily be enabled when you flash the image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --clusterlab true https://github.com/hypriot/image-builder-rpi/releases/download/v0.8.0/hypriotos-rpi-v0.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setting this options starts the Cluster-Lab on boot.&lt;/p&gt;

&lt;p&gt;By flashing a couple of SD cards with different hostnames and Cluster-Lab enabled you can get a fully working Docker Swarm cluster up and running in minutes.
The individual machines will find themselves automatically and form a Swarm cluster.&lt;/p&gt;

&lt;p&gt;You can read more about the Hypriot Cluster-Lab and why it is awesome on &lt;a href=&#34;https://github.com/hypriot/cluster-lab/&#34;&gt;its website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can download the new release in our &lt;a href=&#34;http://blog.hypriot.com/downloads&#34;&gt;download section&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you encounter any problems with this new release please open up issues in one of the following repositories:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;https://github.com/hypriot/image-builder-rpi&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;https://github.com/hypriot/cluster-lab&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/device-init&#34;&gt;https://github.com/hypriot/device-init&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;https://github.com/hypriot/flash&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There is also our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter-Chat&lt;/a&gt; were you&amp;rsquo;ll find a very friendly community that always likes to help.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share the news about this release on Twitter, Facebook or Google+.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Close Encounters of the Third Kind, or Microsoft Windows meets Docker ARM Containers for IoT</title>
      <link>http://blog.hypriot.com/post/close-encounters-of-the-third-kind/</link>
      <pubDate>Tue, 29 Mar 2016 17:20:34 +0200</pubDate>
      
      <guid>http://blog.hypriot.com/post/close-encounters-of-the-third-kind/</guid>
      <description>

&lt;p&gt;Running an ARM-based Docker container for IoT applications directly on Microsoft Windows
looks like an unbelievable &lt;strong&gt;extraterrestrial technology&lt;/strong&gt; from outer space.&lt;/p&gt;

&lt;p&gt;This cannot be true, it must be a fake, right?&lt;br /&gt;
Or, is this maybe just a &lt;strong&gt;cheap magic trick&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/close-encounters-of-the-third-kind/docker4win-arm-webpage.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Nope, believe me, that&amp;rsquo;s really true&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;behind-the-scenes:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Behind the scenes&lt;/h2&gt;

&lt;p&gt;As I showed in my last blog post about the &lt;a href=&#34;http://blog.hypriot.com/post/first-touch-down-with-docker-for-mac/&#34;&gt;First Touch Down with Docker for Mac&lt;/a&gt;,
&amp;ldquo;Docker for Mac&amp;rdquo; uses an Alpine Linux VM under the hood with the capability of emulating
ARM binaries on Intel CPUs. Because of &amp;ldquo;Docker for Windows&amp;rdquo; uses exactly the same
Alpine Linux in a Hyper-V virtual machine, this should work on Windows 10, too.&lt;/p&gt;

&lt;p&gt;The only problem here is, that the bind-mounting of a single binary doesn&amp;rsquo;t work
right now on Windows. I guess this will be fixed in a later release for sure. But
we can easily prepare an ARM-based Docker container to make the magic happen.&lt;/p&gt;

&lt;p&gt;We just have to put the &lt;a href=&#34;https://en.wikipedia.org/wiki/QEMU&#34;&gt;QEMU&lt;/a&gt; emulator binary
into the Docker container, and as long as we
place it at the correct path &lt;code&gt;/usr/bin/qemu-arm-static&lt;/code&gt;, this should work. The easiest
way to include the binary to the correct folder is to create a tar archive and use
the ADD command in the Dockerfile.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar vtf qemu-arm-static.tar
drwxr-xr-x  0 dieter staff       0 Mar 28 18:34 usr/
drwxr-xr-x  0 dieter staff       0 Mar 28 18:34 usr/bin/
-rwxr-xr-x  0 dieter staff 2899840 Mar 28 18:34 usr/bin/qemu-arm-static
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dockerfile:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;FROM hypriot/rpi-busybox-httpd
ADD qemu-arm-static.tar /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this easy preparation we&amp;rsquo;re able to start an ARM-based Docker container on
Windows 10 with two steps only.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; Create the modified Docker image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t rpi-busybox-httpd .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; Start the QEMU-enabled Docker container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here in this screenshot you can see all the necessary steps we need, there is really
nothing else to do.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/close-encounters-of-the-third-kind/docker4win-arm-container.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Voilà&lt;/strong&gt; - that was the magic trick which can be applied to almost all ARM-based Docker
images to make them run in &amp;ldquo;Docker for Windows&amp;rdquo; and &amp;ldquo;Docker for Mac&amp;rdquo; even on an Intel-based
CPU architecture.&lt;/p&gt;

&lt;h2 id=&#34;watch-the-results:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Watch the results&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Docker for Windows&amp;rdquo; publishes the Docker Engine network with the local network name
&lt;code&gt;docker&lt;/code&gt;. Thus to access the ARM web server, which is running inside of a Linux container,
 we just have to point our preferred web browser to &lt;code&gt;http://docker/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/close-encounters-of-the-third-kind/docker4win-arm-webpage2.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;key-takeaways:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Key Takeaways&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Docker for Windows&amp;rdquo; uses Windows native hypervisor Hyper-V&lt;/li&gt;
&lt;li&gt;the Docker Engine is running in a tiny Alpine Linux VM&lt;/li&gt;
&lt;li&gt;ARM-based Docker containers can be easily enabled with QEMU emulator&lt;/li&gt;
&lt;li&gt;Docker works great on Windows 10&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Are you curious now and want to get in touch with &amp;ldquo;Docker for Windows&amp;rdquo; by yourself?
Then you should register for the Docker BETA program at &lt;a href=&#34;https://beta.docker.com&#34;&gt;https://beta.docker.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Your No. 1 source for Docker on ARM</title>
      <link>http://blog.hypriot.com/post/your-number-one-source-for-docker-on-arm/</link>
      <pubDate>Mon, 28 Mar 2016 22:00:00 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/your-number-one-source-for-docker-on-arm/</guid>
      <description>&lt;p&gt;Besides our &lt;a href=&#34;https://blog.hypriot.com/downloads/&#34;&gt;Download section&lt;/a&gt; we do have another source for getting the latest and greatest Docker for ARM.&lt;br /&gt;
It is a debian package repository hosted at &lt;a href=&#34;https://packagecloud.io/&#34;&gt;packagecloud.io&lt;/a&gt; that contains lots of the stuff from our Download section.&lt;/p&gt;

&lt;p&gt;Despite having a package repository for a couple of months now, it seems many people do not know it.
I guess that&amp;rsquo;s our own fault because we never spoke about it - we only added it to our prepared SD card images. :)
Installing or updating Docker or other Docker goodies like Docker-Compose from this repository can be done by a simple &lt;code&gt;apt-get install&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this post I gonna show you what you need to know to get started with this repository.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/packagecloud/packagecloud_io_wide.jpg&#34; alt=&#34;Raspberry Pi Workshop in Brussels&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Packagecloud.io is a really great service for hosting different types of packages (DEBs, RPMs, Ruby Gems).
You get detailed download/usage statistics and can manage all your packages easily with a Web-GUI or with an API.&lt;/p&gt;

&lt;p&gt;The last point was what convinced us to use packagecloud.io as it allows us to upload our packages directly from our Continuous Integration systems.
Many popular CI systems offer build-in packagecloud support - for instance Travis or Circle-CI.&lt;/p&gt;

&lt;p&gt;Our packagecloud repository is conveniently named &amp;ldquo;Schatzkiste&amp;rdquo; and supports Debian-based Linux distributions.&lt;/p&gt;

&lt;p&gt;To use it you need to configure &amp;lsquo;apt&amp;rsquo; first by executing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -s https://packagecloud.io/install/repositories/Hypriot/Schatzkiste/script.deb.sh | sudo bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to know what this script does you can look up the &lt;a href=&#34;https://packagecloud.io/Hypriot/Schatzkiste/install&#34;&gt;source of this script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It installs &amp;lsquo;apt-transport-https&amp;rsquo; for connecting securely to our repository, adds the packagecloud GPG key to &amp;lsquo;apt&amp;rsquo; and then adds our &amp;lsquo;Schatzkiste&amp;rsquo;-repository sources to &amp;lsquo;/etc/apt/sources.list.d/Hypriot_Schatzkiste.list&amp;rsquo;.&lt;br /&gt;
Afterwards it updates the package sources via &amp;lsquo;apt-get update&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;From there you are ready to search for the latest Docker via&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-cache madison docker-hypriot
docker-hypriot |   1.10.3-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |   1.10.2-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |   1.10.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |   1.10.0-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.9.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.9.0-2 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.8.3-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.8.2-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.8.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.8.0-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.7.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.6.2-2 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.6.2-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.6.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.6.0-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.5.0-7 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;apt-cache madison&amp;rsquo; will list all the available version for package &amp;lsquo;docker-hypriot&amp;rsquo; and as you can see the latest Docker 1.10.3 is already there, too.&lt;/p&gt;

&lt;p&gt;Install it with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install docker-hypriot=1.10.3-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So I want to close this blog post with a huge thank you to the packagecloud.io guys as they are hosting our packages for free.&lt;/p&gt;

&lt;p&gt;I highly recommend their service as it can be so tedious and time-consuming to setup your own repository properly - I have been there myself.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First Touch Down with Docker for Mac</title>
      <link>http://blog.hypriot.com/post/first-touch-down-with-docker-for-mac/</link>
      <pubDate>Sun, 27 Mar 2016 18:30:29 +0200</pubDate>
      
      <guid>http://blog.hypriot.com/post/first-touch-down-with-docker-for-mac/</guid>
      <description>

&lt;p&gt;A few days ago, Docker has announced a closed BETA program for their new
applications &amp;ldquo;Docker for Mac&amp;rdquo; and &amp;ldquo;Docker for Windows&amp;rdquo;. These apps are meant to
simplify the usage of Docker containers for every developer even more. They try
to lower the barrier to install and use Docker on your desktop and laptop computers
for both Mac and Windows users.&lt;/p&gt;

&lt;p&gt;As soon as I received the first rumors that there is a special feature built-in,
which should also simplify the developers workflow for IoT applications, I was getting
totally thrilled and registered immediately for the BETA program. It was really hard
to wait for, but luckily I&amp;rsquo;ve received an email with my BETA invitation and access
token within a few hours only.&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;d like to give you a first insight view how to install and use &amp;ldquo;Docker for Mac&amp;rdquo;
with a basic walk-through on my MacBook Pro running the very latest OS X 10.11.4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-copy-app.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So, please join me on this journey&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;access-to-the-beta-program:10b72799563d55724d4550d1181f06ee&#34;&gt;Access to the BETA program&lt;/h2&gt;

&lt;p&gt;You can easily register to the Docker BETA program at &lt;a href=&#34;https://beta.docker.com&#34;&gt;https://beta.docker.com&lt;/a&gt;. Once
you&amp;rsquo;re logged in with your Docker ID (which is literally your Docker Hub user account)
you can apply for testing &amp;ldquo;Docker for Mac&amp;rdquo; and &amp;ldquo;Docker for Windows&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-apply-for-beta.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As this is a closed BETA, you&amp;rsquo;ll get on a waiting list and hopefully will be selected
soon. So, please be patient until you&amp;rsquo;ll receive an invitation email with some more
detailed instructions and a personal access key.&lt;/p&gt;

&lt;p&gt;For this blog post, I&amp;rsquo;ll show you how easy it is to install and use Docker on OS X.
And I guess, we&amp;rsquo;ll write another post later for all the curious Windows users,  too.&lt;/p&gt;

&lt;h2 id=&#34;download-and-install-docker-for-mac:10b72799563d55724d4550d1181f06ee&#34;&gt;Download and install &amp;ldquo;Docker for Mac&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;When you&amp;rsquo;re selected for the BETA, you&amp;rsquo;ll receive an email titled &amp;ldquo;Docker Private Beta&amp;rdquo;
with a link to the download page and an access key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-download-page.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Download the installer package called &amp;ldquo;Docker.dmg&amp;rdquo; to your Mac and double click it,
drag and drop the &amp;ldquo;Docker beta&amp;rdquo; app to your Applications folder.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-copy-app.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Now, from your Lauchpad you can start the &amp;ldquo;Docker beta&amp;rdquo; app directly the first time
and you can begin right away using Docker on your Mac.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-start-app.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Once you start the BETA Docker app the first time you&amp;rsquo;ll be asked to enter your
personal invite token.
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-install-01-insert-key.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Token has been accepted.
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-install-02-key-accepted.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The Docker app needs to additionally install a network helper and requests for privileges
to do so.
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-install-03-request-privileges.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Enter your credentials to grant privileged access.
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-install-04-grant-privileges.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Success, the Docker app is installed and you can easily find and access it by
clicking on the little neat whale icon.
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-install-05-tray-icon.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;using-docker-for-mac-the-first-time:10b72799563d55724d4550d1181f06ee&#34;&gt;Using &amp;ldquo;Docker for Mac&amp;rdquo; the first time&lt;/h2&gt;

&lt;p&gt;To use Docker we&amp;rsquo;ll just start a terminal window and use the Docker CLI to access
the local Docker Engine.&lt;/p&gt;

&lt;p&gt;First, get the version of the Docker command:
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-run-docker-01-dash-v.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Determine the versions of the Docker Client and the Docker Engine:
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-run-docker-02-version.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Display some more detailed informations about the installed Docker software:
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-run-docker-03-info.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;let-s-start-a-real-docker-container:10b72799563d55724d4550d1181f06ee&#34;&gt;Let&amp;rsquo;s start a real Docker container&lt;/h2&gt;

&lt;p&gt;First, we&amp;rsquo;ll check how our host operating system looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Darwin demo.local 15.4.0 Darwin Kernel Version 15.4.0: Fri Feb 26 22:08:05 PST 2016; root:xnu-3248.40.184~3/RELEASE_X86_64 x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As already expected we see our host OS is OS X or &lt;code&gt;Darwin&lt;/code&gt; with a kernel version &lt;code&gt;15.4.0&lt;/code&gt;. Our CPU architecture is &lt;code&gt;x86_64&lt;/code&gt;, which indicates that we&amp;rsquo;re running on an Intel-based
64-bit CPU.&lt;/p&gt;

&lt;p&gt;Second, let&amp;rsquo;s start a basic Linux container and here we&amp;rsquo;re using a Debian standard distro
for now. This will take a few second because the Docker Engine has to fetch/download
the Docker image &lt;code&gt;debian&lt;/code&gt; from the Docker Hub.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm -ti debian
Unable to find image &#39;debian:latest&#39; locally
latest: Pulling from library/debian
fdd5d7827f33: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:e7d38b3517548a1c71e41bffe9c8ae6d6d29546ce46bf62159837aad072c90aa
Status: Downloaded newer image for debian:latest
root@9473484ea965:/#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we now do have an interactive bash prompt within a running Debian
Linux container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@9473484ea965:/# uname -a
Linux 9473484ea965 4.1.19 #1 SMP Sun Mar 20 22:13:39 UTC 2016 x86_64 GNU/Linux

root@9473484ea965:/# cat /etc/os-release
PRETTY_NAME=&amp;quot;Debian GNU/Linux 8 (jessie)&amp;quot;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;
VERSION_ID=&amp;quot;8&amp;quot;
VERSION=&amp;quot;8 (jessie)&amp;quot;
ID=debian
HOME_URL=&amp;quot;http://www.debian.org/&amp;quot;
SUPPORT_URL=&amp;quot;http://www.debian.org/support&amp;quot;
BUG_REPORT_URL=&amp;quot;https://bugs.debian.org/&amp;quot;
root@9473484ea965:/#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;d like to start a really tiny Linux container next, which starts even
faster than Debian. Alpine Linux is meant to be super-small and it brings a lot
of advantages into the container world, too.&lt;/p&gt;

&lt;p&gt;Starting an interactive Alpine container is pretty much the same as Debian, but we
have to use a Bourne shell instead of bash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm -ti alpine sh
Unable to find image &#39;alpine:latest&#39; locally
latest: Pulling from library/alpine
4d06f2521e4f: Pull complete
Digest: sha256:7739b19a213f3a0aa8dacbd5898c8bd467e6eaf71074296a3d75824e76257396
Status: Downloaded newer image for alpine:latest
/ #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, this container is running on the same kernel version like before, but
uses a completely different Linux distribution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ # uname -a
Linux 411883bd07d3 4.1.19 #1 SMP Sun Mar 20 22:13:39 UTC 2016 x86_64 Linux

/ # cat /etc/os-release
NAME=&amp;quot;Alpine Linux&amp;quot;
ID=alpine
VERSION_ID=3.3.1
PRETTY_NAME=&amp;quot;Alpine Linux v3.3&amp;quot;
HOME_URL=&amp;quot;http://alpinelinux.org&amp;quot;
BUG_REPORT_URL=&amp;quot;http://bugs.alpinelinux.org&amp;quot;
/ #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s look at the details of these both Docker containers. Both are complete
Linux systems, but with a substantial difference in size.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
alpine              latest              70c557e50ed6        3 weeks ago         4.798 MB
debian              latest              f50f9524513f        3 weeks ago         125.1 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alpine Linux is damn small in size and thus the Docker images built upon Alpine
are extremely small as well, and much faster to download. Another major advantage is the
security model of Alpine Linux, which reduces the attack surface dramatically and
provides faster and easier security updates as well.&lt;/p&gt;

&lt;p&gt;This experiment with &amp;ldquo;Docker for Mac&amp;rdquo; clearly demonstrates that we can run Linux
commands inside Docker containers with a Linux OS and a recent kernel version 4.1.19. This is indeed different to our host operating system OS X.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s pure Docker container magic: running a Linux container seamlessly on our
development machine, here on a MacBook Pro (Retina, 15-inch, Mid 2014).&lt;/p&gt;

&lt;h2 id=&#34;the-magic-behind-the-scenes:10b72799563d55724d4550d1181f06ee&#34;&gt;The Magic behind the scenes&lt;/h2&gt;

&lt;p&gt;As I&amp;rsquo;ve shown you in the screenshots above, our host operating system, where the Docker
Client is running, is &lt;code&gt;darwin/amd64&lt;/code&gt; or OS X, but the Docker Engine runs on &lt;code&gt;linux/amd64&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Maybe you&amp;rsquo;re wondering how this even can be possible, right?&lt;br /&gt;
The answer is quite easy, &amp;ldquo;Docker for Mac&amp;rdquo; is shipping it&amp;rsquo;s own lightweight hypervisor
called &lt;a href=&#34;http://www.xhyve.org/&#34;&gt;xhyve&lt;/a&gt;, which itself is a port of the BSD hypervisor
&lt;a href=&#34;http://www.bhyve.org/&#34;&gt;bhyve&lt;/a&gt; to OS X.&lt;/p&gt;

&lt;p&gt;The engineers at Docker have greatly enhanced xhyve to enable an optimized usage
to efficiently run Docker containers on OS X. Inside of the xhyve hypervisor,
the Docker Engine is running in a tiny small Linux VM, which is based upon the
&lt;a href=&#34;http://www.alpinelinux.org&#34;&gt;Alpine Linux&lt;/a&gt; distribution. With this great combination
of outstanding technologies we as users get the feeling to run Docker containers
natively on our Mac.&lt;/p&gt;

&lt;p&gt;Honestly, there are even more great technical details packed into the new &amp;ldquo;Docker for Mac&amp;rdquo;
release, but we&amp;rsquo;ll keep them for a later more advanced technical blog post.&lt;/p&gt;

&lt;h2 id=&#34;there-is-another-big-arm-surprise:10b72799563d55724d4550d1181f06ee&#34;&gt;There is another big ARM surprise&lt;/h2&gt;

&lt;p&gt;With the public announcement of &amp;ldquo;Docker for Mac&amp;rdquo;, I received an &lt;a href=&#34;https://twitter.com/avsm/status/713010884596080640&#34;&gt;Easter Egg tweet&lt;/a&gt; from one
of the Docker engineers, Anil Madhavapeddy, that they&amp;rsquo;ve just included another cool
feature, which attracts me most. He promised I could even run the Docker images, which
I built for an IoT device like a Raspberry Pi on my Mac now!&lt;/p&gt;

&lt;p&gt;No way, that sounds to good to be true. And mainly because the Raspberry Pi uses
an ARM CPU, which cannot be executed on an Intel-based Mac, right?&lt;/p&gt;

&lt;p&gt;To test this, I&amp;rsquo;ll select one of my most famous Docker containers:
the webserver I&amp;rsquo;ve presented at DockerCon 2015 San Francisco, CA, last year in June (more details can be found in a dedicated blog post about the &lt;a href=&#34;http://blog.hypriot.com/post/dockercon2015/&#34;&gt;Hypriot-Demo and challenge at DockerCon 2015&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Ok, here we go. Let&amp;rsquo;s run an ARM container on a Mac:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-arm-container-01.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As you can see, it doesn&amp;rsquo;t work that way&amp;hellip;&lt;br /&gt;
&amp;hellip;hmmm, but maybe with some more magic Docker spells it could be done.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-arm-container-02.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;And this is where all the magic happens. We&amp;rsquo;re just bind-mounting a special binary
into our original ARM-based container. Again, we don&amp;rsquo;t change the original Docker
image to get this done. In the end we are really able to run an ARM container,
which was built on a Raspberry Pi, now on an Intel-based Mac - just with the help
of some &lt;a href=&#34;https://twitter.com/quintus23m/status/713523016836231171&#34;&gt;fantastic Docker fu&lt;/a&gt;
embedded in &amp;ldquo;Docker for Mac&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-arm-container-05.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As a last proof, we check with &lt;code&gt;docker ps&lt;/code&gt; that we&amp;rsquo;re running the original ARM container from June 2015:
&lt;img src=&#34;http://blog.hypriot.com/images/first-touch-down-with-docker-for-mac/docker4mac-arm-container-04.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This is possible because the Docker engineers have already included the Linux kernel support
for &lt;code&gt;binfmt_misc&lt;/code&gt; into &amp;ldquo;Docker for Mac&amp;rdquo;. And as long as there is the right Qemu interpreter
&lt;code&gt;qemu-arm-static&lt;/code&gt; (which is an Intel binary itself) placed in the ARM container,
this container can be executed, or better emulated, even on a foreign CPU architecture.&lt;/p&gt;

&lt;p&gt;Now I can clearly imagine to use &amp;ldquo;Docker for Mac&amp;rdquo; as part of a new Docker-centric workflow
to build IoT containers directly on my Mac. Development and testing can be done fast and
efficiently on the developers machine and then deploying and running the IoT containers
on the target device. A few months ago such an idea has sound pretty crazy and unbelievable -
but now it&amp;rsquo;s coming true soon.&lt;/p&gt;

&lt;p&gt;Special thanks to Anil, Justin and all the other great guys at the Docker engineering
team to make this magic true.&lt;/p&gt;

&lt;h2 id=&#34;key-takeaways:10b72799563d55724d4550d1181f06ee&#34;&gt;Key Takeaways&lt;/h2&gt;

&lt;p&gt;After this first and fast walk-through, I guess you&amp;rsquo;re even more curious and you&amp;rsquo;d
like to use &amp;ldquo;Docker for Mac&amp;rdquo; by yourself. So in the meantime I&amp;rsquo;ll just summarize the
key points what impressed me most about this great new release.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;installing &amp;ldquo;Docker for Mac&amp;rdquo; was pretty easy and slick&lt;/li&gt;
&lt;li&gt;a single &lt;code&gt;.dmg&lt;/code&gt; media with 90 MByte only&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Docker for Mac&amp;rdquo; is a real native OS X application&lt;/li&gt;
&lt;li&gt;there are absolutely no other external resources or dependencies to install&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Docker for Mac&amp;rdquo; integrates perfectly into your development workflow&lt;/li&gt;
&lt;li&gt;downloading, installing and running the first Docker container takes a few minutes only&lt;/li&gt;
&lt;li&gt;for tiny containers, Alpine Linux is one of the best Linux distros&lt;/li&gt;
&lt;li&gt;ARM IoT containers can be developed and run even on a Mac&lt;/li&gt;
&lt;li&gt;&amp;hellip;much more will be revealed in later blog posts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s build a PicoCluster for Docker Swarm</title>
      <link>http://blog.hypriot.com/post/lets-build-a-pi-docker-picocluster/</link>
      <pubDate>Wed, 23 Mar 2016 18:40:04 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/lets-build-a-pi-docker-picocluster/</guid>
      <description>

&lt;p&gt;As we love to use Docker Swarm on a cluster of Raspberry Pi&amp;rsquo;s, we&amp;rsquo;d like to cover
in this hands-on tutorial how to build such a cluster easily with a hardware kit
from &lt;a href=&#34;http://picocluster.com&#34;&gt;PicoCluster&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All you need is a PicoCluster kit for a 3-node or 5-node cluster, a couple of
Raspberry Pi&amp;rsquo;s and the time to assemble all the parts together. The project can be
completed within an hour only, and makes so much fun, too - especially when you can
share this as quality time with your kids.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-3node-pdu-tower.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;PicoCluster had just sent us two different kits of their cool Raspberry Pi
clusters. Of course, we are eager to build these new clusters so you can get a first impression.&lt;/p&gt;

&lt;h3 id=&#34;what-s-in-the-box:098640bbbda183ea709087a458ce9550&#34;&gt;What&amp;rsquo;s in the box&lt;/h3&gt;

&lt;p&gt;3-node PicoCluster kit:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;acrylic case, all parts&lt;/li&gt;
&lt;li&gt;PDU (12V input, 4x USB 5V output), including all wires&lt;/li&gt;
&lt;li&gt;wiring for 3x microUSB power&lt;/li&gt;
&lt;li&gt;case wiring for 1x HDMI&lt;/li&gt;
&lt;li&gt;case wiring for 1x 12V power plug&lt;/li&gt;
&lt;li&gt;base mounting for Pi tower, including all crews, nuts &amp;amp; bolts, spacers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-3node-parts.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;5-node PicoCluster kit:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;acrylic case, all parts&lt;/li&gt;
&lt;li&gt;internal 8-port Ethernet switch&lt;/li&gt;
&lt;li&gt;PDU (12V input, 5x USB 5V output), including all wires&lt;/li&gt;
&lt;li&gt;wiring for 5x microUSB power&lt;/li&gt;
&lt;li&gt;wiring for network (Raspberry Pi to Ethernet switch)&lt;/li&gt;
&lt;li&gt;case wiring for 1x Ethernet&lt;/li&gt;
&lt;li&gt;case wiring for 1x HDMI&lt;/li&gt;
&lt;li&gt;case wiring for 2x USB&lt;/li&gt;
&lt;li&gt;case wiring for 1x 12V power plug&lt;/li&gt;
&lt;li&gt;base mounting for Pi tower, including all crews, nuts &amp;amp; bolts, spacers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-5node-parts.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Not included in the kits: (so you have to buy it separately)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi’s and microSD cards&lt;/li&gt;
&lt;li&gt;AC adapter (12V, 1.5A, barrel plug 5.5x2.1mm)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally we&amp;rsquo;ll need some common tools for the mechanical assembling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;philips screw driver&lt;/li&gt;
&lt;li&gt;7mm wrench (or a pliers)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/tools-screwdriver-wrench.jpg&#34; alt=&#34;PicoCluster toosl&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;assembling-the-3-node-picocluster:098640bbbda183ea709087a458ce9550&#34;&gt;Assembling the 3-node PicoCluster&lt;/h3&gt;

&lt;h4 id=&#34;towering-the-raspberry-pi-s:098640bbbda183ea709087a458ce9550&#34;&gt;Towering the Raspberry Pi&amp;rsquo;s&lt;/h4&gt;

&lt;p&gt;First we take the mounting plate for the Pi tower and stack all
three Raspberry Pi&amp;rsquo;s with the help of the included spacers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-3node-pi-tower.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;
&lt;/p&gt;

&lt;h4 id=&#34;wiring-all-together:098640bbbda183ea709087a458ce9550&#34;&gt;Wiring all together&lt;/h4&gt;

&lt;p&gt;Now it&amp;rsquo;s easy to mount the PDU on top of the Pi tower with 4 screws and attaching
the USB power cables to the three Raspberry Pi&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-3node-pdu-tower2.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Next we mount the tower on the base plate, which makes our new cluster look even better.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-3node-base-tower.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;From now on, it&amp;rsquo;s easy to complete the cluster installation: We connect
the 12V power cable to the PDU and front cover. We can also attach the HDMI cable
to the upper Raspberry Pi and mount the other end to the front cover, too.&lt;/p&gt;

&lt;h4 id=&#34;assembling-the-case:098640bbbda183ea709087a458ce9550&#34;&gt;Assembling the case&lt;/h4&gt;

&lt;p&gt;Finally, we mount the side and back cover and put on the top plate.
Mounting with nuts &amp;amp; bolts and the PicoCluster is ready.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Don&amp;rsquo;t forget to flash your microSD cards and insert them into the Pi&amp;rsquo;s,
because as soon as we close the cluster case, it&amp;rsquo;s a little bit harder to change
the SD cards.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-3node-completed.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;assembling-the-5-node-picocluster:098640bbbda183ea709087a458ce9550&#34;&gt;Assembling the 5-node PicoCluster&lt;/h3&gt;

&lt;h4 id=&#34;towering-the-raspberry-pi-s-1:098640bbbda183ea709087a458ce9550&#34;&gt;Towering the Raspberry Pi&amp;rsquo;s&lt;/h4&gt;

&lt;p&gt;With the 5-node cluster we start similar as with the 3-node. We take
the mounting plate for the Pi tower and stack all five Raspberry Pi&amp;rsquo;s with the
spacers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-5node-pi-tower.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;

&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-5node-pi-tower2.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;
&lt;/p&gt;

&lt;h4 id=&#34;wiring-all-together-1:098640bbbda183ea709087a458ce9550&#34;&gt;Wiring all together&lt;/h4&gt;

&lt;p&gt;Next, we mount the PDU on top of the Pi tower with 4 screws and attach
the USB power cables to the five Raspberry Pi&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-5node-pdu-tower.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;As soon as we mount the tower on the base plate, we see that we do have a lot more
parts left.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-5node-base-tower.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;For the 5-node cluster we have an internal dedicated 8-port switch, which we&amp;rsquo;ll
install inside the case and wire all the ethernet cables to the Pi&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-5node-ethernet-switch.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;From now on, it&amp;rsquo;s easy to complete the cluster installation: We connect
the 12V power cable to the PDU and front cover. We can also attach the HDMI cable
to the upper Raspberry Pi and mount the other end to the front cover, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-5node-switch-tower.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll also find two USB cables in the kit, which you can connect to one or two
different Pi&amp;rsquo;s and mount the plug to the front panel as well. Attaching HDMI and USB
plugs to the case is really optional.&lt;/p&gt;

&lt;h4 id=&#34;assembling-the-case-1:098640bbbda183ea709087a458ce9550&#34;&gt;Assembling the case&lt;/h4&gt;

&lt;p&gt;Finally, we mount the side and back cover and put on the top plate.
Mounting with nuts &amp;amp; bolts and our second PicoCluster is almost ready. As there are a
few more parts to assemble the 5-node cluster, it will take a little bit longer than
building the smaller cluster.&lt;/p&gt;

&lt;h3 id=&#34;finally-we-have-two-new-clusters:098640bbbda183ea709087a458ce9550&#34;&gt;Finally, we have two new clusters&lt;/h3&gt;

&lt;p&gt;At the end we have now built two new Raspberry Pi clusters, a 3-node and a 5-node
from PicoCluster. Both are looking really neat and everything is stowed away in
a perfect way. Only accessing the microSD cards is not optimal once after the case
is closed. You just have to remove only a few screws and dismounting the rear side
panel of the case and then you can easily access the SD card slots.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/picocluster-kits/picocluster-3node-and-5node-cluster.jpg&#34; alt=&#34;PicoCluster 3- and 5-node&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Because the 5-node cluster includes an integrated 8-port Ethernet switch, we&amp;rsquo;d recommend
it to use as a standalone Pi cluster for experimenting with Docker Swarm and other
cluster related tutorials and demos. You just have to attach a 12V power source and
a single network link. This is all you need to start playing with it right away.&lt;/p&gt;

&lt;p&gt;Now, you can go ahead and install software on your new PicoCluster.
However, this isn&amp;rsquo;t within the scope of this hands-on project, so we&amp;rsquo;ll point you to one of our
latest tutorials where you learn &lt;a href=&#34;http://blog.hypriot.com/post/how-to-setup-rpi-docker-swarm/&#34;&gt;how to setup a Docker Swarm cluster with Raspberry Pi&amp;rsquo;s&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;where-can-you-get-it:098640bbbda183ea709087a458ce9550&#34;&gt;Where can you get it ?&lt;/h3&gt;

&lt;p&gt;You can order your own ready-to-use and tiny data center directly at &lt;a href=&#34;http://picocluster.com&#34;&gt;PicoCluster&lt;/a&gt;
with the Raspberry Pi&amp;rsquo;s included. The hardware kits we used in this post should be available soon, too.
PicoCluster is currently optimizing a few parts like the PDU to get more power for the new Raspberry Pi 3,
so we expect the next version will get some changes and improvements compared to these
beta units.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker on Raspberry Pi Workshop in Brussels</title>
      <link>http://blog.hypriot.com/post/docker-on-arm-workshops/</link>
      <pubDate>Thu, 17 Mar 2016 00:00:00 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/docker-on-arm-workshops/</guid>
      <description>&lt;p&gt;A couple of weeks ago we have been invited by the fine folks over at the Docker User Group in Brussels to help conduct a workshop.
And of course this workshop was about Docker. Still it was not your ordinary Docker workshop.&lt;/p&gt;

&lt;p&gt;It was special because instead of being a workshop about Docker on big servers it was about Docker on really small ARM devices.
The very same devices that power the upcoming IoT revolution.&lt;/p&gt;

&lt;p&gt;Turns out it is really amazing what you can do with Docker on those tiny machines.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/docker_workshop.jpg&#34; alt=&#34;Raspberry Pi Workshop in Brussels&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;In this workshop attendees learned how to get started with Docker on their Raspberry Pi&amp;rsquo;s.
Starting with the basics they soon turned to advanced topics like building a Docker cluster.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What is Raspberry Pi and how is it working&lt;/li&gt;
&lt;li&gt;How to flash an SD card with HypriotOS&lt;/li&gt;
&lt;li&gt;How to log in to a Raspberry Pi via SSH or serial console&lt;/li&gt;
&lt;li&gt;How to do basic stuff with Docker&lt;/li&gt;
&lt;li&gt;What is different when using Docker on ARM compared to Intel&lt;/li&gt;
&lt;li&gt;How to build a Docker Cluster with Docker Swarm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dieter Reuter from our team gave an introductory talk and showed off some of the cool things we did at Hypriot.
About 70 people attended the workshop and worked in small groups and helped each other to learn new stuff.
Even days after the event Dieter was still raving about the cool event and the amazing, open-minded and friendly people.&lt;/p&gt;

&lt;p&gt;As you can see from the pictures it was a lot of fun to be there.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;
&lt;div class=&#34;title&#34;&gt;Docker &amp;amp; Raspberry Pi Workshop in Brussels&lt;/div&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-02.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-02.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Dieter giving a talk&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Dieter giving a talk
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-01.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-01.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-03.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-03.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-04.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-04.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-05.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-05.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/workshop-06.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://blog.hypriot.com/images/raspberry-pi-workshop/thumbnails/thumb_workshop-06.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://blog.hypriot.com/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://blog.hypriot.com/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;Special thanks for making the workshop possible need to go to Damien Duportal.
His workshop presentation can be found &lt;a href=&#34;http://dduportal.github.io/presentations/docker-meetup-brussels-20160210/#1&#34;&gt;here&lt;/a&gt;.
The example app that was used during the workshop was ported to ARM and can be found &lt;a href=&#34;https://github.com/jmMeessen/rpi-voting-app/commits/master&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We - at the Hypriot team - are really excited to see how more and more people start to see the potential in Docker on ARM.&lt;/p&gt;

&lt;p&gt;Last week I was approached by Bastiaan Schaap from the DevOps Oost-Nederland Meetup Group to help organize a similar workshop.
It will take place on &lt;strong&gt;June, 1st in Wageningen in the Netherlands&lt;/strong&gt;. You can read more about the agenda on the &lt;a href=&#34;http://www.meetup.com/de-DE/DevOps-OostNL/events/229287742/?eventId=229287742&#34;&gt;Meetup-Website&lt;/a&gt;.
Make sure to RSVP early as there will only be a limited number of seats available.&lt;/p&gt;

&lt;p&gt;We plan to do some more workshops in the next couple of months. So if you like to see one happen in your area - please come and talk to us.
We really have a lot of fun organizing and conducting these kind of events and can come up with a ton of different workshop topics.&lt;/p&gt;

&lt;p&gt;So in this sense - hope to see you soon in person.
Happy ARM hacking until then. :)&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s run Docker on the ClearFog Pro router board</title>
      <link>http://blog.hypriot.com/post/clearfog-pro-part-2-lets-run-docker/</link>
      <pubDate>Wed, 16 Mar 2016 18:14:02 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/clearfog-pro-part-2-lets-run-docker/</guid>
      <description>

&lt;p&gt;Here is the follow up of our blog post series about the new ARM-based router board
from SolidRun which is powered by a dual core Marvell ARMADA ARMv7 CPU. In case
you missed the intro a few days ago, we highly recommend reading the technical
specifications first to get an impression of this board.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part 1: &lt;a href=&#34;http://blog.hypriot.com/post/introducing-the-clearfog-pro-router-board/&#34;&gt;Introducing the new ClearFog Pro Router Board from SolidRun&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This time we&amp;rsquo;ll get our hands on this new board and try to install Linux with a
recent kernel version and hopefully we&amp;rsquo;re able to install and run the Docker Engine
the first time on this powerful device.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s get started and for our second episode we connect the ClearFog Pro to a
MacBookPro and powering this thing up&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-part2/clearfog-pro-eth2-cabled.jpg&#34; alt=&#34;ClearFog Pro Eth2 Cabled&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;first-contact:df574ad27518dffc38341295be8d9782&#34;&gt;First contact&lt;/h3&gt;

&lt;p&gt;We can connect the ClearFog Pro to a MacBookPro with a standard USB cable, because
SolidRun added a FTDI chip on the board (Note: you&amp;rsquo;ll need to install the appropriate
FTDI device drivers).
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-part2/clearfog-pro-serial-console.jpg&#34; alt=&#34;ClearFog Pro Serial Console&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The microUSB connector acts as a debugging console and gives us access to the
Linux console as well. As soon as we&amp;rsquo;re powering the board, we can see the console
output of the boot loader. Here we don&amp;rsquo;t have a microSD card inserted and the bootloader
stops it&amp;rsquo;s boot sequence and we proved that we are successfully connected.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BootROM - 1.73

Booting from MMC
Card did not respond to voltage select!
Error initializing MMC - FFFFFFEF

Trying Uart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-linux:df574ad27518dffc38341295be8d9782&#34;&gt;Install Linux&lt;/h3&gt;

&lt;p&gt;Normally we would start building our own HypriotOS for a new board, in order to get a
perfect Linux kernel with tuned settings and a Debian-based Linux distro to run Docker
in an optimized way. But this time it turns out we are able to jump start pretty fast
and using Armbian for this first testing.&lt;/p&gt;

&lt;p&gt;For this purpose we&amp;rsquo;ve created Armbian for the ClearFog Pro from source and getting a brand-new
Linux kernel 4.4.5 and all things packaged into a ready-to-install SD card image. Now, we
only have to flash the image to a microSD card with the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt;
and boot up the board.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash Armbian_5.05_Armada_Debian_jessie_4.4.5.raw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the login prompt we&amp;rsquo;re using username &lt;code&gt;root&lt;/code&gt; with the initial password &lt;code&gt;1234&lt;/code&gt;
to login the first time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Debian GNU/Linux 8 armada ttyS0

armada login:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we&amp;rsquo;ve changed the root password and created another user account, we do have
access to the console and can check the Armbian Linux system in detail.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# uname -a
Linux armada 4.4.5-marvell #2 SMP Wed Mar 16 09:42:31 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, this is indeed a current Linux kernel version 4.4.5. The very latest
Linux kernel release is 4.5 and it was just released a few days ago and we should expect
it will be supported soon for the ClearFog Pro board too.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive a little bit deeper and we can see our board is running with 1 GByte
of main memory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# cat /proc/meminfo
MemTotal:        1027860 kB
MemFree:          910964 kB
MemAvailable:     973540 kB
Buffers:           11104 kB
Cached:            66864 kB
SwapCached:            0 kB
Active:            56388 kB
Inactive:          37856 kB
Active(anon):      17536 kB
Inactive(anon):     6540 kB
Active(file):      38852 kB
Inactive(file):    31316 kB
Unevictable:           0 kB
Mlocked:               0 kB
HighTotal:        262144 kB
HighFree:         237664 kB
LowTotal:         765716 kB
LowFree:          673300 kB
SwapTotal:        131068 kB
SwapFree:         131068 kB
Dirty:                 8 kB
Writeback:             0 kB
AnonPages:         16340 kB
Mapped:            10092 kB
Shmem:              7804 kB
Slab:              11668 kB
SReclaimable:       5004 kB
SUnreclaim:         6664 kB
KernelStack:         720 kB
PageTables:          360 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:      644996 kB
Committed_AS:      56040 kB
VmallocTotal:     245760 kB
VmallocUsed:           0 kB
VmallocChunk:          0 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And a dual core ARMv7 from a Marvell Armada 380 / 385 CPU. To be precise, it&amp;rsquo;s a
Marvell ARMADA 388 CPU with up to 1.6GHz.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# cat /proc/cpuinfo
processor       : 0
model name      : ARMv7 Processor rev 1 (v7l)
BogoMIPS        : 50.00
Features        : half thumb fastmult vfp edsp thumbee neon vfpv3 tls vfpd32
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x4
CPU part        : 0xc09
CPU revision    : 1

processor       : 1
model name      : ARMv7 Processor rev 1 (v7l)
BogoMIPS        : 50.00
Features        : half thumb fastmult vfp edsp thumbee neon vfpv3 tls vfpd32
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x4
CPU part        : 0xc09
CPU revision    : 1

Hardware        : Marvell Armada 380/385 (Device Tree)
Revision        : 0000
Serial          : 0000000000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a detailed picture of the SOM (System On Module), which includes the CPU
and the DDR3 memory chips.
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-part2/clearfog-pro-microsom-a388-top-transparent.jpg&#34; alt=&#34;ClearFog Pro MicroSOM&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Once we attach an ethernet cable to the ethernet connector next to the USB plug,
we should have the network interface &lt;code&gt;eth2&lt;/code&gt; running. If there is no IP address
assigned we can use &lt;code&gt;dhclient eth2&lt;/code&gt; to fetch a new TCP/IP address via DHCP.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# dhclient eth2
[  262.372335] mvneta f1070000.ethernet eth2: PHY [f1072004.mdio-mi:00] driver [Marvell 88E1510]
[  262.380889] mvneta f1070000.ethernet eth2: configuring for link AN mode phy
[  262.387949] IPv6: ADDRCONF(NETDEV_UP): eth2: link is not ready
[  265.371548] mvneta f1070000.ethernet eth2: Link is Up - 100Mbps/Full - flow control rx/tx
[  265.379757] IPv6: ADDRCONF(NETDEV_CHANGE): eth2: link becomes ready
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# ifconfig eth2
eth2      Link encap:Ethernet  HWaddr 00:50:43:25:fb:84
          inet addr:192.168.2.108  Bcast:192.168.2.255  Mask:255.255.255.0
          inet6 addr: fe80::250:43ff:fe25:fb84/64 Scope:Link
          inet6 addr: 2003:86:8c11:a703:250:43ff:fe25:fb84/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:57 errors:0 dropped:0 overruns:0 frame:0
          TX packets:44 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:532
          RX bytes:7746 (7.5 KiB)  TX bytes:4300 (4.1 KiB)
          Interrupt:41
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally let&amp;rsquo;s check if we have an internet connection to proceed with our installation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@armada:~# ping -c 3 google.com
PING google.com (173.194.116.206) 56(84) bytes of data.
64 bytes from fra07s64-in-f14.1e100.net (173.194.116.206): icmp_seq=1 ttl=57 time=27.0 ms
64 bytes from fra07s64-in-f14.1e100.net (173.194.116.206): icmp_seq=2 ttl=57 time=26.8 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2003ms
rtt min/avg/max/mdev = 26.828/26.959/27.091/0.210 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, that&amp;rsquo;s great. We do have now a Debian Jessie Linux distro called &lt;code&gt;Armbian&lt;/code&gt;
with a most recent Linux kernel 4.4.5 running on the ClearFog Pro.&lt;/p&gt;

&lt;h3 id=&#34;installing-the-docker-engine:df574ad27518dffc38341295be8d9782&#34;&gt;Installing the Docker Engine&lt;/h3&gt;

&lt;p&gt;Before we try to install Docker, we&amp;rsquo;d like to know about if the Linux kernel settings
are sufficient to run Docker in a decent way. Remember, most of the standard Linux
kernels for dev boards lacks the support for a few important kernel options, and this
could cause major problems to run Docker.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s have a look here and check the kernel settings with a check script which
is thankfully provided by the Docker core team.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://github.com/docker/docker/raw/master/contrib/check-config.sh
chmod +x check-config.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;./check-config.sh
info: reading kernel config from /proc/config.gz ...

Generally Necessary:
- cgroup hierarchy: properly mounted [/sys/fs/cgroup]
- CONFIG_NAMESPACES: enabled
- CONFIG_NET_NS: enabled
- CONFIG_PID_NS: enabled
- CONFIG_IPC_NS: enabled
- CONFIG_UTS_NS: enabled
- CONFIG_DEVPTS_MULTIPLE_INSTANCES: missing
- CONFIG_CGROUPS: enabled
- CONFIG_CGROUP_CPUACCT: enabled
- CONFIG_CGROUP_DEVICE: enabled
- CONFIG_CGROUP_FREEZER: enabled
- CONFIG_CGROUP_SCHED: enabled
- CONFIG_CPUSETS: enabled
- CONFIG_MEMCG: enabled
- CONFIG_KEYS: enabled
- CONFIG_MACVLAN: enabled
- CONFIG_VETH: enabled
- CONFIG_BRIDGE: enabled
- CONFIG_BRIDGE_NETFILTER: enabled (as module)
- CONFIG_NF_NAT_IPV4: enabled (as module)
- CONFIG_IP_NF_FILTER: enabled (as module)
- CONFIG_IP_NF_TARGET_MASQUERADE: enabled (as module)
- CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: enabled (as module)
- CONFIG_NETFILTER_XT_MATCH_CONNTRACK: enabled (as module)
- CONFIG_NF_NAT: enabled (as module)
- CONFIG_NF_NAT_NEEDED: enabled
- CONFIG_POSIX_MQUEUE: enabled

Optional Features:
- CONFIG_USER_NS: missing
- CONFIG_SECCOMP: missing
- CONFIG_CGROUP_PIDS: missing
- CONFIG_MEMCG_KMEM: enabled
- CONFIG_MEMCG_SWAP: enabled
- CONFIG_MEMCG_SWAP_ENABLED: enabled
- CONFIG_BLK_CGROUP: enabled
- CONFIG_IOSCHED_CFQ: enabled
- CONFIG_BLK_DEV_THROTTLING: enabled
- CONFIG_CGROUP_PERF: enabled
- CONFIG_CGROUP_HUGETLB: missing
- CONFIG_NET_CLS_CGROUP: missing
- CONFIG_CGROUP_NET_PRIO: missing
- CONFIG_CFS_BANDWIDTH: enabled
- CONFIG_FAIR_GROUP_SCHED: enabled
- CONFIG_RT_GROUP_SCHED: enabled
- CONFIG_EXT3_FS: missing
- CONFIG_EXT3_FS_XATTR: missing
- CONFIG_EXT3_FS_POSIX_ACL: missing
- CONFIG_EXT3_FS_SECURITY: missing
    (enable these ext3 configs if you are using ext3 as backing filesystem)
- CONFIG_EXT4_FS: enabled
- CONFIG_EXT4_FS_POSIX_ACL: enabled
- CONFIG_EXT4_FS_SECURITY: enabled
- Storage Drivers:
  - &amp;quot;aufs&amp;quot;:
    - CONFIG_AUFS_FS: missing
  - &amp;quot;btrfs&amp;quot;:
    - CONFIG_BTRFS_FS: enabled
  - &amp;quot;devicemapper&amp;quot;:
    - CONFIG_BLK_DEV_DM: missing
    - CONFIG_DM_THIN_PROVISIONING: missing
  - &amp;quot;overlay&amp;quot;:
    - CONFIG_OVERLAY_FS: enabled (as module)
  - &amp;quot;zfs&amp;quot;:
    - /dev/zfs: missing
    - zfs command: missing
    - zpool command: missing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This report tells us that the kernel 4.4.5 provided by Armbian is quite well,
but it&amp;rsquo;s not perfectly optimized for Docker usage. Anyway, we&amp;rsquo;ll give it a try
and will see how far we can go before we&amp;rsquo;re trying to optimize the kernel settings
even further.&lt;/p&gt;

&lt;p&gt;As this board has a standard ARMv7 CPU we can easily install the Docker Engine from
the Hypriot package repository. BTW, that&amp;rsquo;s exactly the same version we&amp;rsquo;re running
on all the Raspberry Pi&amp;rsquo;s, ODROID&amp;rsquo;s and other ARMv6 or ARMv7 boards as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install -y apt-transport-https
wget -q https://packagecloud.io/gpg.key -O - | apt-key add -
echo &#39;deb https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy main&#39; &amp;gt;&amp;gt; /etc/apt/sources.list.d/hypriot.list
apt-get update
apt-get install -y docker-hypriot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;rsquo;s check the Docker version and infos and see if all is installed the
right way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker version
Client:
 Version:      1.10.3
 API version:  1.22
 Go version:   go1.4.3
 Git commit:   20f81dd
 Built:        Thu Mar 10 22:23:48 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.10.3
 API version:  1.22
 Go version:   go1.4.3
 Git commit:   20f81dd
 Built:        Thu Mar 10 22:23:48 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.10.3
Storage Driver: overlay
 Backing Filesystem: extfs
Execution Driver: native-0.2
Logging Driver: json-file
Plugins:
 Volume: local
 Network: host bridge null
Kernel Version: 4.4.5-marvell
Operating System: Debian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 2
Total Memory: 1004 MiB
Name: armada
ID: CH4K:7X5P:SF47:C6NN:CRIF:OIUS:66TM:PJFL:D5ET:APW2:KCKT:DWBT
Debug mode (server): true
 File Descriptors: 12
 Goroutines: 20
 System Time: 2016-03-16T16:34:52.01930928Z
 EventsListeners: 0
 Init SHA1: 0db326fc09273474242804e87e11e1d9930fb95b
 Init Path: /usr/lib/docker/dockerinit
 Docker Root Dir: /var/lib/docker
WARNING: No memory limit support
WARNING: No swap limit support
WARNING: No oom kill disable support
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perfect! As you can see, we do have now the latest Docker Engine release v1.10.3 up and running
on the ClearFog Pro. And it&amp;rsquo;s using Overlay filesystem which is really great. But
there are also some warnings displayed - this will be fixed later with our own
Linux distro HypriotOS.&lt;/p&gt;

&lt;p&gt;Checking the status of the &lt;code&gt;docker service&lt;/code&gt; reveals, that the service is running
but it&amp;rsquo;s not enabled yet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl status docker
● docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; disabled)
   Active: active (running) since Wed 2016-03-16 16:34:27 UTC; 49s ago
     Docs: https://docs.docker.com
 Main PID: 4219 (docker)
   CGroup: /system.slice/docker.service
           └─4219 /usr/bin/docker daemon -H fd:// --storage-driver=overlay -D...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus we should enable it to get the Docker Engine automatically started on the next
reboot of the board.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable docker
Synchronizing state for docker.service with sysvinit using update-rc.d...
Executing /usr/sbin/update-rc.d docker defaults
Executing /usr/sbin/update-rc.d docker enable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, this was really damn easy. Nothing complicated and nothing special until now.
It seems that with Armbian the Docker Engine 1.10.3 is just running almost out-of-the-box.&lt;/p&gt;

&lt;h3 id=&#34;running-the-first-docker-container:df574ad27518dffc38341295be8d9782&#34;&gt;Running the first Docker container&lt;/h3&gt;

&lt;p&gt;Now, we&amp;rsquo;d like to start a first Docker container and we&amp;rsquo;re just using a very small
web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
c6bf2a8a534dea6b5afd2cf466ed1828bae2f77ba06e7563732e3b416c607d6b
[  705.631098] device vethe5d37f3 entered promiscuous mode
[  705.636762] IPv6: ADDRCONF(NETDEV_UP): vethe5d37f3: link is not ready
[  706.011850] eth0: renamed from veth4dd291a
[  706.052008] IPv6: ADDRCONF(NETDEV_CHANGE): vethe5d37f3: link becomes ready
[  706.058946] docker0: port 1(vethe5d37f3) entered forwarding state
[  706.065096] docker0: port 1(vethe5d37f3) entered forwarding state
[  706.071820] IPv6: ADDRCONF(NETDEV_CHANGE): docker0: link becomes ready
[  706.095771] devpts: called with bogus options
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, the web server seems to be running fine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker ps -a
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                NAMES
c6bf2a8a534d        hypriot/rpi-busybox-httpd   &amp;quot;/bin/busybox httpd -&amp;quot;   21 seconds ago      Up 19 seconds       0.0.0.0:80-&amp;gt;80/tcp   sharp_hugle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can check the web server via a simple &lt;code&gt;curl&lt;/code&gt; command on the ClearFog console or
from the MacBookPro.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl 192.168.2.108
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Pi armed with Docker by Hypriot&amp;lt;/title&amp;gt;
  &amp;lt;body style=&amp;quot;width: 100%; background-color: black;&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;main&amp;quot; style=&amp;quot;margin: 100px auto 0 auto; width: 800px;&amp;quot;&amp;gt;
      &amp;lt;img src=&amp;quot;pi_armed_with_docker.jpg&amp;quot; alt=&amp;quot;pi armed with docker&amp;quot; style=&amp;quot;width: 800px&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, we just point our web browser with &lt;code&gt;open http://192.168.2.108/&lt;/code&gt; to the main web page.
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-part2/clearfog-pro-webbrowser.jpg&#34; alt=&#34;ClearFog Pro WebBrowser&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;current-status-and-key-takeaways:df574ad27518dffc38341295be8d9782&#34;&gt;Current status and key takeaways&lt;/h3&gt;

&lt;p&gt;The web site of SolidRun says, they&amp;rsquo;re supporting a Linux kernel 3.x only and this would
be way too old and outdated. But luckily we figured out there is already support for
the very latest Linux kernel 4.x versions available. SolidRun has an own kernel repo
on GitHub where you can find all the changes and patches, these patches are already
included by Armbian as well.&lt;/p&gt;

&lt;p&gt;We just double-checked this directly with SolidRun and they told us, they&amp;rsquo;re already
working on it, to get all the Marvell related kernel patches for the ClearFog Pro
into the mainline Linux kernel. They plan to get everything merged into LK 4.6. This could
maybe mean that not all the special features of the board will be supported right now
with a kernel 4.x, but we&amp;rsquo;ll test this later on.&lt;/p&gt;

&lt;p&gt;This engagement of SolidRun sounds pretty fantastic and we highly encourage them to proceed
with this strategy. With supporting the latest mainline Linux kernel with hopefully
all hardware features this could become one of the best router boards on the market.
It&amp;rsquo;s powerful with high-speed networking and supports Docker container technology too.&lt;/p&gt;

&lt;h3 id=&#34;next-steps:df574ad27518dffc38341295be8d9782&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;The Linux kernel and SD image provided by Armbian looks really good at this point
and can be used for the first steps with Docker. But we think there is almost a
lot of room for improvements which we&amp;rsquo;d like to pick up and optimize the kernel
settings. As soon as this ground work is done, we&amp;rsquo;ll create a SD card image with
HypriotOS for the ClearFog Pro router board and release this soon.&lt;/p&gt;

&lt;p&gt;But this will be covered in the next detailed posts of this series, so please
stay tuned&amp;hellip;&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing the new ClearFog Pro Router Board from SolidRun</title>
      <link>http://blog.hypriot.com/post/introducing-the-clearfog-pro-router-board/</link>
      <pubDate>Mon, 14 Mar 2016 23:38:42 +0100</pubDate>
      
      <guid>http://blog.hypriot.com/post/introducing-the-clearfog-pro-router-board/</guid>
      <description>

&lt;p&gt;Could you imagine to run a standard Linux OS and your applications of choice securely
within Docker containers on a beefy WiFi router at home?&lt;/p&gt;

&lt;p&gt;We think this will be possible soon with this new ARM-based router board from SolidRun.
Thus we&amp;rsquo;ll spent a whole blog post series to install our Debian-based HypriotOS
and get Docker running on this Marvell ARMADA powered Single Board Computer (SBC).&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s get started and for our first episode in this series we&amp;rsquo;ll dive deep into
the technical specifications of the ClearFog Pro in order to get to know this neat
little device.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-overview.jpg&#34; alt=&#34;ClearFog Pro Overview&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;But be prepared, this one is really a powerful beast&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-overview-01.jpg&#34; alt=&#34;ClearFog Pro Overview&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;technical-specifications:568e70a5f9d2a7d5ec5b5140013e90f2&#34;&gt;Technical specifications&lt;/h3&gt;

&lt;p&gt;The ClearFog is based upon the Marvell ARMADA 380 or 388 processors. The CPU is a
single or dual core ARMv7 processor (Cortex A9) @ up to 1.6 GHz with 1MB L2 cache,
NEON and FPU.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Features&lt;/th&gt;
&lt;th&gt;ClearFog Base*&lt;/th&gt;
&lt;th&gt;ClearFog Pro&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.solid-run.com/marvell-armada-family/armada-som-system-on-module/&#34;&gt;SoC Model&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ARMADA based A380/A388&lt;/td&gt;
&lt;td&gt;ARMADA based A380/A388&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Memory &amp;amp; Storage&lt;/td&gt;
&lt;td&gt;256MB (A380)/1GB (A388)&lt;/td&gt;
&lt;td&gt;256MB (A380)/1GB (A388)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;M.2**&lt;/td&gt;
&lt;td&gt;M.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8GB microSD&lt;/td&gt;
&lt;td&gt;8GB microSD&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4GB eMMC (optional)&lt;/td&gt;
&lt;td&gt;4GB eMMC (optional)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Connectivity&lt;/td&gt;
&lt;td&gt;1x mSATA/mPCIE&lt;/td&gt;
&lt;td&gt;2x mSATA/mPCIE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1x USB 3.0 port&lt;/td&gt;
&lt;td&gt;1x USB 3.0 port&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2x Port dedicated Ethernet&lt;/td&gt;
&lt;td&gt;1x Port dedicated Ethernet&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1x SFP (A388 Only)&lt;/td&gt;
&lt;td&gt;6x Port switched Ethernet&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1x SFP Ethernet&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;I/O and Misc.&lt;/td&gt;
&lt;td&gt;Analog Audio&lt;/td&gt;
&lt;td&gt;Analog Audio/TDM module support&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;GPIO Header (mikroBUS)&lt;/td&gt;
&lt;td&gt;GPIO Header (mikroBUS)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Indication LEDs&lt;/td&gt;
&lt;td&gt;Indication LEDs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;User Push Buttons&lt;/td&gt;
&lt;td&gt;User Push Buttons&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;PoE expansion header&lt;/td&gt;
&lt;td&gt;PoE expansion header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;RTC Battery&lt;/td&gt;
&lt;td&gt;RTC Battery&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;FTDI (console only), Debug Header&lt;/td&gt;
&lt;td&gt;FTDI (console only), Debug Header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;JTAG Header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;OS Support&lt;/td&gt;
&lt;td&gt;Linux Kernel 3.x, OpenWrt, Yocto&lt;/td&gt;
&lt;td&gt;Linux Kernel 3.x, OpenWrt, Yocto&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Power&lt;/td&gt;
&lt;td&gt;Wide range 9-32V&lt;/td&gt;
&lt;td&gt;Wide range 9-32V&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Advanced Power Control&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Fan Control&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Dimensions&lt;/td&gt;
&lt;td&gt;100mm x 74mm&lt;/td&gt;
&lt;td&gt;225mm x 100mm&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;*available soon&lt;br /&gt;
**M.2 includes USB 3.0 support (in carrier Base only)&lt;/p&gt;

&lt;p&gt;More details can be found at the
&lt;a href=&#34;https://www.solid-run.com/marvell-armada-family/clearfog/&#34;&gt;ClearFog Pro&lt;/a&gt; product page.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ClearFog Pro (top view)&lt;/em&gt;
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-components-top-view-1.jpg&#34; alt=&#34;ClearFog Pro Top View&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ClearFog Pro (buttom view)&lt;/em&gt;
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-components-bottom-view.jpg&#34; alt=&#34;ClearFog Pro Buttom View&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;technical-highlights:568e70a5f9d2a7d5ec5b5140013e90f2&#34;&gt;Technical highlights&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;passive cooling&lt;/li&gt;
&lt;li&gt;all Ethernet ports supporting up to 1GBit/s at least&lt;/li&gt;
&lt;li&gt;the SFP Ethernet port supports up to 2.5GBit/s&lt;/li&gt;
&lt;li&gt;mSATA or miniPCIe mode can be configured&lt;/li&gt;
&lt;li&gt;M.2 slot supports a 2242 form factor M.2 card (22mm x 42mm)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;first-impressions:568e70a5f9d2a7d5ec5b5140013e90f2&#34;&gt;First impressions&lt;/h3&gt;

&lt;p&gt;We think you&amp;rsquo;ll get it now - this device is somewhat special.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not a real end-user product and it&amp;rsquo;s therefore called a development board. But the
ClearFog Pro is already equipped with some best-in-class components and has a superior
build quality - once you see it in person you&amp;rsquo;ll gonna know what we&amp;rsquo;re talking about.&lt;/p&gt;

&lt;h3 id=&#34;lot-s-of-possibilities:568e70a5f9d2a7d5ec5b5140013e90f2&#34;&gt;Lot&amp;rsquo;s of possibilities&lt;/h3&gt;

&lt;p&gt;As you now know some of the technical details of the ClearFog Pro, you can clearly
imagine what could be possible with such a board.&lt;/p&gt;

&lt;p&gt;So, we&amp;rsquo;re listing here only a few possibilities to start the brain storming&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a high-speed WiFi router with a 802.11n or 802.11ac miniPCIe card&lt;/li&gt;
&lt;li&gt;a NAS system with mSATA or M.2 SSD disks&lt;/li&gt;
&lt;li&gt;a personal router and firewall&lt;/li&gt;
&lt;li&gt;an ownCloud server&lt;/li&gt;
&lt;li&gt;a streaming server for audio and video tracks&lt;/li&gt;
&lt;li&gt;or maybe all this above at once&lt;/li&gt;
&lt;li&gt;a powerful Docker host with insane network performance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;hellip;and finally we&amp;rsquo;d like to ask you:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;What would you like to build with a ClearFog Pro?&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; new follow-up posts&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part 2: &lt;a href=&#34;http://blog.hypriot.com/post/clearfog-pro-part-2-lets-run-docker/&#34;&gt;Let&amp;rsquo;s run Docker on the ClearFog Pro router board&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;P.S. this ClearFog Pro (ARMADA A388 w/ 1GByte memory) is already hooked up for testing in our labs
&lt;img src=&#34;http://blog.hypriot.com/images/clearfog-pro-intro/clearfog-pro-cabled.jpg&#34; alt=&#34;ClearFog Pro Cabled&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>