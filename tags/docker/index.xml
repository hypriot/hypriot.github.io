<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Docker Pirates ARMed with explosive stuff</title>
    <link>https://blog.hypriot.com/tags/docker/index.xml</link>
    <description>Recent content in Docker on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://blog.hypriot.com/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NVIDIA Jetson Nano - Upgrade Docker Engine</title>
      <link>https://blog.hypriot.com/post/nvidia-jetson-nano-upgrade-docker/</link>
      <pubDate>Sat, 20 Apr 2019 13:47:52 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/nvidia-jetson-nano-upgrade-docker/</guid>
      <description>&lt;p&gt;In our last blogposts about the &lt;a href=&#34;https://blog.hypriot.com/post/nvidia-jetson-nano-intro/&#34;&gt;NVIDIA Jetson Nano Developer Kit - Introduction&lt;/a&gt; and &lt;a href=&#34;https://blog.hypriot.com/post/nvidia-jetson-nano-install-docker-compose/&#34;&gt;NVIDIA Jetson Nano - Install Docker Compose&lt;/a&gt; we digged into the brand-new &lt;strong&gt;NVIDIA Jetson Nano Developer Kit&lt;/strong&gt; and we know, that Docker 18.06.1-CE is already installed, but&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-docker-ce/jetson-desktop-login.jpg&#34; alt=&#34;jetson-desktop-login.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But, this isn&amp;rsquo;t the latest available version of the Docker Engine. So, I&amp;rsquo;d like to point you to a few different options on how to upgrade the Docker Engine to the very latest available version for the NVIDIA Jetson Nano.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;check-the-current-docker-version&#34;&gt;Check the current Docker Version&lt;/h3&gt;

&lt;p&gt;For this tutorial I&amp;rsquo;m starting again with a freshly flashed SD card image.&lt;/p&gt;

&lt;p&gt;Flashing from macOS just takes a few minutes with the Hypriot flash utility, which can be found here &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;https://github.com/hypriot/flash&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ time flash --device /dev/disk2 jetson-nano-sd-r32.1-2019-03-18.img

Is /dev/disk2 correct? y
Unmounting /dev/disk2 ...
Unmount of all volumes on disk2 was successful
Unmount of all volumes on disk2 was successful
Flashing jetson-nano-sd-r32.1-2019-03-18.img to /dev/rdisk2 ...
12.0GiB 0:03:40 [55.8MiB/s] [=======================================================================================&amp;gt;] 100%
0+196608 records in
0+196608 records out
12884901888 bytes transferred in 220.275160 secs (58494575 bytes/sec)
Mounting Disk

real	3m47.866s
user	0m1.648s
sys	0m30.921s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we have to attach a computer monitor via HDMI cable, mouse and keyboard and of course an Ethernet cable in order to get an internet connect. Now connecting to a micro-USB power supply and follow the instruction on the screen to perform the initial setup of the NVIDIA Jetson Nano Developer Kit. This will take around 5 to 10 minutes and we do have a new Ubuntu 18.04 desktop running on that nice 64bit ARM Cortex-A57 developer board.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro-Tip on using Docker client:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As we have seen in the last blogpost, we have to use sudo when we&amp;rsquo;re calling a docker command in the shell. This can be easily resolved, we only have to issue the following command ones.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo usermod -aG docker pirate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, log out and log in again or just start a new shell and we don&amp;rsquo;t have to use sudo any more for our docker commands.&lt;/p&gt;

&lt;p&gt;Show the current version of the Docker Engine installed on the Nano.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ docker version
Client:
 Version:           18.06.1-ce
 API version:       1.38
 Go version:        go1.10.1
 Git commit:        e68fc7a
 Built:             Fri Jan 25 14:35:17 2019
 OS/Arch:           linux/arm64
 Experimental:      false

Server:
 Engine:
  Version:          18.06.1-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.1
  Git commit:       e68fc7a
  Built:            Thu Jan 24 10:49:48 2019
  OS/Arch:          linux/arm64
  Experimental:     false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here we see the version &lt;code&gt;18.06.1-ce&lt;/code&gt; of the Docker Engine, which is installed on the Nano SD card image &lt;code&gt;jetson-nano-sd-r32.1-2019-03-18.img&lt;/code&gt;. And yes, this is by far not the latest nor the securest available version at all.&lt;/p&gt;

&lt;h3 id=&#34;upgrade-docker-engine&#34;&gt;Upgrade Docker Engine&lt;/h3&gt;

&lt;p&gt;As we&amp;rsquo;ve seen in the previous section, the installed Docker Engine version is 18.06.01-ce. Now let&amp;rsquo;s verify if there is already a newer version available.&lt;/p&gt;

&lt;p&gt;We can just use the apt utility from the Ubuntu package manager to determine the installed versions of any of the installed software packages. Here on Ubuntu 18.04 the Docker Engine is installed through the &lt;code&gt;docker.io&lt;/code&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ apt list --installed | grep docker.io

WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

docker.io/bionic-security,now 18.06.1-0ubuntu1.2~18.04.1 arm64 [installed,upgradable to: 18.09.2-0ubuntu1~18.04.1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see the newer Docker version 18.09.2 is already available in the Ubuntu repository, so we&amp;rsquo;re going to upgrade the software package &lt;code&gt;docker.io&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo apt-get --only-upgrade install docker.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end we were able to upgrade the Docker Engine to the very latest version which is provided by the Ubuntu repository.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ docker version
Client:
 Version:           18.09.2
 API version:       1.39
 Go version:        go1.10.4
 Git commit:        6247962
 Built:             Tue Feb 26 23:51:35 2019
 OS/Arch:           linux/arm64
 Experimental:      false

Server:
 Engine:
  Version:          18.09.2
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.4
  Git commit:       6247962
  Built:            Wed Feb 13 00:24:14 2019
  OS/Arch:          linux/arm64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we have upgraded the Docker Engine to version 18.09.2. Please keep in mind, this version of the Docker Engine is provided by the Ubuntu repository. Maybe there is even a newer version available directly from the Docker open source project.&lt;/p&gt;

&lt;h3 id=&#34;recommendation-install-official-docker-engine-ce&#34;&gt;Recommendation: Install official Docker Engine CE&lt;/h3&gt;

&lt;p&gt;For this step I can truely recommend to use the official Docker documentation for the Community Edition. For installing Docker Engine CE on Ubuntu you can directly follow the detailled steps at &lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;https://docs.docker.com/install/linux/docker-ce/ubuntu/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you can see later, Docker Engine CE is also available for ARM 64bit on Ubuntu 18.04 LTS. It&amp;rsquo;s not too complicated to set it up, just follow the installation steps in this documentation and within a few minutes you have installed the official Docker Engine!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; Uninstall old versions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-get remove docker docker-engine docker.io containerd runc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; Set up the repository&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 1. Update the apt package index:
$ sudo apt-get update

# 2. Install packages to allow apt to use a repository over HTTPS:
$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common

# 3. Add Dockerâ€™s official GPG key:
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

$ sudo apt-key fingerprint 0EBFCD88
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &amp;lt;docker@docker.com&amp;gt;
sub   rsa4096 2017-02-22 [S]

# 4. Use the following command to set up the stable repository:
#    here select the commands for &amp;quot;arm64&amp;quot;
$ sudo add-apt-repository \
   &amp;quot;deb [arch=arm64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Alternatively you can also select the &amp;quot;edge&amp;quot; channel for the very latest version
$ sudo add-apt-repository \
   &amp;quot;deb [arch=arm64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   edge&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 3:&lt;/strong&gt; Install Docker CE&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 1. Update the apt package index.
$ sudo apt-get update

# 2. Install the latest version of Docker CE and containerd
$ sudo apt-get install docker-ce docker-ce-cli containerd.io

# 3. Add user &amp;quot;pirate&amp;quot; to the group &amp;quot;docker&amp;quot;, so we don&#39;t need sudo
$ sudo usermod -aG docker pirate
# Now logout and login again
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 4:&lt;/strong&gt; Show the installed Docker Engine version&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ docker version
Client:
 Version:           18.09.5
 API version:       1.39
 Go version:        go1.10.8
 Git commit:        e8ff056
 Built:             Thu Apr 11 04:48:27 2019
 OS/Arch:           linux/arm64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.5
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.8
  Git commit:       e8ff056
  Built:            Thu Apr 11 04:11:17 2019
  OS/Arch:          linux/arm64
  Experimental:     false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 5:&lt;/strong&gt; Run the &lt;code&gt;docker info&lt;/code&gt; command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 18.09.5
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version: bb71b10fd8f58240ca47fbb579b9d1028eea7c84
runc version: 2b18fe1d885ee5083ef9f0838fee39b62d653e30
init version: fec3683
Security Options:
 seccomp
  Profile: default
Kernel Version: 4.9.140-tegra
Operating System: Ubuntu 18.04.2 LTS
OSType: linux
Architecture: aarch64
CPUs: 4
Total Memory: 3.868GiB
Name: jetson-nano
ID: 4JER:EIWM:QFNF:6N2C:YUW3:YES2:RSP5:Z4D2:7PKI:YAOT:G5O7:5N25
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
Labels:
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Product License: Community Engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 6:&lt;/strong&gt;  Start first Docker container&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ docker run hello-world
Unable to find image &#39;hello-world:latest&#39; locally
latest: Pulling from library/hello-world
3b4173355427: Pull complete
Digest: sha256:92695bc579f31df7a63da6922075d0666e565ceccad16b59c3374d2cf4e8e50e
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
    (arm64v8)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-docker-ce/jetson-desktop-docker-ce.jpg&#34; alt=&#34;jetson-desktop-docker-ce.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;As you could see, on the Jetson Nano DevKit there is already a version of the Docker Engine installed and it&amp;rsquo;s maintained by the Ubuntu project. But this is not the latest version available and it will not get updated fast enough to include all important security fixes in time.&lt;/p&gt;

&lt;p&gt;Therefore I&amp;rsquo;d like to strongly recommend to use the Docker Engine CE from the official Docker project. It&amp;rsquo;s well maintained and updated in time. All installation steps and options are also extremely well documented at &lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;https://docs.docker.com/install/linux/docker-ce/ubuntu/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And in case you need more help or having some technical questions about running Docker on an ARM 64bit system like the NVIDIA Jetson Nano, there is an &lt;code&gt;arm&lt;/code&gt; Slack channel available for you at the &lt;a href=&#34;https://dockercommunity.slack.com/messages/C2293P89Y&#34;&gt;DockerCommunity Slack&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>NVIDIA Jetson Nano - Install Docker Compose</title>
      <link>https://blog.hypriot.com/post/nvidia-jetson-nano-install-docker-compose/</link>
      <pubDate>Sat, 20 Apr 2019 09:51:52 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/nvidia-jetson-nano-install-docker-compose/</guid>
      <description>&lt;p&gt;In our last blogpost &lt;a href=&#34;https://blog.hypriot.com/post/nvidia-jetson-nano-intro/&#34;&gt;NVIDIA Jetson Nano Developer Kit - Introduction&lt;/a&gt; we digged into the brand-new &lt;strong&gt;NVIDIA Jetson Nano Developer Kit&lt;/strong&gt; and we did found out, that Docker 18.06.1-CE is already pre-installed on this great ARM board.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/Jetson-Nano-Upacked.jpg&#34; alt=&#34;Jetson-Nano-Upacked.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Today, I want to share some more details on how you can easily install Docker Compose on the Jetson Nano.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;install-docker-compose&#34;&gt;Install Docker Compose&lt;/h3&gt;

&lt;p&gt;Sadly, there is no binary of &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker Compose&lt;/a&gt; available we could install directly on an ARM 64bit board like the NVIDIA Jetson Nano. If we are looking at the official GitHub release page for Docker Compose &lt;a href=&#34;https://github.com/docker/compose/releases/tag/1.24.0&#34;&gt;https://github.com/docker/compose/releases/tag/1.24.0&lt;/a&gt; there are only binaries provided for Intel x86-64 based operating systems like Linux, macOS and Windows - but nothing for ARM 32bit or 64bit systems.&lt;/p&gt;

&lt;p&gt;This isn&amp;rsquo;t too bad, because Docker Compose is based upon Python and maybe it&amp;rsquo;s easier to install if Python is already available on our board. So, let&amp;rsquo;s check this out the easy way.&lt;/p&gt;

&lt;h3 id=&#34;docker-compose-is-based-upon-python&#34;&gt;Docker Compose is based upon Python&lt;/h3&gt;

&lt;p&gt;First, check out if Python is already available on the Jetson Nano. As we have a complete Ubuntu 18.04 LTS desktop operation system this is very likely. But let&amp;rsquo;s verify it directly on a shell running on the Nano. This can be done from the desktop terminal app or via a SSH shell.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ python --version
Python 2.7.15rc1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, this looks pretty promising. We do have the Python version 2.7.15rc1 already installed on the Nano.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try to install Docker Compose via Python PIP. So, first we need to install Python PIP itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# first, we have to install Python PIP
$ sudo apt-get update -y
$ sudo apt-get install -y curl
$ curl -sSL https://bootstrap.pypa.io/get-pip.py | sudo python

# verify the installed Python PIP version
pirate@jetson-nano:~$ pip --version
pip 19.0.3 from /usr/local/lib/python2.7/dist-packages/pip (python 2.7)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s try to install Docker Compose via Python PIP. Here we&amp;rsquo;re going to pin the latest version of Docker Compose, which is 1.24.0 of the time of writing this blogpost.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# install Docker Compose via pip
export DOCKER_COMPOSE_VERSION=1.24.0
sudo pip install docker-compose==&amp;quot;${DOCKER_COMPOSE_VERSION}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this will throw a lot of error messages because it seems we do miss some required build dependencies. If you&amp;rsquo;re interested here are the full details.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ curl -sSL https://bootstrap.pypa.io/get-pip.py | sudo python
DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won&#39;t be maintained after that date. A future version of pip will drop support for Python 2.7.
The directory &#39;/home/pirate/.cache/pip/http&#39; or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&#39;s -H flag.
The directory &#39;/home/pirate/.cache/pip&#39; or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&#39;s -H flag.
Collecting pip
  Downloading https://files.pythonhosted.org/packages/d8/f3/413bab4ff08e1fc4828dfc59996d721917df8e8583ea85385d51125dceff/pip-19.0.3-py2.py3-none-any.whl (1.4MB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1.4MB 843kB/s
Collecting setuptools
  Downloading https://files.pythonhosted.org/packages/c8/b0/cc6b7ba28d5fb790cf0d5946df849233e32b8872b6baca10c9e002ff5b41/setuptools-41.0.0-py2.py3-none-any.whl (575kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 583kB 761kB/s
Collecting wheel
  Downloading https://files.pythonhosted.org/packages/96/ba/a4702cbb6a3a485239fbe9525443446203f00771af9ac000fa3ef2788201/wheel-0.33.1-py2.py3-none-any.whl
Installing collected packages: pip, setuptools, wheel
Successfully installed pip-19.0.3 setuptools-41.0.0 wheel-0.33.1
pirate@jetson-nano:~$ pip --version
pip 19.0.3 from /usr/local/lib/python2.7/dist-packages/pip (python 2.7)

pirate@jetson-nano:~$ export DOCKER_COMPOSE_VERSION=1.24.0
pirate@jetson-nano:~$ sudo pip install docker-compose==&amp;quot;${DOCKER_COMPOSE_VERSION}&amp;quot;
DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won&#39;t be maintained after that date. A future version of pip will drop support for Python 2.7.
The directory &#39;/home/pirate/.cache/pip/http&#39; or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&#39;s -H flag.
The directory &#39;/home/pirate/.cache/pip&#39; or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&#39;s -H flag.
Collecting docker-compose==1.24.0
  Downloading https://files.pythonhosted.org/packages/51/56/5745e66b33846e92a8814466c163f165a26fadad8b33afe381e8b6c3f652/docker_compose-1.24.0-py2.py3-none-any.whl (134kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 143kB 2.3MB/s
Collecting cached-property&amp;lt;2,&amp;gt;=1.2.0 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/3b/86/85c1be2e8db9e13ef9a350aecd6dea292bd612fa288c2f40d035bb750ded/cached_property-1.5.1-py2.py3-none-any.whl
Collecting docopt&amp;lt;0.7,&amp;gt;=0.6.1 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/a2/55/8f8cab2afd404cf578136ef2cc5dfb50baa1761b68c9da1fb1e4eed343c9/docopt-0.6.2.tar.gz
Collecting jsonschema&amp;lt;3,&amp;gt;=2.5.1 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/77/de/47e35a97b2b05c2fadbec67d44cfcdcd09b8086951b331d82de90d2912da/jsonschema-2.6.0-py2.py3-none-any.whl
Collecting backports.ssl-match-hostname&amp;gt;=3.5; python_version &amp;lt; &amp;quot;3.5&amp;quot; (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/ff/2b/8265224812912bc5b7a607c44bf7b027554e1b9775e9ee0de8032e3de4b2/backports.ssl_match_hostname-3.7.0.1.tar.gz
Requirement already satisfied: six&amp;lt;2,&amp;gt;=1.3.0 in /usr/lib/python2.7/dist-packages (from docker-compose==1.24.0) (1.11.0)
Collecting ipaddress&amp;gt;=1.0.16; python_version &amp;lt; &amp;quot;3.3&amp;quot; (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/fc/d0/7fc3a811e011d4b388be48a0e381db8d990042df54aa4ef4599a31d39853/ipaddress-1.0.22-py2.py3-none-any.whl
Collecting requests!=2.11.0,!=2.12.2,!=2.18.0,&amp;lt;2.21,&amp;gt;=2.6.1 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/ff/17/5cbb026005115301a8fb2f9b0e3e8d32313142fe8b617070e7baad20554f/requests-2.20.1-py2.py3-none-any.whl (57kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 61kB 2.8MB/s
Collecting texttable&amp;lt;0.10,&amp;gt;=0.9.0 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/02/e1/2565e6b842de7945af0555167d33acfc8a615584ef7abd30d1eae00a4d80/texttable-0.9.1.tar.gz
Collecting dockerpty&amp;lt;0.5,&amp;gt;=0.4.1 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/8d/ee/e9ecce4c32204a6738e0a5d5883d3413794d7498fe8b06f44becc028d3ba/dockerpty-0.4.1.tar.gz
Collecting enum34&amp;lt;2,&amp;gt;=1.0.4; python_version &amp;lt; &amp;quot;3.4&amp;quot; (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/c5/db/e56e6b4bbac7c4a06de1c50de6fe1ef3810018ae11732a50f15f62c7d050/enum34-1.1.6-py2-none-any.whl
Collecting PyYAML&amp;lt;4.3,&amp;gt;=3.10 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/9e/a3/1d13970c3f36777c583f136c136f804d70f500168edc1edea6daa7200769/PyYAML-3.13.tar.gz (270kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 276kB 2.9MB/s
Collecting websocket-client&amp;lt;1.0,&amp;gt;=0.32.0 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/29/19/44753eab1fdb50770ac69605527e8859468f3c0fd7dc5a76dd9c4dbd7906/websocket_client-0.56.0-py2.py3-none-any.whl (200kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 204kB 3.2MB/s
Collecting docker[ssh]&amp;lt;4.0,&amp;gt;=3.7.0 (from docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/48/68/c3afca1a5aa8d2997ec3b8ee822a4d752cf85907b321f07ea86888545152/docker-3.7.2-py2.py3-none-any.whl (134kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 143kB 3.5MB/s
Collecting functools32; python_version == &amp;quot;2.7&amp;quot; (from jsonschema&amp;lt;3,&amp;gt;=2.5.1-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/c5/60/6ac26ad05857c601308d8fb9e87fa36d0ebf889423f47c3502ef034365db/functools32-3.2.3-2.tar.gz
Collecting urllib3&amp;lt;1.25,&amp;gt;=1.21.1 (from requests!=2.11.0,!=2.12.2,!=2.18.0,&amp;lt;2.21,&amp;gt;=2.6.1-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/df/1c/59cca3abf96f991f2ec3131a4ffe72ae3d9ea1f5894abe8a9c5e3c77cfee/urllib3-1.24.2-py2.py3-none-any.whl (131kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 133kB 3.2MB/s
Collecting chardet&amp;lt;3.1.0,&amp;gt;=3.0.2 (from requests!=2.11.0,!=2.12.2,!=2.18.0,&amp;lt;2.21,&amp;gt;=2.6.1-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/bc/a9/01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 143kB 3.5MB/s
Collecting idna&amp;lt;2.8,&amp;gt;=2.5 (from requests!=2.11.0,!=2.12.2,!=2.18.0,&amp;lt;2.21,&amp;gt;=2.6.1-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/4b/2a/0276479a4b3caeb8a8c1af2f8e4355746a97fab05a372e4a2c6a6b876165/idna-2.7-py2.py3-none-any.whl (58kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 61kB 5.8MB/s
Collecting certifi&amp;gt;=2017.4.17 (from requests!=2.11.0,!=2.12.2,!=2.18.0,&amp;lt;2.21,&amp;gt;=2.6.1-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/60/75/f692a584e85b7eaba0e03827b3d51f45f571c2e793dd731e598828d380aa/certifi-2019.3.9-py2.py3-none-any.whl (158kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 163kB 353kB/s
Collecting docker-pycreds&amp;gt;=0.4.0 (from docker[ssh]&amp;lt;4.0,&amp;gt;=3.7.0-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/f5/e8/f6bd1eee09314e7e6dee49cbe2c5e22314ccdb38db16c9fc72d2fa80d054/docker_pycreds-0.4.0-py2.py3-none-any.whl
Collecting paramiko&amp;gt;=2.4.2; extra == &amp;quot;ssh&amp;quot; (from docker[ssh]&amp;lt;4.0,&amp;gt;=3.7.0-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/cf/ae/94e70d49044ccc234bfdba20114fa947d7ba6eb68a2e452d89b920e62227/paramiko-2.4.2-py2.py3-none-any.whl (193kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 194kB 3.2MB/s
Collecting pyasn1&amp;gt;=0.1.7 (from paramiko&amp;gt;=2.4.2; extra == &amp;quot;ssh&amp;quot;-&amp;gt;docker[ssh]&amp;lt;4.0,&amp;gt;=3.7.0-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/7b/7c/c9386b82a25115cccf1903441bba3cbadcfae7b678a20167347fa8ded34c/pyasn1-0.4.5-py2.py3-none-any.whl (73kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 81kB 3.2MB/s
Collecting bcrypt&amp;gt;=3.1.3 (from paramiko&amp;gt;=2.4.2; extra == &amp;quot;ssh&amp;quot;-&amp;gt;docker[ssh]&amp;lt;4.0,&amp;gt;=3.7.0-&amp;gt;docker-compose==1.24.0)
  Downloading https://files.pythonhosted.org/packages/ce/3a/3d540b9f5ee8d92ce757eebacf167b9deedb8e30aedec69a2a072b2399bb/bcrypt-3.1.6.tar.gz (42kB)
    100% |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 51kB 8.4MB/s
  Installing build dependencies ... error
  Complete output from command /usr/bin/python /usr/local/lib/python2.7/dist-packages/pip install --ignore-installed --no-user --prefix /tmp/pip-build-env-qwOdIW/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools wheel &amp;quot;cffi&amp;gt;=1.1; python_implementation != &#39;PyPy&#39;&amp;quot;:
  DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won&#39;t be maintained after that date. A future version of pip will drop support for Python 2.7.
  The directory &#39;/home/pirate/.cache/pip/http&#39; or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&#39;s -H flag.
  The directory &#39;/home/pirate/.cache/pip&#39; or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&#39;s -H flag.
  Collecting setuptools
    Downloading https://files.pythonhosted.org/packages/c8/b0/cc6b7ba28d5fb790cf0d5946df849233e32b8872b6baca10c9e002ff5b41/setuptools-41.0.0-py2.py3-none-any.whl (575kB)
  Collecting wheel
    Downloading https://files.pythonhosted.org/packages/96/ba/a4702cbb6a3a485239fbe9525443446203f00771af9ac000fa3ef2788201/wheel-0.33.1-py2.py3-none-any.whl
  Collecting cffi&amp;gt;=1.1
    Downloading https://files.pythonhosted.org/packages/93/1a/ab8c62b5838722f29f3daffcc8d4bd61844aa9b5f437341cc890ceee483b/cffi-1.12.3.tar.gz (456kB)
  Collecting pycparser (from cffi&amp;gt;=1.1)
    Downloading https://files.pythonhosted.org/packages/68/9e/49196946aee219aead1290e00d1e7fdeab8567783e83e1b9ab5585e6206a/pycparser-2.19.tar.gz (158kB)
  Installing collected packages: setuptools, wheel, pycparser, cffi
    Running setup.py install for pycparser: started
      Running setup.py install for pycparser: finished with status &#39;done&#39;
    Running setup.py install for cffi: started
      Running setup.py install for cffi: finished with status &#39;error&#39;
      Complete output from command /usr/bin/python -u -c &amp;quot;import setuptools, tokenize;__file__=&#39;/tmp/pip-install-XfNg4G/cffi/setup.py&#39;;f=getattr(tokenize, &#39;open&#39;, open)(__file__);code=f.read().replace(&#39;\r\n&#39;, &#39;\n&#39;);f.close();exec(compile(code, __file__, &#39;exec&#39;))&amp;quot; install --record /tmp/pip-record-lpvT6b/install-record.txt --single-version-externally-managed --prefix /tmp/pip-build-env-qwOdIW/overlay --compile:
      Package libffi was not found in the pkg-config search path.
      Perhaps you should add the directory containing `libffi.pc&#39;
      to the PKG_CONFIG_PATH environment variable
      No package &#39;libffi&#39; found
      Package libffi was not found in the pkg-config search path.
      Perhaps you should add the directory containing `libffi.pc&#39;
      to the PKG_CONFIG_PATH environment variable
      No package &#39;libffi&#39; found
      Package libffi was not found in the pkg-config search path.
      Perhaps you should add the directory containing `libffi.pc&#39;
      to the PKG_CONFIG_PATH environment variable
      No package &#39;libffi&#39; found
      Package libffi was not found in the pkg-config search path.
      Perhaps you should add the directory containing `libffi.pc&#39;
      to the PKG_CONFIG_PATH environment variable
      No package &#39;libffi&#39; found
      Package libffi was not found in the pkg-config search path.
      Perhaps you should add the directory containing `libffi.pc&#39;
      to the PKG_CONFIG_PATH environment variable
      No package &#39;libffi&#39; found
      running install
      running build
      running build_py
      creating build
      creating build/lib.linux-aarch64-2.7
      creating build/lib.linux-aarch64-2.7/cffi
      copying cffi/ffiplatform.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/vengine_gen.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/setuptools_ext.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/verifier.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/backend_ctypes.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/vengine_cpy.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/pkgconfig.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/recompiler.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/api.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/cparser.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/__init__.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/cffi_opcode.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/error.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/lock.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/model.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/commontypes.py -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/_cffi_include.h -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/parse_c_type.h -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/_embedding.h -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      copying cffi/_cffi_errors.h -&amp;gt; build/lib.linux-aarch64-2.7/cffi
      running build_ext
      building &#39;_cffi_backend&#39; extension
      creating build/temp.linux-aarch64-2.7
      creating build/temp.linux-aarch64-2.7/c
      aarch64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fno-strict-aliasing -Wdate-time -D_FORTIFY_SOURCE=2 -g -fdebug-prefix-map=/build/python2.7-ytvI67/python2.7-2.7.15~rc1=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -DUSE__THREAD -DHAVE_SYNC_SYNCHRONIZE -I/usr/include/ffi -I/usr/include/libffi -I/usr/include/python2.7 -c c/_cffi_backend.c -o build/temp.linux-aarch64-2.7/c/_cffi_backend.o
      c/_cffi_backend.c:15:10: fatal error: ffi.h: No such file or directory
       #include &amp;lt;ffi.h&amp;gt;
                ^~~~~~~
      compilation terminated.
      error: command &#39;aarch64-linux-gnu-gcc&#39; failed with exit status 1

      ----------------------------------------
  Command &amp;quot;/usr/bin/python -u -c &amp;quot;import setuptools, tokenize;__file__=&#39;/tmp/pip-install-XfNg4G/cffi/setup.py&#39;;f=getattr(tokenize, &#39;open&#39;, open)(__file__);code=f.read().replace(&#39;\r\n&#39;, &#39;\n&#39;);f.close();exec(compile(code, __file__, &#39;exec&#39;))&amp;quot; install --record /tmp/pip-record-lpvT6b/install-record.txt --single-version-externally-managed --prefix /tmp/pip-build-env-qwOdIW/overlay --compile&amp;quot; failed with error code 1 in /tmp/pip-install-XfNg4G/cffi/

  ----------------------------------------
Command &amp;quot;/usr/bin/python /usr/local/lib/python2.7/dist-packages/pip install --ignore-installed --no-user --prefix /tmp/pip-build-env-qwOdIW/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools wheel &amp;quot;cffi&amp;gt;=1.1; python_implementation != &#39;PyPy&#39;&amp;quot;&amp;quot; failed with error code 1 in None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After some investigation we&amp;rsquo;re able to identify the missing build dependencies and here are the required commands to install it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# install Docker Compose build dependencies for Ubuntu 18.04 on aarch64
$ sudo apt-get install -y libffi-dev
$ sudo apt-get install -y python-openssl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-docker-compose-via-python-pip&#34;&gt;Install Docker Compose via Python PIP&lt;/h3&gt;

&lt;p&gt;TL;DR These are all commands you need to install Docker Compose on a freshly installed NVIDIA Jetson Nano.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# step 1, install Python PIP
$ sudo apt-get update -y
$ sudo apt-get install -y curl
$ curl -sSL https://bootstrap.pypa.io/get-pip.py | sudo python

# step 2, install Docker Compose build dependencies for Ubuntu 18.04 on aarch64
$ sudo apt-get install -y libffi-dev
$ sudo apt-get install -y python-openssl

# step 3, install latest Docker Compose via pip
$ export DOCKER_COMPOSE_VERSION=1.24.0
$ sudo pip install docker-compose==&amp;quot;${DOCKER_COMPOSE_VERSION}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Finally we have the latest available Docker Compose version 1.24.0 installed on the NVIDIA Jetson Nano. It just takes a few minutes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ docker-compose version
docker-compose version 1.24.0, build 0aa5906
docker-py version: 3.7.2
CPython version: 2.7.15rc1
OpenSSL version: OpenSSL 1.1.0g  2 Nov 2017

pirate@jetson-nano:~$ docker-compose --version
docker-compose version 1.24.0, build 0aa5906
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;another-pro-tip-on-using-docker-command-line-interface&#34;&gt;Another Pro-Tip on using Docker command line interface&lt;/h3&gt;

&lt;p&gt;As we have seen in the last blogpost, we have to use sudo when we&amp;rsquo;re calling a docker command in the shell. This can be easy resolved, we only have to issue the following command ones.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo usermod -aG docker pirate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, log out and log in again or just start a new shell and we don&amp;rsquo;t have to use sudo any more for our docker commands.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ docker version
Client:
 Version:           18.06.1-ce
 API version:       1.38
 Go version:        go1.10.1
 Git commit:        e68fc7a
 Built:             Fri Jan 25 14:35:17 2019
 OS/Arch:           linux/arm64
 Experimental:      false

Server:
 Engine:
  Version:          18.06.1-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.1
  Git commit:       e68fc7a
  Built:            Thu Jan 24 10:49:48 2019
  OS/Arch:          linux/arm64
  Experimental:     false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>NVIDIA Jetson Nano Developer Kit - Introduction</title>
      <link>https://blog.hypriot.com/post/nvidia-jetson-nano-intro/</link>
      <pubDate>Fri, 19 Apr 2019 14:16:25 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/nvidia-jetson-nano-intro/</guid>
      <description>&lt;p&gt;Let me introduce the brand new &lt;strong&gt;NVIDIA Jetson Nano Developer Kit&lt;/strong&gt;, which is basically a quad-core 64bit ARM Cortex-A57 CPU with 128 GPU cores - suitable for all kinds of maker ideas: AI, Robotics, and of course for running Docker Containers&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/Jetson-Nano-Box.jpg&#34; alt=&#34;Jetson-Nano-Box.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;unboxing&#34;&gt;Unboxing&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s unbox the board and do the initial configuration&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/Jetson-Nano-Upacked.jpg&#34; alt=&#34;Jetson-Nano-Upacked.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When opening the box we&amp;rsquo;ll find the board itself and a short getting started flyer which heads us to the NVIDIA website &lt;a href=&#34;https://NVIDIA.com/JetsonNano-Start&#34;&gt;https://NVIDIA.com/JetsonNano-Start&lt;/a&gt; where we can find all basic information about the new DevKit.&lt;/p&gt;

&lt;p&gt;Please note, there are no other parts included in the DevKit. So, in order to use the DevKit you&amp;rsquo;ll need some additional accessories:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MicroSD card (at least 16GByte)&lt;/li&gt;
&lt;li&gt;Monitor with HDMI or DisplayPort connector&lt;/li&gt;
&lt;li&gt;HDMI or DisplayPort cable to connect to the monitor&lt;/li&gt;
&lt;li&gt;USB Keyboard and Mouse&lt;/li&gt;
&lt;li&gt;Micro-USB power supply (5V, 2Amps for 10 watts)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;Following the official documentation &lt;a href=&#34;https://developer.nvidia.com/embedded/learn/get-started-jetson-nano-devkit&#34;&gt;Getting Started With Jetson Nano Developer Kit&lt;/a&gt; we have to download and flash the SD card. I don&amp;rsquo;t want to repeat these basic steps here, because it&amp;rsquo;s covered in great detail directy in the official NVIDIA tutorial &lt;a href=&#34;https://developer.nvidia.com/embedded/learn/get-started-jetson-nano-devkit#write&#34;&gt;Write Image to the microSD Card&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When downloading the SD card image, please be aware this one isn&amp;rsquo;t small at all. The download is a zipped image file of 5 GByte of compressed data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -alh jetson-nano-sd-r32.1-2019-03-18.zip
-rw-r--r--@ 1 dieter  staff   5.3G Mar 15 22:49 jetson-nano-sd-r32.1-2019-03-18.zip 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The SD card image is a huge 12 GByte data blob. I would strongly recommend to use a SD card size with at least 32 GByte, with the recommended 16 GByte minimum you won&amp;rsquo;t get really happy. So, please do yourself a favour and get a 32 or 64 GByte SD card.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -alh jetson-nano-sd-r32.1-2019-03-18.img
-rwxr-xr-x  1 dieter  staff    12G Mar 15 19:19 jetson-nano-sd-r32.1-2019-03-18.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For flashing the SD card image you could also use the Hypriot &lt;code&gt;flash&lt;/code&gt; tool, which can be found here &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;https://github.com/hypriot/flash&lt;/a&gt;. That&amp;rsquo;s exactly what I did from macOS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ flash --device /dev/disk2 jetson-nano-sd-r32.1-2019-03-18.img

Is /dev/disk2 correct? y
Unmounting /dev/disk2 ...
Unmount of all volumes on disk2 was successful
Unmount of all volumes on disk2 was successful
Flashing jetson-nano-sd-r32.1-2019-03-18.img to /dev/rdisk2 ...
Password:
12.0GiB 0:03:58 [51.6MiB/s] [=======================================================================================&amp;gt;] 100%
0+196608 records in
0+196608 records out
12884901888 bytes transferred in 234.213296 secs (55013537 bytes/sec)
Mounting Disk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our SD card is flashed with the latest image version, which is from March 18th 2019 as of time of this writing. But before using the SD card to boot up the NVIDIA Jetson Nano device, let&amp;rsquo;s have a short look at what&amp;rsquo;s on the SD card. Please, re-insert the SD card and list the current partitions. On macOS it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diskutil list /dev/disk2
/dev/disk2 (external, physical):
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:      GUID_partition_scheme                        *64.0 GB    disk2
   1:           Linux Filesystem                         12.9 GB    disk2s1
   2:           Linux Filesystem                         131.1 KB   disk2s2
   3:           Linux Filesystem                         458.8 KB   disk2s3
   4:           Linux Filesystem                         589.8 KB   disk2s4
   5:           Linux Filesystem                         65.5 KB    disk2s5
   6:           Linux Filesystem                         196.6 KB   disk2s6
   7:           Linux Filesystem                         589.8 KB   disk2s7
   8:           Linux Filesystem                         65.5 KB    disk2s8
   9:           Linux Filesystem                         655.4 KB   disk2s9
  10:           Linux Filesystem                         458.8 KB   disk2s10
  11:           Linux Filesystem                         131.1 KB   disk2s11
  12:           Linux Filesystem                         81.9 KB    disk2s12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, we&amp;rsquo;ll find at least 12 different partitions from NVIDIA. Currently we don&amp;rsquo;t look into all the details, maybe we can do this as part of a future blog post. For now we just know, 12 partitions are here and therefore flashing should be successful.&lt;/p&gt;

&lt;h3 id=&#34;initial-configuration&#34;&gt;Initial Configuration&lt;/h3&gt;

&lt;p&gt;For &lt;a href=&#34;https://developer.nvidia.com/embedded/learn/get-started-jetson-nano-devkit#setup&#34;&gt;Setup and First Boot&lt;/a&gt; of the NVIDIA Jetson Nano DevKit you need to attach a computer display, mouse and keyboard. All these steps are well documented at the NVIDIA web site, just following the prior hyperlink.&lt;/p&gt;

&lt;p&gt;Then power up the board with the Micro-USB power supply and follow the tutorial. This procedure will take a few minutes and then you&amp;rsquo;ll have a fully configured desktop system up and running which is based upon Ubuntu 18.04 LTS.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/Jetson-Nano-Board-Closeup.jpg&#34; alt=&#34;Jetson-Nano-Board-Closeup.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As I already said, the initial configuration of the Nano board has to be done interactively with the help of a computer monitor, mouse and keyboard. It&amp;rsquo;s really straight forward and consists of the following steps and settings. I also did a short video of this initial setup, so it&amp;rsquo;s maybe a little bit easier for you to follow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Settings:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Accept NVIDIA End User License Agreements: YES&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Select system language: ENGLISH&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Select keyboard layout: ENGLISH (US)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Select location/timezone: BERLIN&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set username: pirate&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set computer name: jetson-nano&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set password: hypriot&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[Here is the video link: NVIDIA-Jetson-Nano&amp;ndash;Initial-Setup &lt;strong&gt;Coming soon!&lt;/strong&gt;]&lt;/p&gt;

&lt;p&gt;At the end we login with the defined username &amp;ldquo;pirate&amp;rdquo; and get this nice Ubuntu desktop on our computer monitor. Yes, it&amp;rsquo;s really a fully Linux desktop system running on a 64bit ARM Cortex A57 board with 4 GByte of memory!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/jetson-desktop.jpg&#34; alt=&#34;jetson-desktop.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;running-docker&#34;&gt;Running Docker&lt;/h3&gt;

&lt;p&gt;TL;DR &lt;strong&gt;Docker is running out-of-the-box on the NVIDIA Jetson Nano board!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[Here is the video link: NVIDIA-Jetson-Nano&amp;ndash;Running-Docker &lt;strong&gt;Coming soon!&lt;/strong&gt;]&lt;/p&gt;

&lt;p&gt;As soon as the Jetson Nano board is configured and attached with an ethernet network cable, we can also discover it on the network with ping. Just use the computer name you defined. Here I used &lt;code&gt;jetson-nano&lt;/code&gt;, or you have to add &lt;code&gt;.local&lt;/code&gt;, this depends on your router setup. But just trying both it&amp;rsquo;s easy to do.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ping -c 3 jetson-nano
PING jetson-nano.lan (192.168.7.158): 56 data bytes
64 bytes from 192.168.7.158: icmp_seq=0 ttl=64 time=1.786 ms
64 bytes from 192.168.7.158: icmp_seq=1 ttl=64 time=1.954 ms
64 bytes from 192.168.7.158: icmp_seq=2 ttl=64 time=2.227 ms

--- jetson-nano.lan ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 1.786/1.989/2.227/0.182 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ping -c 3 jetson-nano.local
PING jetson-nano.local (192.168.7.158): 56 data bytes
64 bytes from 192.168.7.158: icmp_seq=0 ttl=64 time=1.338 ms
64 bytes from 192.168.7.158: icmp_seq=1 ttl=64 time=2.198 ms
64 bytes from 192.168.7.158: icmp_seq=2 ttl=64 time=1.964 ms

--- jetson-nano.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 1.338/1.833/2.198/0.363 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, I&amp;rsquo;m going to check the kernel version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ uname -a
Linux jetson-nano 4.9.140-tegra #1 SMP PREEMPT Wed Mar 13 00:32:22 PDT 2019 aarch64 aarch64 aarch64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We do have a LTS 4.9 kernel available on the Jetson Nano, which is pretty OK for running Docker and Containers.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s check if there is already a Docker Engine preinstalled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker version
[sudo] password for pirate:
Client:
 Version:           18.06.1-ce
 API version:       1.38
 Go version:        go1.10.1
 Git commit:        e68fc7a
 Built:             Fri Jan 25 14:35:17 2019
 OS/Arch:           linux/arm64
 Experimental:      false

Server:
 Engine:
  Version:          18.06.1-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.1
  Git commit:       e68fc7a
  Built:            Thu Jan 24 10:49:48 2019
  OS/Arch:          linux/arm64
  Experimental:     false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And show what details we&amp;rsquo;ll get from a &lt;code&gt;docker info&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker info
Containers: 2
 Running: 2
 Paused: 0
 Stopped: 0
Images: 1
Server Version: 18.06.1-ce
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version:  (expected: 468a545b9edcd5932818eb9de8e72413e616e86e)
runc version: N/A (expected: 69663f0bd4b60df09991c08812a60108003fa340)
init version: v0.18.0 (expected: fec3683b971d9c3ef73f284f176672c44b448662)
Security Options:
 seccomp
  Profile: default
Kernel Version: 4.9.140-tegra
Operating System: Ubuntu 18.04.2 LTS
OSType: linux
Architecture: aarch64
CPUs: 4
Total Memory: 3.868GiB
Name: jetson-nano
ID: CR66:D4BV:6TQC:GI4I:CXLP:EQMK:NK2P:FUFM:OATD:5F6M:J657:LU5T
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
Labels:
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is another screenshot directly from the Jetson Nano desktop with running the &lt;code&gt;docker version&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/jetson-desktop-docker.jpg&#34; alt=&#34;jetson-desktop-docker.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;starting-a-docker-container-for-arm&#34;&gt;Starting a Docker Container for ARM&lt;/h3&gt;

&lt;p&gt;Pull a first Docker Image which should run on ARM, here I&amp;rsquo;m going to use a Docker Image I did created almost four years ago for the Raspberry Pi and showcased live on stage at DockerCon 2015 in San Francisco, see &lt;a href=&#34;https://blog.hypriot.com/post/dockercon2015/&#34;&gt;Hypriot-Demo and challenge at DockerCon 2015&lt;/a&gt;. As this is an 32bit ARM image, let&amp;rsquo;s see if it works out-of-the-box on this brandnew Jetson Nano board.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker pull hypriot/rpi-busybox-httpd
Using default tag: latest
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Already exists
6f1938f6d8ae: Already exists
e1347d4747a6: Already exists
a3ed95caeb02: Already exists
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Image is up to date for hypriot/rpi-busybox-httpd:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Docker Image is pulled directly from Docker Hub and we can have a closer look, it&amp;rsquo;s pretty small in size with 2.16MByte only and it is already 3 years old.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker images
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
hypriot/rpi-busybox-httpd   latest              fbd9685c5ffc        3 years ago         2.16MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s see how it runs on the Jetson Nano.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pirate@jetson-nano:~$ sudo docker run -d -p 8000:80 hypriot/rpi-busybox-httpd
ed6e7838c9af3f73e6f7129e7c38bf369bb9a33aa67a3b160b1f1c6c7251b2b2

pirate@jetson-nano:~$ sudo docker ps
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                  NAMES
ed6e7838c9af        hypriot/rpi-busybox-httpd   &amp;quot;/bin/busybox httpd â€¦&amp;quot;   8 seconds ago       Up 7 seconds        0.0.0.0:8000-&amp;gt;80/tcp   laughing_lalande
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Opening up a web browser with the URL &lt;code&gt;http://192.168.7.158:8000&lt;/code&gt; and we should see the web page served by our Docker container running on the NVIDIA Jetson Nano.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/docker-container-webpage.jpg&#34; alt=&#34;docker-container-webpage.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here is another screenshot directly from the Jetson Nano desktop and a Chromium browser window which is showing our webpage served from the Docker container.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/nvidia-jetson-nano-intro/jetson-desktop-container-webpage.jpg&#34; alt=&#34;jetson-desktop-container-webpage.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SUCCESS:&lt;/strong&gt; Docker Engine 18.06.1-CE is preinstalled on the brandnew NVIDIA Jetson Nano board and even old 32bit ARM Docker Images are running easily!&lt;/p&gt;

&lt;h3 id=&#34;recap&#34;&gt;Recap&lt;/h3&gt;

&lt;p&gt;As you can see, there is already a fully running version of the Docker Engine preinstalled on the official SD card image for the NVIDIA Jetson Nano board. The Linux kernel 4.9.x has all the basic features enabled to run containers locally.&lt;/p&gt;

&lt;p&gt;So, Docker just works out-of-the-box and you are able to use Docker Images right away. Even 32bit Docker images are able to run on this board because it&amp;rsquo;s based upon an ARM Cortex A57 CPU and this one is capable to run 64bit and 32bit ARM instructions.&lt;/p&gt;

&lt;p&gt;If you want to learn more general details about the NVIDIA Jetson Nano Developer Kit, please visit the JetsonHacks website at &lt;a href=&#34;https://www.jetsonhacks.com/2019/03/25/nvidia-jetson-nano-developer-kit/&#34;&gt;https://www.jetsonhacks.com/2019/03/25/nvidia-jetson-nano-developer-kit/&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Releasing HypriotOS 1.10.0: Docker 18.06.3 CE from Raspberry Pi Zero to 3 B&#43;</title>
      <link>https://blog.hypriot.com/post/releasing-HypriotOS-1-10/</link>
      <pubDate>Sun, 24 Feb 2019 16:01:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/releasing-HypriotOS-1-10/</guid>
      <description>&lt;p&gt;&lt;strong&gt;We&amp;rsquo;re proud to announce our 1.10.0 release of HypriotOS - the fastest way to get Docker up and running on any Raspberry Pi.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/release-1-10/hypriotos-1.10.0-docker-18.06.3.png&#34; alt=&#34;Raspberry Pi Zero with Docker 18.06.3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;features-of-hypriotos&#34;&gt;Features of HypriotOS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Latest Docker Engine 18.06.3-ce&lt;/strong&gt; &lt;/br&gt;
You can use the latest features of the freshly-baked Docker Engine 18.06.3-ce that is still warm. It includes the Swarm Mode, which allows high availability of services in a multi-node cluster within just a few simple commands.
This version contains a fix for the &lt;a href=&#34;https://blog.docker.com/2019/02/docker-security-update-cve-2018-5736-and-container-security-best-practices/&#34;&gt;CVE-2019-5736&lt;/a&gt; in runC.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Up to date with Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS with an up-to-date OS and Linux kernel which is in sync with the current Raspbian Lite running a Linux kernel 4.14.98.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Support for the complete Raspberry Pi family&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS on every model of the Raspberry Pi family - we&amp;rsquo;re supporting Pi 1, 2, 3, the 3 B+, Zero and even the Compute Module.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Easy flashing and configuration&lt;/strong&gt; &lt;/br&gt;
We improved our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;, which puts HypriotOS onto a SD card that is ready to boot from with a single command. With additional command line options you can customize HypriotOS during the flash operation to have the best out-of-the-box first-boot experience.
HypriotOS includes &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/&#34;&gt;cloud-init&lt;/a&gt;, which makes the first boot of your Raspberry Pi customizable and you even are able connecting it to your Wi-Fi network during boot.
After booting, you can find the Raspberry Pi at your network with a simple &lt;code&gt;ping black-pearl.local&lt;/code&gt; â€“ no more searching for IP addresses required thanks to the integrated Avahi service discovery.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enhanced security out of the box&lt;/strong&gt; &lt;/br&gt;
We think that security should be shipped out-of-the-box. We make HypriotOS more secure without you even noticing it. For instance, there is no built-in &amp;ldquo;root&amp;rdquo; user. Also, the default user &amp;ldquo;pirate&amp;rdquo; (password &amp;ldquo;hypriot&amp;rdquo;) is can be customized or removed before the first boot. Just look at the file &lt;code&gt;/boot/user-data&lt;/code&gt;. You can add your public SSH key, disable password logins and specify a different user account before you even boot your Raspberry Pi. WiFi can be customized and enabled to have Docker up and running through the air without attaching a keyboard and monitor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Smaller than Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
Even though HypriotOS 1.10.0 is fully packed with the complete and latest Docker tool set, it now comes at a size smaller than the tiniest version of Raspbian (&amp;ldquo;Raspbian Lite&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Please see all details in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases/tag/v1.10.0&#34;&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick start&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Download our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O https://raw.githubusercontent.com/hypriot/flash/2.2.0/flash
chmod +x flash
sudo mv flash /usr/local/bin/flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Now run this command to flash HypriotOS 1.10.0&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash https://github.com/hypriot/image-builder-rpi/releases/download/v1.10.0/hypriotos-rpi-v1.10.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Afterwards, put the SD card into the Raspberry Pi and power it. That&amp;rsquo;s all to get HypriotOS up and running!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;If you want to connect to the Raspberry Pi, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with password &amp;ldquo;hypriot&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;flash-with-wi-fi-settings-for-pi-zero&#34;&gt;Flash with Wi-Fi settings for Pi Zero&lt;/h3&gt;

&lt;p&gt;If you want the Raspberry Pi Zero (or Pi 3) to connect directly to your Wi-Fi after boot, change the hostname of the Raspberry Pi and more, edit &lt;code&gt;/boot/user-data&lt;/code&gt; of the SD card and have a look at &lt;a href=&#34;https://blog.hypriot.com/faq/#wifi&#34;&gt;our FAQ&lt;/a&gt;. Alternatively, checkout the parameters of the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt; that also allows you to define your own cloud-init user-data template file which will be copied onto the SD image for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n myHOSTNAME -u wifi.yml https://github.com/hypriot/image-builder-rpi/releases/download/v1.10.0/hypriotos-rpi-v1.10.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h2&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>We now accept donations. Buy us a beer!</title>
      <link>https://blog.hypriot.com/post/donation-liberapay-support-contribute/</link>
      <pubDate>Tue, 29 May 2018 16:30:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/donation-liberapay-support-contribute/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Many of our users have asked for it for quite a long time. Now, we finally took the time to setup a donation option.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since we started Hypriot in 2015, we received great attention from a growing community around Docker on ARMed devices. We received numerous &amp;ldquo;kudos&amp;rdquo; and nice words. Even though we greatly appreciate this until today, words do not enable us to pay our infrastructure bills. Now you have the option to support us materialistically.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/donations/liberapay-hypriot.png&#34; alt=&#34;Donations Screenshot Liberpay&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;what-we-do-with-your-donation&#34;&gt;What we do with your donation&lt;/h2&gt;

&lt;p&gt;Open source software might seem to be &amp;ldquo;free&amp;rdquo; (as in free beer) at first sight - that&amp;rsquo;s a fallacy. Its development, testing, and deployment require a huuuge amount of scarce time, ARMed hardware for testing, costs for service providers that help us throughout the software lifecycle, and costs for software licenses.&lt;/p&gt;

&lt;p&gt;Today, everything at Hypriot we do in our leisure time and pay for related bills with our private wallet. It would be great if we could at least cover our basic costs for infrastructure. Many parts of our infrastructure are free of charge for us because many service providers for e.g. build pipelines or Github support open source projects (our software is 100% open source). However, some providers do not offer free subscriptions for open source projects. We&amp;rsquo;ll use your donation to cover the bills from them.&lt;/p&gt;

&lt;p&gt;If the infrastructure costs are completely funded, we&amp;rsquo;ll use the surplus to enjoy a good beer during our hacking sessions :-)&lt;/p&gt;

&lt;h2 id=&#34;why-liberapay&#34;&gt;Why Liberapay?&lt;/h2&gt;

&lt;p&gt;Liberapay is a relatively new and trendy donation platform for free software projects. The unique thing about this platform: &lt;strong&gt;it pays its bills for development by receiving donations on its own platform&lt;/strong&gt;! As transaction fees for payments, this platform only invoices for the fees they are charged by their financial provider. In addition, Liberapay is fully open source and based within the European Union. Using software stemming from within the EU got more important with the advent of the new data protection regulation.&lt;/p&gt;

&lt;p&gt;Thus Liberapay offers several advantages over other popular platforms like Patreon (closed source, high transaction fees, not EU based).&lt;/p&gt;

&lt;h2 id=&#34;buy-us-at-least-a-little-beer&#34;&gt;Buy us at least a little beer!&lt;/h2&gt;

&lt;p&gt;If many of our community only provide little portions, the sum can be high. So please click on the following button, create an account and charge the account with some euros or dollars. Finally, specify a little amount you&amp;rsquo;d like to donate to us.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://liberapay.com/Hypriot/donate&#34;&gt;&lt;img alt=&#34;Donate using Liberapay&#34; src=&#34;https://liberapay.com/assets/widgets/donate.svg&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thank you very much in advance!&lt;/p&gt;

&lt;p&gt;@MathiasRenner at &lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;Twitter&lt;/a&gt; or &lt;a href=&#34;https://mastodon.social/@mathiasrenner&#34;&gt;Mastodon&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Releasing HypriotOS 1.8.0: Raspberry Pi 3 B&#43;, Stretch and more</title>
      <link>https://blog.hypriot.com/post/releasing-HypriotOS-1-8/</link>
      <pubDate>Tue, 27 Mar 2018 16:30:00 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/releasing-HypriotOS-1-8/</guid>
      <description>&lt;p&gt;&lt;strong&gt;We&amp;rsquo;re proud to announce our 1.8.0 release of HypriotOS - the fastest way to get Docker up and running on any Raspberry Pi including the new Pi 3 B+.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At this years Pi day the Raspberry Pi foundation &lt;a href=&#34;https://www.raspberrypi.org/blog/raspberry-pi-3-model-bplus-sale-now-35/&#34;&gt;has announced a new model&lt;/a&gt; - the Raspberry Pi 3 B+ with improved networking and a faster CPU. A good reason for us to update our HypriotOS to support this new device. And while we were at it we also updated the OS to Raspbian Stretch and Linux Kernel version 4.9.80 - and of course the latest Docker 18.03.0-ce release.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/release-1-8/pi3-b-plus.jpg&#34; alt=&#34;Raspberry Pi 3 B+&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;features-of-hypriotos&#34;&gt;Features of HypriotOS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Latest Docker Engine 18.03.0-ce with Swarm Mode&lt;/strong&gt; &lt;/br&gt;
You can use the latest features of the freshly-baked Engine Docker 18.03.0-ce that is still warm. It includes the Swarm Mode, which allows high availability of services in a multi-node cluster within just a few simple commands.
&lt;a href=&#34;https://blog.docker.com/2016/07/swarm-mode-on-a-raspberry-pi-cluster/&#34;&gt;See this short video how it works.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Up to date with Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS with an up-to-date OS and Linux kernel which is in sync with Raspbian Lite. We have updated to Raspbian Stretch and also prepared a new Docker optimized kernel 4.9.80.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Support for the complete Raspberry Pi family&lt;/strong&gt; &lt;/br&gt;
You can run HypriotOS on every model of the Raspberry Pi family - we&amp;rsquo;re supporting Pi 1, 2, 3, the 3 B+, Zero and even the Compute Module.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Easy flashing and configuration&lt;/strong&gt; &lt;/br&gt;
We improved our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;, which puts HypriotOS onto a SD card that is ready to boot from with a single command. With additional command line options you can customize HypriotOS during the flash operation to have the best out-of-the-box first-boot experience.
HypriotOS includes &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/&#34;&gt;cloud-init&lt;/a&gt;, which makes the first boot of your Raspberry Pi customizable and you even are able connecting it to your Wi-Fi network during boot.
After booting, you can find the Raspberry Pi at your network with a simple &lt;code&gt;ping black-pearl.local&lt;/code&gt; â€“ no more searching for IP addresses required thanks to the integrated Avahi service discovery.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enhanced security out of the box&lt;/strong&gt; &lt;/br&gt;
We think that security should be shipped out-of-the-box. We make HypriotOS more secure without you even noticing it. For instance, there is no built-in &amp;ldquo;root&amp;rdquo; user. Also, the default user &amp;ldquo;pirate&amp;rdquo; (password &amp;ldquo;hypriot&amp;rdquo;) is can be customized or removed before the first boot. Just look at the file &lt;code&gt;/boot/user-data&lt;/code&gt;. You can add your public SSH key, disable password logins and specify a different user account before you even boot your Raspberry Pi. WiFi can be customized and enabled to have Docker up and running through the air without attaching a keyboard and monitor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Smaller than Raspbian Lite&lt;/strong&gt; &lt;/br&gt;
Even though HypriotOS 1.8.0 is fully packed with the complete and latest Docker tool set, it now comes at a size smaller than the tiniest version of Raspbian (&amp;ldquo;Raspbian Lite&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Please see all details in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases/tag/v1.8.0&#34;&gt;release notes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick start&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Download our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O https://raw.githubusercontent.com/hypriot/flash/2.0.0/flash
chmod +x flash
sudo mv flash /usr/local/bin/flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Now run this command to flash HypriotOS 1.8.0&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash https://github.com/hypriot/image-builder-rpi/releases/download/v1.8.0/hypriotos-rpi-v1.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Afterwards, put the SD card into the Raspberry Pi and power it. That&amp;rsquo;s all to get HypriotOS up and running!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-steps&#34;&gt;Next steps&lt;/h3&gt;

&lt;p&gt;If you want to connect to the Raspberry Pi, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@black-pearl.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with password &amp;ldquo;hypriot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you want the Raspberry Pi to connect directly to your Wi-Fi after boot, change the hostname of the Raspberry Pi and more, edit &lt;code&gt;/boot/user-data&lt;/code&gt; of the SD card and have a look at &lt;a href=&#34;https://blog.hypriot.com/faq/#wifi&#34;&gt;our FAQ&lt;/a&gt;. Alternatively, checkout the parameters of the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;Hypriot flash tool&lt;/a&gt; that also allows you to define your own cloud-init user-data template file which will be copied onto the SD image for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -n myHOSTNAME -u wifi.yml https://github.com/hypriot/image-builder-rpi/releases/download/v1.8.0/hypriotos-rpi-v1.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will improve the flash tool to bring back support of the &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options so you can add WiFi support without creating your own user-data template file.&lt;/p&gt;

&lt;h2 id=&#34;hands-free-projects&#34;&gt;Hands-free projects&lt;/h2&gt;

&lt;p&gt;We have put together a small sample YAML that shows what you can do with HypriotOS, cloud-init and Docker. You can prepare a wireless Raspberry Pi with an SD card image that creates a Docker Swarm and starts a service to drive some LED&amp;rsquo;s automatically. You don&amp;rsquo;t have to login to this device. It will also start the service again after a power outage.&lt;/p&gt;

&lt;p&gt;The sample &lt;a href=&#34;https://github.com/hypriot/flash/blob/master/sample/rainbow.yml&#34;&gt;rainbow.yml&lt;/a&gt; shows how to setup a user with SSH public key authentication, activate WiFi and run a rainbow service.
You only have to customize the YAML file at&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;line 16: insert your SSH public key for authentication&lt;/li&gt;
&lt;li&gt;line 32 and 33: insert your WiFi settings&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then flash an SD image with this command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash -u rainbow.yml https://github.com/hypriot/image-builder-rpi/releases/download/v1.8.0/hypriotos-rpi-v1.8.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And after booting a Raspberry Pi Zero or Pi 3/Pi 3 B+ you will see some blinking LED&amp;rsquo;s once everything has been set up after the first boot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/release-1-8/rainbow.jpg&#34; alt=&#34;Raspberry Pi 3 B+ with rainbow service&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h2&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Bootstrapping a Cloud with Cloud-Init and HypriotOS</title>
      <link>https://blog.hypriot.com/post/cloud-init-cloud-on-hypriot-x64/</link>
      <pubDate>Sun, 29 Oct 2017 00:14:00 -0700</pubDate>
      
      <guid>https://blog.hypriot.com/post/cloud-init-cloud-on-hypriot-x64/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Things may come to those who wait, but only the things left by those who hustle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Over the last year, a lot has happened in the Raspberry Pi and Docker communities, there are Docker Captains helping lead the charge, one of those, &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;Dieter Reuter&lt;/a&gt; really has been pushing the cause for ARM64 support with both Raspberry Pi 3 and LinuxKit. He isn&amp;rsquo;t a single man army, the rest of the &lt;a href=&#34;http://blog.hypriot.com/crew/&#34;&gt;Docker Pirates&lt;/a&gt; over at &lt;a href=&#34;http://blog.hypriot.com/&#34;&gt;Hypriot&lt;/a&gt; have been doing some awesome things as well!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/cloud-init/brown-airplanes.jpg&#34; alt=&#34;airplanes&#34; /&gt;
&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/horiavarlan/5019447085/in/photolist-8DxYK8-6RFbEf-6RFfrw-6RLCGd-6RAH6n-6RF9gf-6RATnx-6RGCKM-6RB7L2-6REXqA-6T4VEQ-6RBeKg-brFbp6-6RAZU8-6RGwNk-6RAiLD-6RBgp6-6RLAvm-6RBbwM-6RAE5e-6RLJVj-6RLFdN-6RBsmr-6RFxxw-6RLJrY-6RFvGJ-6RFtZS-6REvrf-6RENUY-6RFwCC-6RGBEn-6RGz9n-6RFpb3-6RFzo1-if9tn-9NF66y-84UZy9-6RFew9-6RFq2m-6RLHWJ-6T4Wd9-9NChKc-6RAZ5V-9NCiK8-6T5Lbf-6RAUfp-6RBhb6-9NF3UW-9NF979-9NFaFW&#34;&gt;Horia Varlan&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Building on the backs of these outstanding community members, I was finally able to spin up a Raspberry Pi, exactly like I do in the &amp;ldquo;real world&amp;rdquo;, just turn it on, let it self-configure, then software just runs.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A lot of this is really about having &lt;a href=&#34;http://cloudinit.readthedocs.io/en/latest/index.html&#34;&gt;cloud-init &lt;/a&gt; available in the HypriotOS 64bit images thanks to another Pirate &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;Stefan Scherer&lt;/a&gt;. In the &amp;ldquo;cloud world&amp;rdquo;, you spin up instances, give it some user-data, then when it boots, the machines self-configures based on the instance meta-data and the user-data provided.&lt;/p&gt;

&lt;h2 id=&#34;before&#34;&gt;Before&lt;/h2&gt;

&lt;p&gt;Before we talk about the &amp;ldquo;new&amp;rdquo; pirate way, let&amp;rsquo;t talk about the &amp;ldquo;old&amp;rdquo; non-pirate way.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Download Raspbian Lite (the easiest for nubbies like me)&lt;/li&gt;
&lt;li&gt;Flash said image to an SD Card&lt;/li&gt;
&lt;li&gt;Optionally re-mount SD Card and monkey some stuff around&lt;/li&gt;
&lt;li&gt;Put the card in your RPi&lt;/li&gt;
&lt;li&gt;Power up the RPi&lt;/li&gt;
&lt;li&gt;If you don&amp;rsquo;t have avahi/bonjour, go find the IP in your router&lt;/li&gt;
&lt;li&gt;SSH into the server&lt;/li&gt;
&lt;li&gt;Update Packages&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;raspi-config&lt;/code&gt; and modify some junk&lt;/li&gt;
&lt;li&gt;Reboot&lt;/li&gt;
&lt;li&gt;Install Docker&lt;/li&gt;
&lt;li&gt;Initialize Docker Swarm&lt;/li&gt;
&lt;li&gt;Configure &lt;a href=&#34;http://portainer.io&#34;&gt;Portainer&lt;/a&gt; service (if not, are you broken?)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;try&amp;rdquo; and find some images you can run on arm&lt;/li&gt;
&lt;li&gt;Cheer at your glory based nginx hello world page!&lt;/li&gt;
&lt;li&gt;Figure out how to use automation tools like Ansible to make your life easier when you need a cluster&lt;/li&gt;
&lt;li&gt;Bang head on desk learning so much&amp;hellip;&lt;/li&gt;
&lt;li&gt;Do victory dances when you created a bunch of automation around setting up servers&lt;/li&gt;
&lt;li&gt;Go find out what the community is doing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is at that point, when the community really is an awesome place. Given the latest &lt;a href=&#34;https://github.com/DieterReuter/image-builder-rpi64/releases/tag/v20171013-172949&#34;&gt;HypriotOS-rpi64&lt;/a&gt;, the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash&lt;/a&gt; utility (also from Hypriot), Docker images now being multi-architecture supported through the &lt;a href=&#34;https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md&#34;&gt;manifest v2 API&lt;/a&gt; and Docker pushing to get all the &lt;a href=&#34;https://github.com/docker-library/official-images#architectures-other-than-amd64&#34;&gt;supported images covering a lot of architectures&lt;/a&gt;, life begins to get much &lt;strong&gt;much&lt;/strong&gt; easier.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: Before we continue, we need to talk about ARM 64 naming issues.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/ARM_architecture#64.2F32-bit_architecture&#34;&gt;ARM is complicated&lt;/a&gt; when it comes to the latest version of the architecture (v8). A lot of the distros still haven&amp;rsquo;t settled on what to call it, and you will find a lot of differences: &lt;code&gt;AArch64&lt;/code&gt; and &lt;code&gt;ARM64v8&lt;/code&gt; being the two most popular. When in doubt, do what &lt;a href=&#34;https://github.com/docker-library/official-images#architectures-other-than-amd64&#34;&gt;Docker does&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;after&#34;&gt;After&lt;/h2&gt;

&lt;p&gt;Now that we got that out of the way, let&amp;rsquo;s get into some code. Given the list of &lt;code&gt;arm64v8&lt;/code&gt; images in the &lt;a href=&#34;https://hub.docker.com/u/arm64v8/&#34;&gt;Docker registry&lt;/a&gt; I wanted to find something that would be interesting. Luckily, I was able to find &lt;a href=&#34;https://nextcloud.com/&#34;&gt;NextCloud&lt;/a&gt;. I have no idea if this software is worth keeping around, but it was something I could play with, try to break, reboot to see if it lives, and have something to play with when I succeed!&lt;/p&gt;

&lt;h3 id=&#34;user-data&#34;&gt;User Data&lt;/h3&gt;

&lt;p&gt;The first thing we need to do, is create our &lt;code&gt;user-data&lt;/code&gt; file. This will be placed inside of our SD card when we flash it and instruct &lt;code&gt;cloud-init&lt;/code&gt; what to do when the system boots for the first time.&lt;/p&gt;

&lt;p&gt;It should be noted, that at this time, the cloud-init version available for Debian distribution is &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/&#34;&gt;0.7.9&lt;/a&gt;, not the 17.1 you would have thought (as latest). Currently only Ubuntu is the only distribution I know of that is using 17.1.&lt;/p&gt;

&lt;p&gt;The next important fact to know is that the Data Source we are utilizing is the &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/topics/datasources/nocloud.html&#34;&gt;NoCloud&lt;/a&gt; data source. This basically means (in the 0.7.9 and below version) that the &lt;code&gt;user-data&lt;/code&gt; and &lt;code&gt;meta-data&lt;/code&gt; are on the local file system, not pulled from a remote resource or other means.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;user-data&lt;/code&gt; file is simply a YAML file, you can get a lot more complicated, but for the sake of simplicity, let&amp;rsquo;s just call it a YAML file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;user-data&lt;/code&gt; for this project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#cloud-config
# vim: syntax=yaml
#

hostname: nextcloud-pi64
manage_etc_hosts: true

resize_rootfs: true
growpart:
    mode: auto
    devices: [&amp;quot;/&amp;quot;]
    ignore_growroot_disabled: false

users:
  - name: pirate
    gecos: &amp;quot;Hypriot Pirate&amp;quot;
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    groups: users,docker,video
    plain_text_passwd: hypriot
    lock_passwd: false
    ssh_pwauth: true
    chpasswd: { expire: false }

package_update: true
package_upgrade: true
package_reboot_if_required: true
packages:
  - ntp

locale: &amp;quot;en_US.UTF-8&amp;quot;
timezone: &amp;quot;America/Los_Angeles&amp;quot;

write_files:
    - path: &amp;quot;/etc/docker/daemon.json&amp;quot;
      owner: &amp;quot;root:root&amp;quot;
      content: |
        {
          &amp;quot;labels&amp;quot;: [ &amp;quot;os=linux&amp;quot;, &amp;quot;arch=arm64&amp;quot; ],
          &amp;quot;experimental&amp;quot;: true
        }

runcmd:
  - [ systemctl, restart, avahi-daemon ]
  - [ systemctl, restart, docker ]
  - [docker, swarm, init ]
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;portainer&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;9000:9000&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=portainer_data,dst=/data&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock&amp;quot;,
      &amp;quot;portainer/portainer&amp;quot;, &amp;quot;-H&amp;quot;, &amp;quot;unix:///var/run/docker.sock&amp;quot;, &amp;quot;--no-auth&amp;quot;
    ]
  - [mkdir, &amp;quot;-p&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]
  - [setfacl, &amp;quot;-m&amp;quot;, &amp;quot;u:www-data:rwx&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;nextcloud&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;80:80&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=nextcloud,dst=/var/www/html&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/cloud/data,dst=/var/www/html/data&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;SQLITE_DATABASE=nextcloud&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_USER=pirate&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_PASSWORD=hypriot&amp;quot;,
      &amp;quot;nextcloud:latest&amp;quot;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is extremely important that before you flash this to a disk and attempt to boot, that you run this file through a YAML linter. There are some good ones &lt;a href=&#34;http://www.yamllint.com/&#34;&gt;available online&lt;/a&gt;, but you should never use an online linter if your &lt;code&gt;user-data&lt;/code&gt; contains real passwords or SSH keys, you can&amp;rsquo;t trust if they store the YAML or not on the server side.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s break this down into somewhat readable chunks&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;configure-host-name&#34;&gt;Configure Host Name&lt;/h4&gt;

&lt;p&gt;This will simply configure your hostname of the machine as well as make sure that &lt;code&gt;/etc/hosts&lt;/code&gt; is appropriately updated. You can specify an &lt;code&gt;fqdn&lt;/code&gt; here, as you will see below. However, the hostname in this file isn&amp;rsquo;t super important, as we will use the &lt;code&gt;--hostname&lt;/code&gt; option with the flash utility later to change this when we write the image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;hostname: nextcloud-pi64
manage_etc_hosts: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;resize-file-system&#34;&gt;Resize File System&lt;/h4&gt;

&lt;p&gt;This is something that had plagued RPi users for years, finally at some point the foundation images included this on first boot, but the wonderful thing about &lt;code&gt;cloud-init&lt;/code&gt; is it already had this built in. You &amp;ldquo;really&amp;rdquo; don&amp;rsquo;t need these settings in the file, I put these here to show that this is just built in functionality for &lt;code&gt;cloud-init&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;resize_rootfs: true
growpart:
    mode: auto
    devices: [&amp;quot;/&amp;quot;]
    ignore_growroot_disabled: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;create-users&#34;&gt;Create Users&lt;/h4&gt;

&lt;p&gt;Creating users is pretty simple, plop in an array element, give it some information, and your off to the races. The below is actually what is in the default &lt;code&gt;cloud-init&lt;/code&gt; for the HypriotOS image if you don&amp;rsquo;t overwrite it.  You can actually do a lot more with this, including adding SSH keys. Check out the &lt;a href=&#34;http://cloudinit.readthedocs.io/en/0.7.9/topics/modules.html#users-and-groups&#34;&gt;users documentation&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;users:
  - name: pirate
    gecos: &amp;quot;Hypriot Pirate&amp;quot;
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    groups: users,docker,video
    plain_text_passwd: hypriot
    lock_passwd: false
    ssh_pwauth: true
    chpasswd: { expire: false }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;update-and-add-packages&#34;&gt;Update and Add Packages&lt;/h4&gt;

&lt;p&gt;Because we live in a world of ever updating software, you really don&amp;rsquo;t know what is out of date in your image. This ensures that on first boot, all packages are updated. Additionally, you can install additional packages you might need. In this case I am installing NTP (there is a better way to do this, but there is an outstanding issue with it atm). Additionally, we instruct &lt;code&gt;cloud-init&lt;/code&gt; to reboot the server if the updates require one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;package_update: true
package_upgrade: true
package_reboot_if_required: true
packages:
  - ntp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NTP missing from the HypriotOS image is something I will be bringing up with the team to get fixed in the future!&lt;/p&gt;

&lt;h4 id=&#34;set-localized-settings&#34;&gt;Set Localized Settings&lt;/h4&gt;

&lt;p&gt;These will setup your server in your correct part of the world. The Raspbian comes with UK as default, at least HypriotOS came with a sane UTC default, but sometimes you just want your local time. This is definitely one of those time savers where most people used &lt;code&gt;raspi-config&lt;/code&gt; to set these (horrible horrible menus).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;locale: &amp;quot;en_US.UTF-8&amp;quot;
timezone: &amp;quot;America/Los_Angeles&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is something I feel like you should also be able to configure in the flash utility, and will be bringing it up as well with the Pirates.&lt;/p&gt;

&lt;h4 id=&#34;write-some-arbitrary-files&#34;&gt;Write some arbitrary files&lt;/h4&gt;

&lt;p&gt;The power to create files on boot&amp;hellip; This simple file output below is configuring docker labels as well as doing the (currently required) experimental features flag. This will require a Docker daemon restart, but we will cover that soon enough!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;write_files:
    - path: &amp;quot;/etc/docker/daemon.json&amp;quot;
      owner: &amp;quot;root:root&amp;quot;
      content: |
        {
          &amp;quot;labels&amp;quot;: [ &amp;quot;os=linux&amp;quot;, &amp;quot;arch=arm64&amp;quot; ],
          &amp;quot;experimental&amp;quot;: true
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;run-a-bunch-of-commands&#34;&gt;Run a bunch of commands&lt;/h4&gt;

&lt;p&gt;There are actually a few ways to run commands in &lt;code&gt;cloud-init&lt;/code&gt;, this is the most used, because it is the last thing that is done during initialization.&lt;/p&gt;

&lt;p&gt;In this, we are essentially restarting Docker and avahi to pickup our configuration changes, initializing Docker Swarm, running good ol Portainer (so we can see what is going on without SSH).&lt;/p&gt;

&lt;p&gt;The last steps are all specific to NextCloud. I create a new directory to store the files and SQL Lite database, set permissions for the &lt;code&gt;www-data&lt;/code&gt; user since NextCloud is using Apache, and running as a known user, we need to give that specific user permissions, and finally bootstrap NextCloud to self-configure and initialize.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;runcmd:
  # Pickup the hostname changes
  - [ systemctl, restart, avahi-daemon ]

  # Pickup the daemon.json changes
  - [ systemctl, restart, docker ]

  # Init a swarm, because why not
  - [docker, swarm, init ]

  # Run portainer, so we can see our logs and control stuff from a UI
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;portainer&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;9000:9000&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=portainer_data,dst=/data&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock&amp;quot;,
      &amp;quot;portainer/portainer&amp;quot;, &amp;quot;-H&amp;quot;, &amp;quot;unix:///var/run/docker.sock&amp;quot;, &amp;quot;--no-auth&amp;quot;
    ]

  # Create a specific directory to store all the data,
  # this way you could mount an external drive later (coming soon!)
  - [mkdir, &amp;quot;-p&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]

  # This gives the nextcloud permissions to write to this directory
  # since it runs as www-data
  - [setfacl, &amp;quot;-m&amp;quot;, &amp;quot;u:www-data:rwx&amp;quot;, &amp;quot;/var/cloud/data&amp;quot; ]

  # Create the nextcloud instance configuring it on startup
  # - you should change the user/password below to something less obvious
  # or use the config UI
  - [
      docker, service, create,
      &amp;quot;--detach=false&amp;quot;,
      &amp;quot;--name&amp;quot;, &amp;quot;nextcloud&amp;quot;,
      &amp;quot;--publish&amp;quot;, &amp;quot;80:80&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=volume,src=nextcloud,dst=/var/www/html&amp;quot;,
      &amp;quot;--mount&amp;quot;, &amp;quot;type=bind,src=//var/cloud/data,dst=/var/www/html/data&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;SQLITE_DATABASE=nextcloud&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_USER=pirate&amp;quot;,
      &amp;quot;--env&amp;quot;, &amp;quot;NEXTCLOUD_ADMIN_PASSWORD=hypriot&amp;quot;,
      &amp;quot;nextcloud:latest&amp;quot;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are some important bits here, the &lt;code&gt;SQLITE_DATABASE=&amp;lt;name&amp;gt;&lt;/code&gt; is actually what triggers the &amp;ldquo;auto-configure&amp;rdquo; option, without that, the &lt;code&gt;NEXTCLOUD_*&lt;/code&gt; variables are ignored, despite what the documentation says.&lt;/p&gt;

&lt;h3 id=&#34;flash&#34;&gt;FLASH&lt;/h3&gt;

&lt;p&gt;If you don&amp;rsquo;t know about this utility yet, please head over to the &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;github repo&lt;/a&gt; and check it out.&lt;/p&gt;

&lt;p&gt;Good, your back, now lets see my command line I use to run this on my Ubuntu 16.x Server.&lt;/p&gt;

&lt;p&gt;The following statements will install the prerequisites for flash, download the script, download this blog posts &lt;code&gt;user-data.yml&lt;/code&gt; file, then attempt to flash the image to an SD card.&lt;/p&gt;

&lt;p&gt;I highly recommend using a 32 or 64 GB flash card for this project, because if you decide to keep this cloud around, you might want to store one or two things in it.&lt;/p&gt;

&lt;p&gt;When prompted, insert your SD flash card into an available USB slot, then choose the right one, and verify the right one. You really don&amp;rsquo;t want DD to mount/flash/unmount your main drive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install pv unzip hdparm
curl -O https://raw.githubusercontent.com/hypriot/flash/master/$(uname -s)/flash
chmod +x flash
sudo mv flash /usr/local/bin/flash

# Just make sure the existing is gone
rm ./user-data.yml

# Download this yaml from this repo
curl -O https://gist.githubusercontent.com/RenEvo/6a9e244b670df334c42578b8fe95400b/raw/user-data.yml

// flash it
flash \
  --hostname mycloud.home.renevo.com \
  --userdata ./user-data.yml \
  https://github.com/DieterReuter/image-builder-rpi64/releases/download/v20171013-172949/hypriotos-rpi64-v20171013-172949.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When finished, pull out that sweet SD card, and let&amp;rsquo;s get ready to plug in.&lt;/p&gt;

&lt;h3 id=&#34;boot-and-forget&#34;&gt;Boot and Forget&lt;/h3&gt;

&lt;p&gt;For this, I simply put the SD card into a random RPi3 I had laying around, plugged in a network cable to my switch and the RPi, and then applied power to it.&lt;/p&gt;

&lt;p&gt;This is really where the waiting game begins, the RPi is going to boot up, self-name, self-update, possible reboot, pull down some Docker images, bootstrap a Docker Swarm, run Portainer, then finally&amp;hellip; start a personal cloud.&lt;/p&gt;

&lt;p&gt;At the time of writing this, you are still going to have to go fish out your IP from DNS unless you are on Mac or Linux with avahi, at that case, you can just navigate to &lt;code&gt;http://&amp;lt;hostname&amp;gt;.local&lt;/code&gt; or &lt;code&gt;http://&amp;lt;hostname&amp;gt;&lt;/code&gt; if you used an fqdn like I did. There are actually ways to get the RPi to phone home when it is finished bootstrapping, but I am going to save that for another post!&lt;/p&gt;

&lt;p&gt;So, after you get some coffee, you can try navigating to your RPi on port 9000 with your browser, that should get you into the Portainer instance without any type of authentication (don&amp;rsquo;t do this in a real environment please, go read the docs on securing it).&lt;/p&gt;

&lt;p&gt;After you go get a snack and take a short walk, you can try navigating to your RPi on port 80 with your browser, once you get prompted, login with user: &lt;code&gt;pirate&lt;/code&gt; and password: &lt;code&gt;hypriot&lt;/code&gt; to get access to your cloud. Click close on the annoying modal about downloading sync programs, and there you have it&amp;hellip; Your own personal cloud, bootstrapped from a simple YAML file, without you ever having to SSH into your PI.&lt;/p&gt;

&lt;p&gt;Here is the fun part, you can reflash that anytime you want to recreate the exact same baseline SD card image.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;This was a lot of fun for me, and without having to actually figure out some nitty gritty details, not over documenting things, and getting prepared to write this post, it realistically took me about 10 minutes to go from downloading the OS image to running NextCloud on my RPi. And that is all due to the hard work of the community, and especially the Docker Pirates at Hypriot, and to them, I thank you.&lt;/p&gt;

&lt;p&gt;I plan to continue playing with this, potentially updating the server to use an external USB drive for data and auto-mounting it on boot, possible setup a GlusterFS and run them in a small 2 or 3 node cluster, and call it my PiCloud.&lt;/p&gt;

&lt;p&gt;Who knows, it&amp;rsquo;s all about having fun and experimenting right?&lt;/p&gt;

&lt;p&gt;All the samples can be &lt;a href=&#34;https://gist.github.com/RenEvo/6a9e244b670df334c42578b8fe95400b&#34;&gt;found on on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;about-me&#34;&gt;About Me&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Who is this guy, and why is he posting on this blog?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My name is &lt;a href=&#34;https://twitter.com/TribalTom&#34;&gt;Tom Anderson&lt;/a&gt;, I am a Senior II Cloud Software Engineer by day at a killer gaming company, and by night I am a father, musician, tinkerer, and still&amp;hellip; a hobbiest programmer of all the things. Dieter Reuter was nice enough to ask me to guest post this topic, and I just felt it had to be done! The Pirates have given so much to the community, I felt I needed to give a little something back.&lt;/p&gt;

&lt;p&gt;Additionally, I build and talk about some things I think are cool on my own blog &lt;a href=&#34;http://tomanderson.me&#34;&gt;tomanderson.me&lt;/a&gt;, feel free to stop by and say hi!&lt;/p&gt;

&lt;p&gt;Finally, because legaleeze and stuff&amp;hellip; All opinions here are my own, and do not reflect the opinions of Blizzard Entertainment.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DockerCon 2017 Demo: Monitoring Docker Swarm with LED&#39;s</title>
      <link>https://blog.hypriot.com/post/dockerconaustin2017/</link>
      <pubDate>Thu, 20 Apr 2017 14:30:34 -0600</pubDate>
      
      <guid>https://blog.hypriot.com/post/dockerconaustin2017/</guid>
      <description>&lt;p&gt;At DockerCon 2017 in Austin I gave a presentation of a Raspberry Pi cluster mixed with some UP boards. The audience really liked the visual effects of the Docker Swarm scaling a service up and down. So I show you some background details what you need to run that demo on your Raspberry Pi cluster as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/stage2.jpg&#34; alt=&#34;PiCloud at DockerCon Austin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;All the effort played off to build that cluster, to find out how to drive LED&amp;rsquo;s in swarm mode, to put it into my bag and go through customs on my flight from Germany to Austin, Texas. It really was fun to show this the audience and everybody liked it.&lt;/p&gt;

&lt;p&gt;To enable you to replay the demo with some Pimoroni Blinkt! LED&amp;rsquo;s and Raspberry Pi - regardless if you only have Pi Zeros I want to show you the Docker images I used and the commands to show the scaling demo.&lt;/p&gt;

&lt;p&gt;The Docker image &lt;a href=&#34;https://hub.docker.com/r/stefanscherer/monitor/&#34;&gt;stefanscherer/monitor&lt;/a&gt; is available on the Docker Hub. It is a multi-architecture image that can be used on Linux with Intel or ARM CPU&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;So just create a Docker swarm with the usual commands &lt;code&gt;docker swarm init&lt;/code&gt; and then join some other workers with the swarm token shown in your terminal.&lt;/p&gt;

&lt;h2 id=&#34;start-the-led-monitor&#34;&gt;Start the LED monitor&lt;/h2&gt;

&lt;p&gt;First we have to start the LED monitor as a service so that it is running on each node of the Docker swarm. The option &lt;code&gt;--mode global&lt;/code&gt; will do this and start one instance on each node. We have to bind mount both the Docker socket and a part of the file system into the container so it can access the &lt;code&gt;/sys/class/fs&lt;/code&gt; file system.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service create --name monitor --mode global \
  --restart-condition any --mount type=bind,src=/sys,dst=/sys \
  --mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
  stefanscherer/monitor:1.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are all set to play with scaling an example service.&lt;/p&gt;

&lt;h2 id=&#34;scale-up&#34;&gt;Scale up&lt;/h2&gt;

&lt;p&gt;There is another multi-arch image that I used for the scaling demo. It is the &amp;ldquo;whoami&amp;rdquo; web service that responds the container&amp;rsquo;s hostname.&lt;/p&gt;

&lt;p&gt;First we create the service with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service create --name whoami stefanscherer/whoami:1.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As said this works with any Raspberry Pi or the UP board that has an Intel Atom CPU.
After the image has been downloaded the LED monitor should show one yellow LED lighting up.&lt;/p&gt;

&lt;p&gt;Now scale the service a little more eg. to the number of nodes you have to have one LED lighting up per node.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then scale it up a little more&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/scale-up.gif&#34; alt=&#34;Scale up&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And then light up all the LED&amp;rsquo;s by scaling up to the number of LED&amp;rsquo;s you have.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=32
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rolling-update&#34;&gt;Rolling update&lt;/h2&gt;

&lt;p&gt;Another thing that can be visualized is a rolling update. The LED monitor shows each container with a yellow color for version 1.1.0 of the service and blue for version 1.2.0.&lt;/p&gt;

&lt;p&gt;So start the rolling update by specifing &lt;code&gt;--update-parallelism&lt;/code&gt; with the number of containers that should be replaced in one step. So Docker Swarm kills that number of containers and starts the new version of it before stopping the next bulk of containers. Use the &lt;code&gt;--image&lt;/code&gt; option to specifiy the new version that should be used by the whoami service.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service update --update-parallelism 5 \
  --image stefanscherer/whoami:1.2.0 whoami
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now watch what happens. Each destroyed container lights up red and then dims. After a while Docker swarm manager starts the new version and so new LED&amp;rsquo;s with blue light up. After a while all LED&amp;rsquo;s have changed from yellow (version 1.1.0) to blue (version 1.2.0). And while this rolling update is going on you still can use this &amp;ldquo;whoami&amp;rdquo; service by curl&amp;rsquo;ing it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/rolling-update.gif&#34; alt=&#34;Rolling update&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;scale-down-to-one&#34;&gt;Scale down to one&lt;/h2&gt;

&lt;p&gt;Another nice effect is to scale down the service back to one as all LED&amp;rsquo;s will flash up in red and only one LED remains blue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker service scale whoami=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockercon2017/scale-down-to-one.gif&#34; alt=&#34;Scale down to one&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hope I did make you curious to try it out on your own cluster. Happy hacking and have fun! If you want to improve the visual effects have a look at the Node.js sources in the &lt;a href=&#34;https://github.com/StefanScherer/swarm-monitor&#34;&gt;GitHub repo&lt;/a&gt;. Rewrite it in Golang or anything else and suprise me with other nice visual effects.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building a 64bit Docker OS for the Raspberry Pi 3</title>
      <link>https://blog.hypriot.com/post/building-a-64bit-docker-os-for-rpi3/</link>
      <pubDate>Thu, 02 Mar 2017 11:28:42 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/building-a-64bit-docker-os-for-rpi3/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m happy to announce the start of a &amp;ldquo;short&amp;rdquo; workshop were I&amp;rsquo;m going through all the steps to build a complete 64bit operating system for the Raspberry Pi 3. This 64bit HypriotOS is mainly focused on running Docker containers easily on this popular DIY and IoT device.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/e/e6/Raspberry-Pi-3-Flat-Top.jpg&#34; alt=&#34;Raspi3-Image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll see that I&amp;rsquo;m using Docker heavily for each and every build step, because it really helps us a lot to run a local build with &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;Docker-for-Mac&lt;/a&gt; or later on the cloud build servers at &lt;a href=&#34;https://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/building-a-64bit-docker-os-for-rpi3/bee42-workshop.jpg&#34; alt=&#34;bee42-workshop.jpg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This workshop is sponsored by &lt;a href=&#34;http://bee42.com&#34;&gt;bee42 solutions&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bee42solutions&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @bee42solutions&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background-and-contents&#34;&gt;Background and Contents&lt;/h3&gt;

&lt;p&gt;As you may already know, a complete Linux operating system consists of several important building blocks and I&amp;rsquo;d like to show you how to build all of these step by step.&lt;/p&gt;

&lt;p&gt;For this purpose I&amp;rsquo;m not going to reinvent the wheel and so I&amp;rsquo;ll reuse all of the existing parts which are already published by the Raspberry Pi Organisation, by the Debian Linux project and will add some more glue code.&lt;/p&gt;

&lt;p&gt;At the end you should have learned how to build all the necessary parts and how to automatically create a finished SD card image which could be flashed on an empty SD card. Then boot your Raspberry Pi 3 with and in less than a minute you have a fully running Docker Engine on a Debian-based 64bit Linux OS.&lt;/p&gt;

&lt;p&gt;Here is a short overview of the contents of the workshop:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 1: Bootloader&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 2: Kernel&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 3: Root filesystem&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Part 4: SD Card Image&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, that&amp;rsquo;s enough for explaining the background of this workshop. For more informations please follow along the details I&amp;rsquo;ll publish on the coming tweets at Twitter and in the GitHub repos until all the parts of this workshop are finished and available as OpenSource.&lt;/p&gt;

&lt;p&gt;Please be aware that this OS is in a development phase and far from being perfect. So you are encouraged to help me with reporting issues and filing pull-requests to add features and fix bugs.&lt;/p&gt;

&lt;h3 id=&#34;further-links&#34;&gt;Further Links&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to publish all the details and steps to build the new operating system in a public GitHub repo. All other details and necessary GitHub repos will be linked here in this section as a future reference.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Workshop Repo&lt;/strong&gt; &lt;a href=&#34;https://github.com/dieterreuter/workshop-raspberrypi-64bit-os&#34;&gt;https://github.com/dieterreuter/workshop-raspberrypi-64bit-os&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So please stay tuned, this link list will be extended over the next few days.&lt;/p&gt;

&lt;h3 id=&#34;acknowledgments&#34;&gt;Acknowledgments&lt;/h3&gt;

&lt;p&gt;Please follow along the detailed tweets about this workshop via&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; &lt;a href=&#34;https://twitter.com/Quintus23M&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @Quintus23M&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt; &lt;a href=&#34;https://twitter.com/HypriotTweets&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @HypriotTweets&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/bee42solutions&#34;&gt;@bee42solutions&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bee42solutions&#34; class=&#34;twitter-follow-button&#34; data-show-count=&#34;false&#34;&gt;Follow @bee42solutions&lt;/a&gt;&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Special thanks goes to &lt;a href=&#34;http://bee42.com&#34;&gt;bee42 solutions&lt;/a&gt; for giving me the time to work on this awesome topic to build a complete Docker-enabled 64bit OS for the Raspberry Pi 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/building-a-64bit-docker-os-for-rpi3/bee42-logo.jpg&#34; alt=&#34;bee42-logo.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Let&#39;s build the smallest possible Docker image</title>
      <link>https://blog.hypriot.com/post/build-smallest-possible-docker-image/</link>
      <pubDate>Wed, 22 Feb 2017 09:18:35 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/build-smallest-possible-docker-image/</guid>
      <description>&lt;p&gt;Imagine what happens if we&amp;rsquo;re starting to use Docker containers on IoT devices. On small and slow devices with limited system resources and connected via a damn slow network connection we do have to care differently on how to build and ship our apps. In these circumstances it pays off and it&amp;rsquo;s absolutely essential to optimize our applications and the resulting Docker images for size.&lt;/p&gt;

&lt;p&gt;SIZE DOES MATTER&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/build-smallest-possible-docker-image/docker-image-minimal.png&#34; alt=&#34;docker-image-minimal.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re doing it right we&amp;rsquo;ll get a lot of benefits such as blasting fast download speed for updating to a new or more secured version. On wireless networks we are also reducing the costs for data transfers as well.&lt;/p&gt;

&lt;p&gt;According to my &lt;a href=&#34;https://twitter.com/quintus23m/status/834132186211180544&#34;&gt;tweet&lt;/a&gt; I&amp;rsquo;d like to start a new Docker challenge:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How small is the smallest Docker image we could build, which prints a &amp;ldquo;Hello Docker World!&amp;rdquo;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Sometimes developing directly on an IoT device can be pretty hard or nearly impossible due to the lack of enough system resources. These resources can be the amount of memory, disk space or CPU capacity - or it can be just a limited network connectivity over a low-bandwith 64kbit/sec wireless network.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s assume we do have a Raspberry Pi already deployed in the field and this IoT device has such a low-bandwidth network connection. We&amp;rsquo;re preparing our developing system to run on a bare-metal cloud server and we are transfering our build artefacts as ready-to-run Docker images regularly with each and every new release in a DevOps driven manner. For this reason we&amp;rsquo;d like to speed up the deployment with minimized Docker image sizes.&lt;/p&gt;

&lt;p&gt;Wait, I thought a Docker image can be pretty heavy with up to 1 GByte or even larger? Well, that could happen if we&amp;rsquo;re packing a whole Operating System like Ubuntu or Debian into our Docker images. But as we&amp;rsquo;re building an IoT application we should take care about that situation. A Docker image can instead be build with an app consisting of a statically linked binary and when we start it as a Docker container it will run a single Linux process only.&lt;/p&gt;

&lt;h3 id=&#34;creating-our-app-in-arm-assembly&#34;&gt;Creating our App in ARM assembly&lt;/h3&gt;

&lt;p&gt;TL;DR all the source code and build instructions can be found in this public &lt;a href=&#34;https://github.com/DieterReuter/dockerchallenge-smallest-image&#34;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here is my starting example of an assembly program which just prints a single static text string. It is written in ARM assembly language and should be compiled into a really small binary we can run on any ARMv7 device.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat hello.S
.data
msg:
    .ascii      &amp;quot;Hello Docker World!\n&amp;quot;
len = . - msg

.text

.globl _start
_start:
    /* syscall write(int fd, const void *buf, size_t count) */
    mov     %r0, $1     /* fd -&amp;gt; stdout */
    ldr     %r1, =msg   /* buf -&amp;gt; msg */
    ldr     %r2, =len   /* count -&amp;gt; len(msg) */
    mov     %r7, $4     /* write is syscall #4 */
    swi     $0          /* invoke syscall */

    /* syscall exit(int status) */
    mov     %r0, $0     /* status -&amp;gt; 0 */
    mov     %r7, $1     /* exit is syscall #1 */
    swi     $0          /* invoke syscall */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s compile and link it as a static program&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ as -o hello.o hello.S
$ ld -s -o hello hello.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show details about the binary&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ file hello
hello: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now as we do have our app as a single binary program, we can build our smallest Docker image easily from scratch. This new Docker image consists only our binary and nothing else of other components at all. But you have to know this only works if the binary is statically linked and has all necessary tools baked in.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat Dockerfile.armhf
FROM scratch
ADD hello /hello
CMD [&amp;quot;/hello&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Building the Docker image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t dieterreuter/hello -f Dockerfile.armhf .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;starting-point&#34;&gt;Starting point&lt;/h3&gt;

&lt;p&gt;With all the details I&amp;rsquo;ve shown above in this blog post I finally built a first super-small Docker image with an indicated size of 452 Bytes only.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
dieterreuter/hello           latest              b961df9c849e        27 hours ago        452 B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting this Docker container on a Raspberry Pi (or another ARMv7 machine) will print the requested text string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run dieterreuter/hello
Hello Docker World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, if you&amp;rsquo;re working with &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;Docker-for-Mac&lt;/a&gt; or &lt;a href=&#34;https://docs.docker.com/docker-for-windows/&#34;&gt;Docker-for-Windows&lt;/a&gt; you should try to run this command, too. I guess you&amp;rsquo;ll be surprised what happens on your Intel based system when you start this Docker container which is containing an ARM binary. But this is a topic for another future blog post.&lt;/p&gt;

&lt;h3 id=&#34;challenge-details&#34;&gt;Challenge details&lt;/h3&gt;

&lt;p&gt;There are not many rules for this challenge, but let&amp;rsquo;s give you some hints:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the Docker image should output the text &amp;ldquo;Hello Docker World!&amp;rdquo; on the console&lt;/li&gt;
&lt;li&gt;we measure the size of the Docker image with &lt;code&gt;docker images&lt;/code&gt; or &lt;code&gt;docker image ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;feel free to use a CPU architecture of your choice: Intel, ARMv7, ARMv8/AARCH64, &amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Please publish your results on DockerHub, source codes on GitHub and tweet about it on Twitter with the hashtag #DockerChallenge. The goal of this challenge is to get familiar with the techniques to build minimal sized Docker images not only for IoT use cases, to understand the fact that a Docker container can be just a single process, and that this process can be really extremely small itself. On the way we&amp;rsquo;ll learn to take care about all the necessary steps to reduce the size and how we can optimize our development workflow as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/build-smallest-possible-docker-image/docker-image-minimal2.png&#34; alt=&#34;docker-image-minimal2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s start the journey&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Setup Kubernetes on a Raspberry Pi Cluster easily the official way!</title>
      <link>https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/</link>
      <pubDate>Wed, 11 Jan 2017 14:03:34 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;kubernetes.io&#34;&gt;Kubernetes&lt;/a&gt; shares the pole position with Docker in the category &amp;ldquo;orchestration solutions for Raspberry Pi cluster&amp;rdquo;.
However it&amp;rsquo;s setup process has been elaborate â€“ until &lt;a href=&#34;http://blog.kubernetes.io/2016/09/how-we-made-kubernetes-easy-to-install.html&#34;&gt;v1.4 with the kubeadm announcement&lt;/a&gt;.
With that effort, Kubernetes changed this game completely and can be up and running officially within no time.&lt;/p&gt;

&lt;p&gt;I am very happy to announce that this blog post has been written in collaboration with &lt;a href=&#34;https://github.com/luxas&#34;&gt;Lucas KÃ¤ldstrÃ¶m&lt;/a&gt;, an independent maintainer of Kubernetes (his story is very interesting,  you can read it in a &lt;a href=&#34;https://www.cncf.io/blog/2016/11/29/diversity-scholarship-series-programming-journey-becoming-kubernetes-maintainer&#34;&gt;CNCF blogpost&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/raspberry-pi-cluster.png&#34; alt=&#34;SwarmClusterHA&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;why-kubernetes&#34;&gt;Why Kubernetes?&lt;/h2&gt;

&lt;p&gt;As shown in my recent &lt;a href=&#34;http://www.slideshare.net/MathiasRenner/high-availability-performance-of-kubernetes-and-docker-swarm-on-a-raspberry-pi-cluster/&#34;&gt;talk&lt;/a&gt;, there are many software suites available to manage a cluster of computers. There is Kubernetes, Docker Swarm, Mesos, OpenStack, Hadoop YARN, Nomad&amp;hellip; just to name a few.&lt;/p&gt;

&lt;p&gt;However, at Hypriot we have always been in love with tiny devices. So when working with an orchestrator, the maximum power we wanna use is what&amp;rsquo;s provided by a Raspberry Pi. Why? We have IoT networks in mind that will hold a large share in tomorrow&amp;rsquo;s IT infrastructure. At their edges, the power required for large orchestrators simply is not available.&lt;/p&gt;

&lt;p&gt;This boundary of resources leads to several requirements that need to be checked before we start getting our hands dirty with an orchestrator:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lightweight:&lt;/strong&gt; Software should be fit on a Raspberry Pi or smaller. As proofed in my talk mentioned above, Kubernetes painlessly runs on a Raspberry Pi.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARM compatible:&lt;/strong&gt; Since the ARM CPU architecture is designed for low energy consumption but still able to deliver a decent portion of power, the Raspberry Pi runs an ARM CPU. Thanks to Lucas, Kubernetes is ARM compatible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;General purpose:&lt;/strong&gt; Hadoop or Apache Spark are great for data analysis. But what if your use case changes? We prefer general purpose software that allows to run &lt;strong&gt;anything&lt;/strong&gt;. Kubernetes uses a container runtime (with Docker as the 100% supported runtime for the time being) that allows to run whatever you want.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Production ready:&lt;/strong&gt; Since we compare Kubernetes against a production ready Docker suite, let&amp;rsquo;s be fair and only choose equivalents. Kubernetes itself is production ready, and while the ARM port has some small issues, it&amp;rsquo;s working exactly as expected when going the official kubeadm route, which also will mature with time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, Kubernetes seems to be a compelling competitor to Docker Swarm. Let&amp;rsquo;s get our hands on it!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;wait-what-about-kubernetes-on-arm&#34;&gt;Wait â€“ what about &lt;em&gt;Kubernetes-on-ARM&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;If you followed the discussion of Kubernetes on ARM for some time, you probably know about Lucas&amp;rsquo; project &lt;a href=&#34;https://github.com/luxas/kubernetes-on-arm&#34;&gt;kubernetes-on-ARM&lt;/a&gt;. Since the beginning of the movement to bring Kubernetes on ARM in 2015, this project has always been the most stable and updated.&lt;/p&gt;

&lt;p&gt;However, during 2016, Lucas&amp;rsquo; contributions have successfully been merged into official Kubernetes repositories, such that there is no point any more for using the kubernetes-on-ARM project.
In fact, the features of that project are far behind of what&amp;rsquo;s now implemented in the official repos, &lt;strong&gt;and that has been Lucas&amp;rsquo; goal from the beginning.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So if you&amp;rsquo;re up to using Kubernetes, please stick to the official repos now. And as of the kubeadm documentation, &lt;strong&gt;the following setup is considered official for Kubernetes on ARM.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;at-first-flash-hypriotos-on-your-sd-cards&#34;&gt;At first: Flash HypriotOS on your SD cards&lt;/h2&gt;

&lt;p&gt;As hardware, take at least two Raspberry Pis and make sure they are connected to each other and to the Internet.&lt;/p&gt;

&lt;p&gt;First, we need an operating system. Download and flash &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases&#34;&gt;HypriotOS&lt;/a&gt;. The fastest way to download and flash HypriotOS on your SD cards is by using our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --hostname node01 https://github.com/hypriot/image-builder-rpi/releases/download/v1.4.0/hypriotos-rpi-v1.4.0.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Provision all Raspberry Pis you have like this and boot them up.&lt;/p&gt;

&lt;p&gt;Afterwards, SSH into the Raspberry Pis with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pirate@node01.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The password &lt;code&gt;hypriot&lt;/code&gt; will grant you access.&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;install-kubernetes&#34;&gt;Install Kubernetes&lt;/h2&gt;

&lt;p&gt;The installation requries root privileges. Retrieve them by&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo su -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install Kubernetes and its dependencies, only some commands are required.
First, trust the kubernetes APT key and add the official APT Kubernetes repository on every node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
$ echo &amp;quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&amp;quot; &amp;gt; /etc/apt/sources.list.d/kubernetes.list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and then just install &lt;code&gt;kubeadm&lt;/code&gt; on every node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get update &amp;amp;&amp;amp; apt-get install -y kubeadm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the previous command has been finished, initialize Kubernetes on the &lt;strong&gt;master node&lt;/strong&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm init --pod-network-cidr 10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is important that you add the &lt;code&gt;--pod-network-cidr&lt;/code&gt; command as given here, because we will use &lt;a href=&#34;https://coreos.com/flannel/docs/latest/&#34;&gt;flannel&lt;/a&gt;. Read the next notes about flannel if you wanna know why.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Some notes about flannel&lt;/strong&gt;: We picked flannel here because thatâ€™s the only available solution for ARM at the moment (this is subject to change in the future though).&lt;/p&gt;

&lt;p&gt;flannel can use and is using in this example the Kubernetes API to store metadata about the Pod CIDR allocations, and therefore we need to tell &lt;em&gt;Kubernetes&lt;/em&gt; first which subnet we want to use. The subnet we chose here is somehow fixed, because the &lt;a href=&#34;https://github.com/coreos/flannel/blob/master/Documentation/kube-flannel.yml#L25&#34;&gt;flannel configuration file&lt;/a&gt; that we&amp;rsquo;ll use later in this guide predefines the equivalent subnet. Of course, you can adapt both.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you are connected via WIFI instead of Ethernet, add &lt;code&gt;--apiserver-advertise-address=&amp;lt;wifi-ip-address&amp;gt;&lt;/code&gt; as parameter to &lt;code&gt;kubeadm init&lt;/code&gt; in order to publish Kubernetes&amp;rsquo; API via WiFi. Feel free to explore the other options that exist for &lt;code&gt;kubeadm init&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After Kubernetes has been initialized, the last lines of your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/init.png&#34; alt=&#34;init&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To start using your cluster, you need to run (as a regular user):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo cp /etc/kubernetes/admin.conf $HOME/
$ sudo chown $(id -u):$(id -g) $HOME/admin.conf
$ export KUBECONFIG=$HOME/admin.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, as told by that output, let all other nodes join the cluster via the given &lt;code&gt;kubeadm join&lt;/code&gt; command. It will look something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm join --token=bb14ca.e8bbbedf40c58788 192.168.0.34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After some seconds, you should see all nodes in your cluster when executing the following &lt;strong&gt;on the master node&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/get-nodes.png&#34; alt=&#34;k8S&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, &lt;strong&gt;we need to setup flannel v0.9.1 as the Pod network driver&lt;/strong&gt;. Do not use &lt;a href=&#34;https://github.com/coreos/flannel/releases/tag/v0.8.0&#34;&gt;v0.8.0&lt;/a&gt; due to a known &lt;a href=&#34;https://github.com/coreos/flannel/issues/773&#34;&gt;bug&lt;/a&gt; that can cause a &lt;code&gt;CrashLoopBackOff&lt;/code&gt; error. Run this &lt;strong&gt;on the master node&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sSL https://rawgit.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml | sed &amp;quot;s/amd64/arm/g&amp;quot; | kubectl create -f -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your terminal should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/flannel.png&#34; alt=&#34;k8S&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then wait until all flannel and all other cluster-internal Pods are &lt;code&gt;Running&lt;/code&gt; before you continue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get po --all-namespaces
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice, it seems like they are all &lt;code&gt;Running&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/show-namespaces.png&#34; alt=&#34;show-namespaces&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all for the setup of Kubernetes! Next, let&amp;rsquo;s actually spin up a service on the cluster!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;test-your-setup-with-a-tiny-service&#34;&gt;Test your setup with a tiny service&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start a simple service so see if the cluster actually can publish a service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run hypriot --image=hypriot/rpi-busybox-httpd --replicas=3 --port=80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command starts set of containers called &lt;strong&gt;hypriot&lt;/strong&gt; from the image &lt;strong&gt;hypriot/rpi-busybox-httpd&lt;/strong&gt; and defines the port the container listens on at &lt;strong&gt;80&lt;/strong&gt;. The service will be &lt;strong&gt;replicated with 3 containers&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Next, expose the Pods in the above created Deployment in a Service with a stable name and IP:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl expose deployment hypriot --port 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! Now, let&amp;rsquo;s check if all three desired containers are up and running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get endpoints hypriot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see three endpoints (= containers) like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/show-endpoints.png&#34; alt=&#34;show-endpoints&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s curl one of them to see if the service is up:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/curl-service.png&#34; alt=&#34;curl-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The HTML is the response of the service. Good, it&amp;rsquo;s up and running! Next, let&amp;rsquo;s see how we can access it from outside the cluster!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;finally-access-your-service-from-outside-the-cluster&#34;&gt;Finally access your service from outside the cluster&lt;/h2&gt;

&lt;p&gt;We will now deploy an example Ingress Controller to manage incoming requests from the outside world onto our tiny service. Also, in this example we we&amp;rsquo;ll use &lt;a href=&#34;https://traefik.io&#34;&gt;Traefik&lt;/a&gt; as load balancer. Read the following notes if you wanna know more about Ingress and Traefik.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;In contrast to Docker Swarm, Kubernetes itself does not provide an option to define a specific port that you can use to access a service&lt;/strong&gt;. According to Lucas this is an important design decision; routing of incoming requests should be handled by a third party, such as a load balancer or a webserver, but not by the core product. The core Kubernetes should be lean and extensible, and encourage others to build tools on top of it for their specific needs.&lt;/p&gt;

&lt;p&gt;Regarding load balancers in front of a cluster, there is &lt;a href=&#34;http://kubernetes.io/docs/user-guide/ingress/&#34;&gt;the Ingress API object&lt;/a&gt; and some sample &lt;a href=&#34;https://github.com/kubernetes/ingress&#34;&gt;Ingress Controllers&lt;/a&gt;. Ingress is a built-in way of exposing Services to the outside world via an Ingress Controller that anyone can build. An &lt;em&gt;Ingress rule&lt;/em&gt; defines how traffic should flow from the node the Ingress controller runs on to services inside of the cluster.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;First, let&amp;rsquo;s deploy traefik as load balancer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/hypriot/rpi-traefik/master/traefik-k8s-example.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Label the node you want to be the load balancer. Then the Traefik Ingress Controller will land on the node you specified. Run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl label node &amp;lt;load balancer-node&amp;gt; nginx-controller=traefik
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, create an Ingress object that makes Traefik load balance traffic on port &lt;code&gt;80&lt;/code&gt; to the &lt;code&gt;hypriot&lt;/code&gt; service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat &amp;gt; hypriot-ingress.yaml &amp;lt;&amp;lt;EOF
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: hypriot
spec:
  rules:
  - http:
      paths:
      - path: /
        backend:
          serviceName: hypriot
          servicePort: 80
EOF
$ kubectl apply -f hypriot-ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visit the loadbalancing node&amp;rsquo;s IP address in your browser and you should see a nice web page:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/kubernetes-setup-cluster/hypriot-website.png&#34; alt=&#34;curl-service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t see a website there yet, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get pods
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and make sure all hypriot Pods are in the &lt;code&gt;Running&lt;/code&gt; state.&lt;/p&gt;

&lt;p&gt;Wait until you see that all Pods are running, and a nice Hypriot website should appear!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;tear-down-the-cluster&#34;&gt;Tear down the cluster&lt;/h2&gt;

&lt;p&gt;If you wanna reset the whole cluster to the state after a fresh install, just run this on each node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubeadm reset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition, it is recommended to delete some additional files &lt;a href=&#34;http://stackoverflow.com/questions/41359224/kubernetes-failed-to-setup-network-for-pod-after-executed-kubeadm-reset/41372829#41372829&#34;&gt;as it is mentioned here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;optional-deploy-the-kubernetes-dashboard&#34;&gt;Optional: Deploy the Kubernetes dashboard&lt;/h2&gt;

&lt;p&gt;The dashboard is a wonderful interface to visualize the state of the cluster. Start it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard-arm.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the kubernetes-dashboard service to use &lt;code&gt;type: ClusterIP&lt;/code&gt; to &lt;code&gt;type: NodePort&lt;/code&gt;, see &lt;a href=&#34;https://github.com/kubernetes/dashboard/wiki/Accessing-Dashboard---1.7.X-and-above&#34;&gt;Accessing Kubernetes Dashboard&lt;/a&gt; for more details.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl -n kube-system edit service kubernetes-dashboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following command provides the port that the dashboard is exposed at on every node with the NodePort function of Services, which is another way to expose your Services to the outside of your cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl -n kube-system get service kubernetes-dashboard -o template --template=&amp;quot;{{ (index .spec.ports 0).nodePort }}&amp;quot; | xargs echo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can checkout the dashboard on any node&amp;rsquo;s IP address on that port! Make sure to use &lt;code&gt;https&lt;/code&gt; when accessing the dashboard, for example if running on port &lt;code&gt;31657&lt;/code&gt; access it at &lt;code&gt;https://node:31657&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Newer versions of the Kubernetes Dashboard require either a &lt;code&gt;Kubeconfig&lt;/code&gt; or &lt;code&gt;Token&lt;/code&gt; to view information on the dashboard. &lt;a href=&#34;https://github.com/kubernetes/dashboard/wiki/Access-control#introduction&#34;&gt;Bearer tokens&lt;/a&gt; are recommended to setup proper permissions for a user, but to test the &lt;code&gt;replicaset-controller-token&lt;/code&gt; Token may be used to test.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl -n kube-system describe secret `kubectl -n kube-system get secret | grep replicaset-controller-token | awk &#39;{print $1}&#39;` | grep token: | awk &#39;{print $2}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2 id=&#34;you-like-a-follow-up&#34;&gt;You like a follow-up?&lt;/h2&gt;

&lt;p&gt;It was our goal to show that Kubernetes indeed works well on ARM (and ARM 64-bit!). For more examples including the AMD64 platform, check out the &lt;a href=&#34;http://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;official kubeadm documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We might follow-up this blog post with a more in-depth post about the current and planned state of Kubernetes officially on ARM and more, so stay tuned and tell Lucas if that&amp;rsquo;s something you&amp;rsquo;re interested in reading.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;Mathias Renner&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/kubernetesonarm&#34;&gt;Lucas KÃ¤ldstrÃ¶m&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Setup a simple CI pipeline to build Docker images for ARM</title>
      <link>https://blog.hypriot.com/post/setup-simple-ci-pipeline-for-arm-images/</link>
      <pubDate>Tue, 10 Jan 2017 07:25:23 +0200</pubDate>
      
      <guid>https://blog.hypriot.com/post/setup-simple-ci-pipeline-for-arm-images/</guid>
      <description>&lt;p&gt;Recently I did an experiment: Can we build Docker images for ARM on ordinary cloud CI services that only provide Intel CPU&amp;rsquo;s?&lt;/p&gt;

&lt;p&gt;The idea was to get rid of self hosted CI build agents that you have to care for. If you want to provide an ARM Docker image for an open source project your task is to build it and not to setup and maintain a whole pipeline for it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/setup-simple-ci-pipeline-for-arm-images/github_yaml_arm.png&#34; alt=&#34;GitHub + YAML = ARM Docker image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;We at Hypriot have created several Dockerfiles for open source tools like &lt;a href=&#34;https://github.com/hypriot/rpi-mysql&#34;&gt;MySQL&lt;/a&gt;, &lt;a href=&#34;https://github.com/hypriot/rpi-traefik&#34;&gt;TrÃ¦fÉªk&lt;/a&gt; or &lt;a href=&#34;https://github.com/hypriot/rpi-node&#34;&gt;Node.js&lt;/a&gt; to make them available as Docker images for your ARM devices.&lt;/p&gt;

&lt;p&gt;Building such images and maintaining them over a longer period of time you have to care for updates. We are happy to receive pull requests from our community that help us updating the Dockerfiles.
But sometimes it happended that our ARM CI pipeline went offline and we had to put in some time and effort to fix it. There were pull requests lying around for some time without any CI checks.&lt;/p&gt;

&lt;p&gt;To get out of this trap I wanted a simpler CI pipeline without self hosted build agents. There are several cloud CI services like Travis, Codeship, Circle and so on, but they all only offer you Intel based CPU&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;But they have one thing in common: Just add a YAML file to your GitHub repo, connect it to their CI servers and you are done. There must be a way to use this convenient way for our ARM builds.&lt;/p&gt;

&lt;h3 id=&#34;qemu-for-the-rescue&#34;&gt;QEMU for the rescue&lt;/h3&gt;

&lt;p&gt;There are some blog posts how to use QEMU to emulate ARM on Intel CPU&amp;rsquo;s and many have even tried to build Docker images. I followed these tutorials, but many steps were needed to set up everything and it looked very complex.&lt;/p&gt;

&lt;p&gt;But after some hours of investigation I found out that all comes down to just two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;An Intel binary of QEMU for ARM must exist in the base Docker image&lt;/li&gt;
&lt;li&gt;The QEMU binary must be registered in the CI build agent&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fortunately both steps can be done in a very simple way.&lt;/p&gt;

&lt;h3 id=&#34;choose-a-base-image-with-qemu-binary&#34;&gt;Choose a base image with QEMU binary&lt;/h3&gt;

&lt;p&gt;The Raspbian Docker images from &lt;a href=&#34;https://resin.io&#34;&gt;Resin&lt;/a&gt; already have the QEMU binary in it. As these are the most common base images used you are already prepared.&lt;/p&gt;

&lt;p&gt;So if you use the following line in your &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM resin/rpi-raspbian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you are done with the first step. But what about Alpine? Well we have created a similar - still small - Docker image &lt;a href=&#34;https://github.com/hypriot/rpi-alpine&#34;&gt;hypriot/rpi-alpine&lt;/a&gt; that uses the &amp;ldquo;official&amp;rdquo; &lt;a href=&#34;https://hub.docker.com/r/armhf/alpine/&#34;&gt;armhf/alpine&lt;/a&gt; image and just append the QEMU binary. If you want to build ARM Alpine images just use this line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM hypriot/rpi-alpine
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;register-qemu-in-the-build-agent&#34;&gt;Register QEMU in the build agent&lt;/h3&gt;

&lt;p&gt;The next step is to register QEMU in the build agent. There is a Docker image available that can do this for us in just one line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm --privileged multiarch/qemu-user-static:register --reset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. Just add this line to your YAML file before the other docker commands.&lt;/p&gt;

&lt;h3 id=&#34;travis-builds-mysql-arm-image&#34;&gt;Travis builds MySQL ARM image&lt;/h3&gt;

&lt;p&gt;I have done the tests with Travis CI to build ARM images. But if you prefer another cloud CI services that offers Docker builds, it should be the same.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s put all pieces together and have a look at the final &lt;code&gt;.travis.yml&lt;/code&gt; file that is used to build the &lt;a href=&#34;https://github.com/hypriot/rpi-mysql&#34;&gt;hypriot/rpi-mysql&lt;/a&gt; Docker image for ARM.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo: required
services:
- docker
language: bash
script:
# prepare qemu
- docker run --rm --privileged multiarch/qemu-user-static:register --reset
# build image
- docker build -t hypriot/rpi-mysql .
# test image
- docker run hypriot/rpi-mysql mysql --version
# push image
- &amp;gt;
  if [ &amp;quot;$TRAVIS_BRANCH&amp;quot; == &amp;quot;master&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;$TRAVIS_PULL_REQUEST&amp;quot; == &amp;quot;false&amp;quot; ]; then
    docker login -u=&amp;quot;$DOCKER_USER&amp;quot; -p=&amp;quot;$DOCKER_PASS&amp;quot;
    TAG=$(grep &amp;quot;ENV MYSQL_VERSION&amp;quot; Dockerfile | awk &#39;NF&amp;gt;1{print $NF}&#39;)
    docker tag hypriot/rpi-mysql hypriot/rpi-mysql:$TAG
    docker push hypriot/rpi-mysql:$TAG
    docker push hypriot/rpi-mysql
  fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference to an Intel build is to just register QEMU here. The rest is activating Docker builds and do a simple docker build, test, push of that image.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;You only have to remember two things to let the cloud build your ARM images:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FROM resin/rpi-raspbian&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run --rm --privileged multiarch/qemu-user-static:register --reset&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are using this setup for more and more GitHub repos to gain speed and respond to pull requests much faster.&lt;/p&gt;

&lt;p&gt;For example we also are using &lt;a href=&#34;https://github.com/hypriot/rpi-node/blob/33d6ea9bebeca9bf31abac1b5dbc66a9f9902184/.travis.yml#L5-L8&#34;&gt;matrix builds&lt;/a&gt; for all major versions of Node.js to build new Docker images with Travis.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker is supported on the $9 C.H.I.P. computer</title>
      <link>https://blog.hypriot.com/post/docker-supported-on-chip-computer/</link>
      <pubDate>Sun, 11 Dec 2016 13:22:15 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/docker-supported-on-chip-computer/</guid>
      <description>&lt;p&gt;I guess you&amp;rsquo;re already knowing, one of the cheapest but powerful ARM boards is the $9 C.H.I.P. computer from Next Thing Co. &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt;. It has an ARMv7 1GHz CPU with 512 MByte of main memory, 4 GByte flash memory as disk storage and is equipped with onboard WiFi and bluetooth as well.
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-photo2.jpg&#34; alt=&#34;chip-photo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Some time ago I wrote a detailed blog post about how to &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt; with the help of a custom Linux kernel which I built from source for this purpose and included all the necessary kernel modules which are required to run Docker. As an outlook I mentioned that one of the kernel developers from &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt;, namely Wynter Woods &lt;a href=&#34;https://twitter.com/zerotri&#34;&gt;@zerotri&lt;/a&gt;, is working to support Docker officially.&lt;/p&gt;

&lt;p&gt;Kernel development and testing takes time and finally here it is!&lt;br&gt;
&lt;strong&gt;Docker is running on the C.H.I.P. with their latest standard kernel!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;
&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/chip-and-banana.jpg&#34; alt=&#34;chip-and-banana&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;short-overview&#34;&gt;Short overview&lt;/h3&gt;

&lt;p&gt;With the new Docker-enabled Linux kernel for the C.H.I.P. it&amp;rsquo;s really easy to install and use Docker on these tiny cute ARM devices. Basically you just have to update/upgrade to the latest software packages through the standard &lt;code&gt;apt&lt;/code&gt; package management commands, have to install Docker and you&amp;rsquo;re good to go.&lt;/p&gt;

&lt;p&gt;As I&amp;rsquo;ve already covered all these steps in detail in my post &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;Install Docker 1.12 on the $9 C.H.I.P. computer&lt;/a&gt;, we can take a shortcut and I&amp;rsquo;m explaining only the new and shorter steps.&lt;/p&gt;

&lt;h3 id=&#34;necessary-steps-to-install-docker&#34;&gt;Necessary steps to install Docker&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Flash the latest available firmware (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Connect to the C.H.I.P. via USB or UART console cable (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Configure WiFi connection (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Configure SSH to access the C.H.I.P. (see &lt;a href=&#34;http://blog.hypriot.com/post/install-docker-on-chip-computer/&#34;&gt;last post&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Checking the OS and Linux kernel version&lt;/li&gt;
&lt;li&gt;Upgrade the Linux kernel and operating system&lt;/li&gt;
&lt;li&gt;Install the Docker Engine the official way&lt;/li&gt;
&lt;li&gt;Run your first Docker Container on the C.H.I.P.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;step-5-checking-the-os-and-linux-kernel-version&#34;&gt;Step 5: Checking the OS and Linux kernel version&lt;/h4&gt;

&lt;p&gt;Here I&amp;rsquo;ve flashed the C.H.I.P. with the latest available firmware&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.13-ntc-mlc #1 SMP Thu Nov 3 01:28:54 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we can see it&amp;rsquo;s running a Linux kernel version &lt;code&gt;4.4.13-ntc-mlc&lt;/code&gt; which is compiled at &lt;code&gt;Thu Nov 3 01:28:54 UTC 2016&lt;/code&gt;. If you&amp;rsquo;ve flashed your device weeks or months before, you could maybe see a different and older kernel version.&lt;/p&gt;

&lt;h4 id=&#34;step-6-upgrade-the-linux-kernel-and-operating-system&#34;&gt;Step 6: Upgrade the Linux kernel and operating system&lt;/h4&gt;

&lt;p&gt;The new Docker-enabled Linux kernel for the C.H.I.P. computer is already available in the standard APT package repository, but it&amp;rsquo;s not yet included in the latest firmware you can flash with the &lt;a href=&#34;http://flash.getchip.com/&#34;&gt;C.H.I.P. Flasher&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In order to update/upgrade the C.H.I.P. kernel we are going the easy way and performing a complete update and upgrade process of the operating system as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update
apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see on the &lt;code&gt;apt-get upgrade&lt;/code&gt; command, you&amp;rsquo;ll be asked to confirm to install a few new software packages which also includes the new kernel packages.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
The following packages will be upgraded:
  apt apt-utils base-files chip-mali-modules-4.4.13-ntc-mlc cpio dmsetup dpkg e2fslibs e2fsprogs
  gnupg gpgv libapt-inst1.5 libapt-pkg4.12 libc-bin libc6 libcomerr2 libdevmapper1.02.1
  libdns-export100 libgcrypt20 libhogweed2 libicu52 libidn11 libirs-export91 libisc-export95
  libisccfg-export90 libnettle4 libpam-modules libpam-modules-bin libpam0g libpcre3 libss2
  libtasn1-6 libudev1 linux-image-4.4.13-ntc-mlc multiarch-support
  rtl8723bs-mp-driver-modules-4.4.13-ntc-mlc tar tzdata udev vim-common vim-tiny wget
42 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Need to get 39.8 MB of archives.
After this operation, 8562 kB of additional disk space will be used.
Do you want to continue? [Y/n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of the upgrade you have to reboot the device in order to boot the new Linux kernel. That&amp;rsquo;s all, really!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you log in again, you can see&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Linux chip 4.4.13-ntc-mlc #1 SMP Tue Dec 6 21:38:00 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the new Linux kernel has the same version, but a newer build time from &lt;code&gt;Tue Dec 6 21:38:00 UTC 2016&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;step-6-install-the-docker-engine-the-official-way&#34;&gt;Step 6: Install the Docker Engine the official way&lt;/h4&gt;

&lt;p&gt;To install Docker the official way is quite easy today because we can use the APT packages and install scripts directly provided by the &lt;a href=&#34;https://github.com/docker/docker&#34;&gt;Docker project&lt;/a&gt;. And Debian for ARMv7 is one of the officially supported OS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://get.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will take some time, but after a while the Docker Engine is installed on your C.H.I.P. computer with just a few commands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# cat /etc/apt/sources.list.d/docker.list
deb [arch=armhf] https://apt.dockerproject.org/repo debian-jessie main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the version of the Docker client command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker --version
Docker version 1.12.2, build bb80604
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the versions of the Docker client, Docker API and Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker version
Client:
 Version:      1.12.2
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   bb80604
 Built:        Tue Oct 11 17:52:51 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.2
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   bb80604
 Built:        Tue Oct 11 17:52:51 2016
 OS/Arch:      linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get some more details about the running Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@chip:~# docker info
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.12.2
Storage Driver: devicemapper
 Pool Name: docker-0:16-33578-pool
 Pool Blocksize: 65.54 kB
 Base Device Size: 10.74 GB
 Backing Filesystem: ext4
 Data file: /dev/loop0
 Metadata file: /dev/loop1
 Data Space Used: 305.7 MB
 Data Space Total: 107.4 GB
 Data Space Available: 6.596 GB
 Metadata Space Used: 729.1 kB
 Metadata Space Total: 2.147 GB
 Metadata Space Available: 2.147 GB
 Thin Pool Minimum Free Space: 10.74 GB
 Udev Sync Supported: true
 Deferred Removal Enabled: false
 Deferred Deletion Enabled: false
 Deferred Deleted Device Count: 0
 Data loop file: /var/lib/docker/devicemapper/devicemapper/data
 WARNING: Usage of loopback devices is strongly discouraged for production use. Use `--storage-opt dm.thinpooldev` to specify a custom block storage device.
 Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata
 Library Version: 1.02.90 (2014-09-01)
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: overlay bridge null host
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Security Options:
Kernel Version: 4.4.13-ntc-mlc
Operating System: Debian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 1
Total Memory: 491 MiB
Name: chip
ID: Z7U2:2DYF:G54F:2QLU:AAG3:TD7Y:YWSQ:6PRM:6ZW3:WIC5:7DEA:HFFK
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
WARNING: No swap limit support
WARNING: No kernel memory limit support
Insecure Registries:
 127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we could see, the latest Docker Engine v1.12.2 for Debian/ARMv7 is now installed and is successfully running.&lt;/p&gt;

&lt;h4 id=&#34;step-8-run-your-first-docker-container-on-the-c-h-i-p&#34;&gt;Step 8: Run your first Docker Container on the C.H.I.P.&lt;/h4&gt;

&lt;p&gt;As a last step we&amp;rsquo;d like to start a first Docker container, a small web server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
fec2773baaec570ba8b6e00296dfd11b4b4768d1b51e574d851968b9225b9d22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start your web browser and point it to the website from our Docker container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open http://192.168.2.112
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/install-docker-on-chip-computer/first-container-on-chip.jpg&#34; alt=&#34;first-container-on-chip&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;using-latest-rc-of-docker-engine&#34;&gt;Using latest RC of Docker Engine&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to get the latest Docker Engine for testing, like release candidates, you can install it pretty easily with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://test.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can upgrade your current system with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#edit /etc/apt/sources.list.d/docker.list # change &#39;main&#39; to &#39;testing&#39;
cat /etc/apt/sources.list.d/docker.list
deb [arch=armhf] https://apt.dockerproject.org/repo debian-jessie testing

apt-get update
apt-get install -y docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can test the latest available release candidate of the Docker Engine with all the newest features with Docker Swarm mode and other goodies.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker version
Client:
 Version:      1.13.0-rc3
 API version:  1.25
 Go version:   go1.7.3
 Git commit:   4d92237
 Built:        Mon Dec  5 19:00:08 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.13.0-rc3
 API version:  1.25 (minimum version 1.12)
 Go version:   go1.7.3
 Git commit:   4d92237
 Built:        Mon Dec  5 19:00:08 2016
 OS/Arch:      linux/arm
 Experimental: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tl-dr-install-docker-on-the-c-h-i-p-computer&#34;&gt;TL;DR - Install Docker on the C.H.I.P. computer&lt;/h3&gt;

&lt;p&gt;For all the impatient users, these are the minimal steps to install the latest Linux kernel and the latest Docker Engine on the C.H.I.P. computer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update
apt-get upgrade -y
reboot
curl -sSL https://get.docker.com | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DONE !!!!&lt;/p&gt;

&lt;h3 id=&#34;acknowledgments&#34;&gt;Acknowledgments&lt;/h3&gt;

&lt;p&gt;Again, I like to thank Wynter Woods &lt;a href=&#34;https://twitter.com/zerotri&#34;&gt;@zerotri&lt;/a&gt; from &lt;a href=&#34;https://twitter.com/nextthingco&#34;&gt;@NextThingCo&lt;/a&gt; for his efforts and hard work to include all the Linux kernel changes necessary to run the Docker Engine pretty slick on the C.H.I.P. computer. It&amp;rsquo;s so great to see when all the changes will be accepted and implemented in the upstream version, so everybody can use the new features without spending too much time.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s the important point to work in opensource, contributing back so that all users benefit from the results!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fix Dirty COW on Raspberry Pi the Docker way</title>
      <link>https://blog.hypriot.com/post/fix-dirty-cow-on-raspberry-pi/</link>
      <pubDate>Tue, 01 Nov 2016 13:42:20 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/fix-dirty-cow-on-raspberry-pi/</guid>
      <description>&lt;p&gt;Have you seen the latest reports about the Linux kernel security vulnerability called &amp;ldquo;Dirty COW&amp;rdquo;?
Dirty COW is a &lt;a href=&#34;http://www.theregister.co.uk/2016/10/21/linux_privilege_escalation_hole/&#34;&gt;race condition in Linux&lt;/a&gt; arising from how Copy-On-Write (the COW in the name) is handled by the kernel&amp;rsquo;s memory subsystem&amp;rsquo;s use of private mappings.&lt;/p&gt;

&lt;p&gt;The really dangerous point here is, it can be used to &lt;a href=&#34;http://www.theregister.co.uk/2016/11/01/docker_user_havent_patched_dirty_cow_yet_bad_news/&#34;&gt;escape Docker containers&lt;/a&gt;.
&lt;img src=&#34;https://blog.hypriot.com/images/fix-dirty-cow-on-raspberry-pi/dirty-cow-001.jpg&#34; alt=&#34;dirty-cow-001&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, we&amp;rsquo;re encourage you to immediately fix it with upgrading your Linux kernel on the Raspberry Pi !!!&lt;/p&gt;

&lt;p&gt;No matter if you&amp;rsquo;re running an official Raspbian or HypriotOS, please upgrade your Linux kernel to be safe again&amp;hellip;
&lt;/p&gt;

&lt;h3 id=&#34;tl-dr-fast-fixing&#34;&gt;TL;DR - Fast Fixing&lt;/h3&gt;

&lt;p&gt;For all the impatient users, here are the essential steps to upgrade your Linux kernel in an easy way on your Raspberry Pi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS&lt;/strong&gt; and &lt;strong&gt;Raspbian Jessie&lt;/strong&gt; (more details can be found &lt;a href=&#34;https://www.raspberrypi.org/blog/#fix-dirty-cow-raspberry-pi&#34;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For both operating systems it requires a system reboot to exchange the running Linux kernel in memory. But once you&amp;rsquo;ve done these easy steps you have successfully fixed the Dirty COW vulnerability.&lt;/p&gt;

&lt;h3 id=&#34;testing-for-dirty-cow-with-the-help-of-docker&#34;&gt;Testing for Dirty COW with the help of Docker&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to know whether your system is vulnerable against Dirty COW you can easily run a test with the help of a Docker Image. The complete source code can be found in my Github repo &lt;a href=&#34;https://github.com/DieterReuter/rpi-dirtycow&#34;&gt;DieterReuter/rpi-dirtycow&lt;/a&gt;, so you can build everything on your own, too.&lt;/p&gt;

&lt;p&gt;Running this single command is just absolutely easy and this is one of the benefits of Docker, you don&amp;rsquo;t have to install anything on your host machine. Just run a Docker container in a secure way and get instant results within seconds.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s do some testing on two different operating systems for the Raspberry Pi:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Raspbian Jessie LITE (2016-09-23)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve used a freshly installed Raspbian Lite for these tests and you can see, we do have a Linux kernel 4.4.21.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux raspberrypi 4.4.21-v7+ #911 SMP Thu Sep 15 14:22:38 BST 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t have the Docker Engine already installed on Raspbian, you can perform it with this few commands - YEAH, it&amp;rsquo;s just so easy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -sSL https://get.docker.com | bash
$ sudo usermod -aG docker pi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, logout and login again to get access to the Docker CLI from your default &amp;ldquo;pi&amp;rdquo; user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker --version
Docker version 1.12.3, build 6b644ec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have Docker installed, we can test against Dirty COW.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm hypriot/rpi-dirtycow
Unable to find image &#39;hypriot/rpi-dirtycow:latest&#39; locally
latest: Pulling from hypriot/rpi-dirtycow
38070c4d0c33: Pull complete
a3ed95caeb02: Pull complete
2d2e2d46b9b5: Pull complete
Digest: sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Status: Downloaded newer image for hypriot/rpi-dirtycow:latest

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are VULNERABLE!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s upgrade the Linux kernel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;ll test it again. Hopefully we&amp;rsquo;ve fixed it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux raspberrypi 4.4.26-v7+ #915 SMP Thu Oct 20 17:08:44 BST 2016 armv7l GNU/Linux

$ docker run --rm hypriot/rpi-dirtycow

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are SAFE!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New Linux kernel 4.4.26 is installed for Raspbian and Dirty COW is fixed!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Did you mentioned the different output from the &lt;code&gt;docker run&lt;/code&gt; commands? The first time, Docker has detected that the Docker Image &amp;ldquo;hypriot/rpi-dirtycow&amp;rdquo; is not on the machine and downloads/pulls the required image layers. The second time it can just start the Docker container.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HypriotOS 1.1.0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;m using the latest HypriotOS 1.1.0 release, but the Linux kernel upgrade works even for an older 0.8 release.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux black-pearl 4.4.24-hypriotos-v7+ #1 SMP PREEMPT Tue Oct 11 17:15:58 UTC 2016 armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test for Dirty COW.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time docker run --rm hypriot/rpi-dirtycow
Unable to find image &#39;hypriot/rpi-dirtycow:latest&#39; locally
latest: Pulling from hypriot/rpi-dirtycow
38070c4d0c33: Pull complete
a3ed95caeb02: Pull complete
2d2e2d46b9b5: Pull complete
Digest: sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Status: Downloaded newer image for hypriot/rpi-dirtycow:latest

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are VULNERABLE!!!

real	0m14.514s
user	0m0.200s
sys	0m0.180s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You can see, it takes just under 15 seconds to pull the Docker Image and to perform the test against the Dirty COW vulnerability. We didn&amp;rsquo;t installed anything on the host machine for these tests and we can get rid of the Docker image later on and clean our host system easily.&lt;/p&gt;

&lt;p&gt;Upgrade the Linux kernel for HypriotOS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install raspberrypi-kernel
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we have the latest Linux kernel 4.4.27 for HypriotOS installed and we&amp;rsquo;re safe again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -a
Linux black-pearl 4.4.27-hypriotos-v7+ #1 SMP PREEMPT Fri Oct 28 09:06:49 UTC 2016 armv7l GNU/Linux

$ time docker run --rm hypriot/rpi-dirtycow

Test for Dirty Cow:
  $ echo &amp;quot;You are SAFE!          &amp;quot; &amp;gt; foo
  $ chmod 404 foo
  $ ./dirtyc0w foo &amp;quot;You are VULNERABLE!!!&amp;quot; &amp;amp;
  $ sleep 2
  $ cat foo
You are SAFE!

real	0m4.504s
user	0m0.100s
sys	0m0.050s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we&amp;rsquo;ll remove the Docker Image we&amp;rsquo;ve used for the tests and free some disk space.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
hypriot/rpi-dirtycow   latest              31229be9ea1d        3 days ago          5.512 MB

$ docker rmi -f 31229be9ea1d
Untagged: hypriot/rpi-dirtycow:latest
Untagged: hypriot/rpi-dirtycow@sha256:065d979dd3c48e6488044206ec782628ecf241ef02104610c076949d9881ad0d
Deleted: sha256:31229be9ea1d01ed2df47cc23ab50efdc84be3b49572bb4b6047a449dea4e596

$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This is another great advantage by Docker - get rid of all the tools we don&amp;rsquo;t need anymore.&lt;/p&gt;

&lt;h3 id=&#34;conclusion-upgrade-your-system-regularly&#34;&gt;Conclusion: upgrade your system regularly&lt;/h3&gt;

&lt;p&gt;Your Raspberry Pi system is now SAFE again. In the future don&amp;rsquo;t forget to upgrade it from time to time. On both operating systems, Raspbian and HypriotOS, you can do the upgrade procedure with these few commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And with this way you&amp;rsquo;ll get some other tools updated as well, like the Docker Engine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker version
Client:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 19:06:36 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.12.3
 API version:  1.24
 Go version:   go1.6.3
 Git commit:   6b644ec
 Built:        Wed Oct 26 19:06:36 2016
 OS/Arch:      linux/arm
HypriotOS/armv7: pirate@black-pearl in ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all and STAY SAFE !!!&lt;/p&gt;

&lt;h3 id=&#34;feedback-please&#34;&gt;Feedback, please&lt;/h3&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Visualize your Raspberry Pi containers with Portainer or UI for Docker</title>
      <link>https://blog.hypriot.com/post/new-docker-ui-portainer/</link>
      <pubDate>Mon, 31 Oct 2016 15:18:33 +0100</pubDate>
      
      <guid>https://blog.hypriot.com/post/new-docker-ui-portainer/</guid>
      <description>&lt;p&gt;At home I use some Raspberry Pi&amp;rsquo;s for some home network services, and I run
these services inside Docker containers. From time to time I want to see or
manage one of these containers. But I&amp;rsquo;m too lazy to get to my laptop and use
the Docker CLI for that. There are two nice Docker UI&amp;rsquo;s to access your Docker engine with a web browser. Let&amp;rsquo;s have a look at both.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-docker.png&#34; alt=&#34;Portainer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;ui-for-docker-formerly-known-as-dockerui&#34;&gt;UI for Docker, formerly known as DockerUI&lt;/h2&gt;

&lt;p&gt;I have started using the DockerUI, an open source project from Michael Crosby and Kevan Ahlquist. You can find the source code on GitHub at &lt;a href=&#34;https://github.com/kevana/ui-for-docker&#34;&gt;https://github.com/kevana/ui-for-docker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://github.com/StefanScherer/docker-at-home/blob/eb451b954809393e8536259aff6daf27bfb7b7b8/docker-compose.yml#L27-L35&#34;&gt;my home setup&lt;/a&gt; I use Docker Compose to configure how to run my services.&lt;/p&gt;

&lt;p&gt;This is my configuration to start the UI so I can reach it on port 80 of the Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ui:
  image: hypriot/rpi-dockerui
  restart: always
  volumes:
    - &#39;/var/run/docker.sock:/var/run/docker.sock&#39;
  expose:
    - 9000
  ports:
    - 80:9000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we provide a Docker image &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-dockerui/&#34;&gt;hypriot/rpi-dockerui&lt;/a&gt; on the Docker hub so it is very easy to use it in your environment.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s have a look at the dashboard which shows you an overview of your running or stopped containers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-dashboard.png&#34; alt=&#34;DockerUI Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can click on each container and see more details and so some actions with them like stopping and starting them again.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-container.png&#34; alt=&#34;DockerUI Container&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The UI provides some more views to list for example all local Docker images and information about your Docker engine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/dockerui-images.png&#34; alt=&#34;DockerUI Images&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;portainer&#34;&gt;Portainer&lt;/h2&gt;

&lt;p&gt;Last week I found &lt;a href=&#34;http://portainer.io&#34;&gt;portainer.io&lt;/a&gt; which also looks very good. They provide Docker images for Linux and Windows, &lt;del&gt;but not for ARM right now&lt;/del&gt; and as well an image for ARM.&lt;/p&gt;

&lt;p&gt;The source code is also available on GitHub &lt;a href=&#34;https://github.com/portainer/portainer&#34;&gt;https://github.com/portainer/portainer&lt;/a&gt; and it&amp;rsquo;s based on the work of DockerUI.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/portainer/portainer/pull/299&#34;&gt;pull request&lt;/a&gt; to add Linux ARM support was merged and now you can get the Docker image for the Rapsberry Pi using the image &lt;a href=&#34;https://hub.docker.com/r/portainer/portainer/&#34;&gt;portainer/portainer:arm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Just use the same Docker Compose sample from above and replace the image name. Killing the old container and running a new one with &lt;code&gt;docker-compose up -d ui&lt;/code&gt; you have Portainer up and running.&lt;/p&gt;

&lt;p&gt;The dashboard also gives you an overview of all running containers, all images etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-dashboard.png&#34; alt=&#34;Portainer Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the container list you can see all running and stopped containers as well as some actions you can do with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-container.png&#34; alt=&#34;Portainer Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clicking on one of the running containers you have access to the details, environment variables, port mappings, volumes.
You can also access some CPU/memory and network statistics as well as the logs of your container, as well as the processes running inside the container.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.hypriot.com/images/dockerui-portainer/portainer-stats.png&#34; alt=&#34;Portainer Stats&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you want to remote control your Raspberry Pi Docker containers from a nice Web UI, then try
one of these prebuilt Docker images. Of course be aware that everyone in your home network
is able to manipulate your Docker containers with it as there is no login dialog.
But for some private projects it is still an advantage to simplify starting and stopping containers from your mobile phone.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>